# Task: WebRTC Library (libdatachannel) Integration

**Objective:** Integrate the `libdatachannel` library into the C++ audio engine to enable MP3 audio streaming over WebRTC data channels, primarily for browser-based clients.

**Parent Plan Section:** I. Core Technologies & Libraries Selection/Integration

**Files to Modify/Create:**

*   **`setup.py`:**
    *   Modify to include `libdatachannel` and its dependencies (e.g., OpenSSL, usrsctp, libjuice) as C/C++ library dependencies for the Python extension.
    *   This will involve configuring include paths, library paths, and library names for these dependencies. This can be complex and might require vendoring or ensuring system-wide availability of these libraries.
*   **New C++ Files (e.g., `src/audio_engine/webrtc_sender.h`, `src/audio_engine/webrtc_sender.cpp` - as per `task_08_cpp_modular_sender.md`):**
    *   This class will implement the `INetworkSender` interface.
    *   **`WebRTCSender` Class:**
        *   Manages a `libdatachannel::PeerConnection` for each WebRTC sink.
        *   Handles the WebRTC signaling process (offer/answer exchange, ICE candidate gathering) by interfacing with `AudioManager` (which will bridge to Python for actual signaling).
            *   `initialize(const SinkConfig& config, std::function<void(const std::string& type, const std::string& sdp_or_candidate)> signaling_callback)`: Takes a callback to send signaling messages (SDP, ICE candidates) to `AudioManager`.
            *   `process_signaling_message(const std::string& type, const std::string& sdp_or_candidate)`: Method for `AudioManager` to push incoming signaling messages (offers, answers, candidates from Python) to this sender.
        *   Creates a `libdatachannel::DataChannel` configured for reliable, ordered delivery.
        *   `send_mp3_frame(const uint8_t* mp3_data, size_t data_len)`: Sends MP3 data over the established data channel.
        *   Sets up `libdatachannel` callbacks for:
            *   Local SDP offer/answer generation.
            *   Local ICE candidate generation.
            *   Data channel open/closed/error events.
            *   Connection state changes.
*   **`src/audio_engine/sink_audio_mixer.h` / `src/audio_engine/sink_audio_mixer.cpp`:**
    *   As per `task_08_cpp_modular_sender.md`, `SinkAudioMixer` will instantiate `WebRTCSender` if `SinkConfig::protocol_type` is `WEBRTC`.
    *   When MP3 data is encoded by LAME, it will be passed to `WebRTCSender::send_mp3_frame()`.
*   **`src/audio_engine/audio_manager.h` / `src/audio_engine/audio_manager.cpp`:**
    *   `AudioManager` will manage the lifecycle of `WebRTCSender` instances (via `SinkAudioMixer`'s `INetworkSender` member).
    *   **Signaling Bridge:**
        *   `AudioManager` will need methods callable from Python (via pybind11) to relay signaling messages *to* a specific `WebRTCSender` instance (identified by sink ID). E.g., `handle_webrtc_signaling_message(const std::string& sink_id, const std::string& type, const std::string& message)`.
        *   `AudioManager` will need a mechanism (e.g., a queue or callback registered by Python) to send signaling messages generated by `WebRTCSender` (local SDP, local ICE candidates) *from* C++ *to* the Python SIP/Signaling server.
*   **`src/audio_engine/bindings.cpp`:**
    *   Add pybind11 functions for the signaling bridge:
        *   Expose `AudioManager::handle_webrtc_signaling_message`.
        *   Provide a way for Python to register a callback function with `AudioManager` that C++ can invoke to send signaling data (like local ICE candidates or SDP answers) up to Python. Example: `audio_manager.set_webrtc_signaling_callback(python_callback_function)`.
*   **`src/audio_engine/audio_types.h` / `src/configuration/audio_engine_config_types.h`:**
    *   Ensure `SinkConfig::protocol_type` enum includes `WEBRTC`.
    *   `SinkConfig` might include fields for STUN/TURN server configuration if these are to be passed from Python to C++, though `libdatachannel` can also be configured globally or accept these during peer connection setup.
*   **`src/configuration/configuration_manager.py` (and `AudioEngineConfigApplier`):**
    *   Python's `SinkDescription` and its nested `WebRTCConfig` will hold STUN/TURN server details.
    *   `AudioEngineConfigApplier` will pass these to `AudioManager` when a WebRTC sink is configured.

**Detailed Steps:**

1.  **Build System (`setup.py`):** Integrate `libdatachannel` and its dependencies (OpenSSL, usrsctp, etc.) into the C++ extension build process. This is often the most challenging part for WebRTC libraries.
2.  **Implement `WebRTCSender` Class:**
    *   Encapsulate `libdatachannel::PeerConnection` and `libdatachannel::DataChannel`.
    *   Implement methods for creating connections, processing incoming signaling messages (SDP offers/answers, ICE candidates), and generating local signaling messages.
    *   Use `libdatachannel` callbacks for SDP generation, ICE candidate gathering, data channel status, and connection state. These callbacks will use the signaling callback provided to `WebRTCSender` to send messages to `AudioManager`.
    *   Implement `send_mp3_frame()` to send data on an open data channel.
3.  **Implement Signaling Bridge in `AudioManager`:**
    *   `handle_webrtc_signaling_message()`: Receives messages from Python, finds the target `WebRTCSender` (via `SinkAudioMixer`), and calls its processing method.
    *   `set_webrtc_signaling_callback()`: Allows Python to register a callback. `AudioManager` stores this.
    *   The callback passed to `WebRTCSender` instances will invoke this Python-registered callback to send messages (local SDP, ICE candidates) from C++ to Python.
4.  **Integrate `WebRTCSender` with `SinkAudioMixer`:**
    *   `SinkAudioMixer` instantiates `WebRTCSender` for WebRTC sinks, passing the signaling callback mechanism.
    *   MP3 data from LAME is routed to `WebRTCSender::send_mp3_frame()`.
5.  **Pybind11 Bindings:** Create Python bindings for `AudioManager`'s signaling bridge methods.
6.  **Configuration Updates:** Ensure `protocol_type` and WebRTC-specific configs (STUN/TURN) can be set in Python and passed to C++.
7.  **Testing:**
    *   Use a WebRTC test page (e.g., `libdatachannel` examples, or a simple custom page) as a client.
    *   The Python backend (FastAPI + SIP server) will act as the signaling intermediary.
    *   Test SDP offer/answer exchange and ICE candidate negotiation.
    *   Verify data channel establishment and MP3 streaming.
    *   Test with STUN/TURN servers if NAT traversal is required.

**Considerations:**

*   **`libdatachannel` Dependencies:** Managing the build and linkage of `libdatachannel` and its dependencies (OpenSSL, usrsctp, libjuice) within `setup.py` will require care.
*   **Signaling Complexity:** The signaling flow (Web Client <-> Python/SIP <-> C++/AudioManager <-> C++/WebRTCSender) is intricate. Clear interfaces and message formats are essential.
*   **Error Handling:** Implement robust error handling for all `libdatachannel` operations and signaling steps.
*   **Thread Safety:** Ensure callbacks from `libdatachannel` into `WebRTCSender` and then potentially to `AudioManager` are handled in a thread-safe manner, especially when interacting with Python via pybind11 (GIL considerations for Python callback).

**Acceptance Criteria:**

*   ScreamRouter can establish a WebRTC data channel with a compatible web client via SIP-based signaling.
*   MP3 audio is successfully streamed from ScreamRouter to the web client.
*   `setup.py` correctly builds the C++ extension with `libdatachannel` and its dependencies.
*   Signaling messages are correctly relayed between the web client, Python, and C++.
