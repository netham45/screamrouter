// src/configuration/audio_engine_config_types.h
#ifndef AUDIO_ENGINE_CONFIG_TYPES_H
#define AUDIO_ENGINE_CONFIG_TYPES_H

#include <string>
#include <vector>
#include <map> 
#include <set> 
#include "audio_constants.h" // Include directly for MAX_CHANNELS, EQ_BANDS
#include "audio_types.h" // For audio::SinkConfig, screamrouter::audio::CppSpeakerLayout
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

// #include "audio_processor.h" // No longer needed for EQ_BANDS here

namespace screamrouter {
namespace config {

// CppSpeakerLayout is now defined in audio_types.h

struct AppliedSourcePathParams {
    std::string path_id;                 // e.g., "DesktopAudio_to_LivingRoomSpeakers"
    std::string source_tag;              // e.g., "192.168.1.100"
    std::string target_sink_id;          // e.g., "LivingRoomSpeakers"
    
    float volume = 1.0f;
    std::vector<float> eq_values;        // Should be initialized to EQ_BANDS size
    bool eq_normalization = true;
    bool volume_normalization = false;
    int delay_ms = 0;
    float timeshift_sec = 0.0f;
    
    int target_output_channels;
    int target_output_samplerate;
    
    std::string generated_instance_id; // Filled by C++ applier

    // Constructor to initialize eq_values correctly
    // Assuming audio::EQ_BANDS is accessible here. If not, a default size might be needed
    // or this initialization needs to be done carefully.
    // The spec for audio_types.h (bindings.cpp) shows EQ_BANDS is a constant.
    // EQ_BANDS is likely a global constant from audio_processor.h

    std::map<int, screamrouter::audio::CppSpeakerLayout> speaker_layouts_map; // New member, CppSpeakerLayout is in screamrouter::audio namespace
    // Old members removed:
    // std::vector<std::vector<float>> speaker_mix_matrix;
    // bool use_auto_speaker_mix;

    AppliedSourcePathParams() : volume(1.0f), delay_ms(0), timeshift_sec(0.0f),
                                target_output_channels(2), target_output_samplerate(48000) {
      eq_values.assign(screamrouter::audio::EQ_BANDS, 1.0f); // Default flat EQ
      // speaker_layouts_map will be default-initialized (empty map)
  }
};

struct AppliedSinkParams {
    std::string sink_id;
    screamrouter::audio::SinkConfig sink_engine_config; // The C++ struct from audio_types.h
    std::vector<std::string> connected_source_path_ids; // List of path_id from AppliedSourcePathParams
};

struct DesiredEngineState {
        std::vector<AppliedSourcePathParams> source_paths;
        std::vector<AppliedSinkParams> sinks;
    };
    
    inline void bind_config_types(pybind11::module_ &m) {
        namespace py = pybind11;
    
        py::class_<AppliedSourcePathParams>(m, "AppliedSourcePathParams", "Parameters for a specific source-to-sink audio path")
            .def(py::init<>()) // Bind default constructor (initializes eq_values)
            .def_readwrite("path_id", &AppliedSourcePathParams::path_id, "Unique ID for this path (e.g., source_tag_to_sink_id)")
            .def_readwrite("source_tag", &AppliedSourcePathParams::source_tag, "Original source identifier (e.g., IP address)")
            .def_readwrite("target_sink_id", &AppliedSourcePathParams::target_sink_id, "ID of the target sink for this path")
            .def_readwrite("volume", &AppliedSourcePathParams::volume, "Volume for this path")
            .def_readwrite("eq_values", &AppliedSourcePathParams::eq_values, "Equalizer settings for this path (list/vector of floats)")
            .def_readwrite("eq_normalization", &AppliedSourcePathParams::eq_normalization, "Enable or disable equalizer normalization")
            .def_readwrite("volume_normalization", &AppliedSourcePathParams::volume_normalization, "Enable or disable volume normalization")
            .def_readwrite("delay_ms", &AppliedSourcePathParams::delay_ms, "Delay in milliseconds for this path")
            .def_readwrite("timeshift_sec", &AppliedSourcePathParams::timeshift_sec, "Timeshift in seconds for this path")
            .def_readwrite("target_output_channels", &AppliedSourcePathParams::target_output_channels, "Required output channels for the target sink")
            .def_readwrite("target_output_samplerate", &AppliedSourcePathParams::target_output_samplerate, "Required output sample rate for the target sink")
            .def_readwrite("generated_instance_id", &AppliedSourcePathParams::generated_instance_id, "(Read-only from Python perspective) Instance ID generated by C++")
            .def_readwrite("speaker_layouts_map", &AppliedSourcePathParams::speaker_layouts_map, "Map of input channel counts to CppSpeakerLayout objects");
    
        py::class_<AppliedSinkParams>(m, "AppliedSinkParams", "Parameters for a configured sink")
            .def(py::init<>()) // Bind default constructor
            .def_readwrite("sink_id", &AppliedSinkParams::sink_id, "Unique identifier for the sink")
            .def_readwrite("sink_engine_config", &AppliedSinkParams::sink_engine_config, "C++ SinkConfig parameters for AudioManager")
            .def_readwrite("connected_source_path_ids", &AppliedSinkParams::connected_source_path_ids, "List of path_ids connected to this sink");
    
        py::class_<DesiredEngineState>(m, "DesiredEngineState", "Represents the complete desired state of the audio engine")
            .def(py::init<>()) // Bind default constructor
            .def_readwrite("source_paths", &DesiredEngineState::source_paths, "List of all desired AppliedSourcePathParams")
            .def_readwrite("sinks", &DesiredEngineState::sinks, "List of all desired AppliedSinkParams");
    }
    
    } // namespace config
    } // namespace screamrouter

#endif // AUDIO_ENGINE_CONFIG_TYPES_H
