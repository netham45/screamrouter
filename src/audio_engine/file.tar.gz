audio_component.h0000644000000000000000000000466315005720006013114 0ustar  rootroot#ifndef AUDIO_COMPONENT_H
#define AUDIO_COMPONENT_H

#include <thread>
#include <atomic>
#include <string> // For potential ID/name later

namespace screamrouter {
namespace audio {

/**
 * @brief Abstract base class for core audio processing components.
 *        Provides a common interface for lifecycle management (start, stop)
 *        and thread control.
 */
class AudioComponent {
public:
    /**
     * @brief Virtual destructor is crucial for base classes with virtual methods.
     */
    virtual ~AudioComponent() = default;

    // Prevent copying/moving to avoid slicing and ownership issues
    AudioComponent(const AudioComponent&) = delete;
    AudioComponent& operator=(const AudioComponent&) = delete;
    AudioComponent(AudioComponent&&) = delete;
    AudioComponent& operator=(AudioComponent&&) = delete;

    /**
     * @brief Starts the component's processing thread.
     *        Implementations should set stop_flag_ to false and launch
     *        component_thread_ executing the run() method.
     */
    virtual void start() = 0;

    /**
     * @brief Signals the component's processing thread to stop and joins it.
     *        Implementations should set stop_flag_ to true, potentially notify
     *        any condition variables in run(), and join component_thread_.
     */
    virtual void stop() = 0;

    /**
     * @brief Checks if the component's thread is currently running (i.e., started and not stopped).
     * @return true if the component is considered active, false otherwise.
     */
    bool is_running() const {
        // Check if thread is joinable (implies it was started and hasn't been joined yet)
        // and if the stop flag hasn't been set. This is an approximation.
        // A more robust check might involve another atomic flag set in start/stop.
        return component_thread_.joinable() && !stop_flag_;
    }

protected:
    // Protected constructor for use by derived classes only
    AudioComponent() : stop_flag_(false) {}

    /**
     * @brief The main processing loop executed by the component's thread.
     *        Implementations should contain the core logic and periodically
     *        check stop_flag_ to allow for graceful termination.
     */
    virtual void run() = 0;

    std::thread component_thread_;
    std::atomic<bool> stop_flag_;

    // Potential future additions:
    // std::string component_id_;
};

} // namespace audio
} // namespace screamrouter

#endif // AUDIO_COMPONENT_H
audio_manager.cpp0000644000000000000000000005420615006163324013062 0ustar  rootroot#include "audio_manager.h"
#include <iostream> // For logging
#include <stdexcept>
#include <utility> // For std::move
#include <system_error> // For thread errors

// Use namespaces for clarity
namespace screamrouter { namespace audio { using namespace utils; } }
using namespace screamrouter::audio;
using namespace screamrouter::utils;

// Simple logger helper (replace with a proper logger if available)
#define LOG_AM(msg) std::cout << "[AudioManager] " << msg << std::endl
#define LOG_ERROR_AM(msg) std::cerr << "[AudioManager Error] " << msg << std::endl


AudioManager::AudioManager() : running_(false) {
    LOG_AM("Created.");
}

AudioManager::~AudioManager() {
    LOG_AM("Destroying...");
    if (running_) {
        shutdown(); // Ensure shutdown is called if not done explicitly
    }
    // Ensure notification thread is joined if it was started
    if (notification_thread_.joinable()) {
         LOG_ERROR_AM("Notification thread still joinable in destructor! Shutdown might have failed.");
         // Attempt to signal stop again just in case
         if (new_source_notification_queue_) new_source_notification_queue_->stop();
         notification_thread_.join();
    }
    LOG_AM("Destroyed.");
}

bool AudioManager::initialize(int rtp_listen_port) {
    LOG_AM("Initializing...");
    std::lock_guard<std::mutex> lock(manager_mutex_); // Protect shared state during init

    if (running_) {
        LOG_AM("Already initialized.");
        return true;
    }

    // 1. Create Notification Queue
    new_source_notification_queue_ = std::make_shared<NotificationQueue>();

    // 2. Create and Start RTP Receiver
    try {
        RtpReceiverConfig rtp_config;
        rtp_config.listen_port = rtp_listen_port;
        rtp_receiver_ = std::make_unique<RtpReceiver>(rtp_config, new_source_notification_queue_);
        rtp_receiver_->start(); // This internally creates the socket and thread
        // Check if start was successful (basic check, might need more robust mechanism)
        // A short sleep might be needed to allow the thread to actually start and potentially fail setup
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        if (!rtp_receiver_->is_running()) {
             throw std::runtime_error("RtpReceiver failed to start or socket setup failed.");
        }
    } catch (const std::exception& e) {
        LOG_ERROR_AM("Failed to initialize RtpReceiver: " + std::string(e.what()));
        rtp_receiver_.reset(); // Clean up partially created receiver
        new_source_notification_queue_.reset();
        return false;
    }

    // 3. Start Notification Processing Thread
    try {
        notification_thread_ = std::thread(&AudioManager::process_notifications, this);
    } catch (const std::system_error& e) {
        LOG_ERROR_AM("Failed to start notification thread: " + std::string(e.what()));
        rtp_receiver_->stop(); // Stop the receiver if notification thread failed
        rtp_receiver_.reset();
        new_source_notification_queue_.reset();
        return false;
    }

    running_ = true;
    LOG_AM("Initialization successful.");
    return true;
}

void AudioManager::shutdown() {
    LOG_AM("Shutting down...");
    { // Scope for lock
        std::lock_guard<std::mutex> lock(manager_mutex_);
        if (!running_) {
            LOG_AM("Already shut down.");
            return;
        }
        running_ = false; // Signal all loops to stop

        // Stop notification queue first to prevent processing new sources during shutdown
        if (new_source_notification_queue_) {
            new_source_notification_queue_->stop();
        }
    } // Release lock before joining threads

    // Join notification thread
    if (notification_thread_.joinable()) {
        LOG_AM("Joining notification thread...");
        try {
             notification_thread_.join();
             LOG_AM("Notification thread joined.");
        } catch (const std::system_error& e) {
             LOG_ERROR_AM("Error joining notification thread: " + std::string(e.what()));
        }
    }

    // Now acquire lock again to stop components safely
    std::lock_guard<std::mutex> lock(manager_mutex_);

    // Stop RTP Receiver
    if (rtp_receiver_) {
        LOG_AM("Stopping RTP Receiver...");
        rtp_receiver_->stop();
        rtp_receiver_.reset(); // Destroy after stopping
        LOG_AM("RTP Receiver stopped.");
    }

    // Stop all Source Processors
    LOG_AM("Stopping Source Processors...");
    for (auto& pair : sources_) {
        if (pair.second) {
            pair.second->stop();
        }
    }
    sources_.clear(); // Destroy after stopping all
    // Clear associated queues
    rtp_to_source_queues_.clear();
    source_to_sink_queues_.clear();
    command_queues_.clear();
    LOG_AM("Source Processors stopped.");


    // Stop all Sink Mixers
    LOG_AM("Stopping Sink Mixers...");
    for (auto& pair : sinks_) {
        if (pair.second) {
            pair.second->stop();
        }
    }
    sinks_.clear(); // Destroy after stopping all
    mp3_output_queues_.clear(); // Clear MP3 queues
    sink_configs_.clear();
    LOG_AM("Sink Mixers stopped.");

    // Clear source configurations
    source_configs_.clear();

    // Clear notification queue pointer
    new_source_notification_queue_.reset();

    LOG_AM("Shutdown complete.");
}

bool AudioManager::add_sink(const SinkConfig& config) {
    LOG_AM("Adding sink: " + config.id);
    std::lock_guard<std::mutex> lock(manager_mutex_);

    if (!running_) {
        LOG_ERROR_AM("Cannot add sink, manager is not running.");
        return false;
    }

    if (sinks_.count(config.id)) {
        LOG_ERROR_AM("Sink ID already exists: " + config.id);
        return false;
    }

    // 1. Create MP3 Queue unconditionally
    // The SinkAudioMixer will handle LAME initialization based on the queue pointer.
    // The Python layer decides whether to *consume* the data via get_mp3_data.
    auto mp3_queue = std::make_shared<Mp3Queue>();
    mp3_output_queues_[config.id] = mp3_queue;
    LOG_AM("MP3 output queue created for sink: " + config.id);

    // 2. Create SinkMixerConfig (copying relevant fields from SinkConfig)
    SinkMixerConfig mixer_config;
    mixer_config.sink_id = config.id;
    mixer_config.output_ip = config.output_ip;
    mixer_config.output_port = config.output_port;
    mixer_config.output_bitdepth = config.bitdepth;
    mixer_config.output_samplerate = config.samplerate;
    mixer_config.output_channels = config.channels;
    mixer_config.output_chlayout1 = config.chlayout1;
    mixer_config.output_chlayout2 = config.chlayout2;
    mixer_config.use_tcp = config.use_tcp;

    // 3. Create and Start SinkAudioMixer
    std::unique_ptr<SinkAudioMixer> new_sink;
    try {
        new_sink = std::make_unique<SinkAudioMixer>(mixer_config, mp3_queue);
        new_sink->start();
         // Basic check if start succeeded
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        if (!new_sink->is_running()) {
             throw std::runtime_error("SinkAudioMixer failed to start.");
        }
    } catch (const std::exception& e) {
        LOG_ERROR_AM("Failed to create or start SinkAudioMixer for " + config.id + ": " + std::string(e.what()));
        if (config.enable_mp3) {
            mp3_output_queues_.erase(config.id); // Clean up MP3 queue if mixer failed
        }
        // Clean up MP3 queue if mixer failed (even if created unconditionally)
        mp3_output_queues_.erase(config.id);
        return false;
    }

    // 4. Connect existing sources to the new sink
    LOG_AM("Connecting existing sources to new sink " + config.id);
    for (const auto& pair : sources_) {
        const std::string& source_tag = pair.first;
        auto it = source_to_sink_queues_.find(source_tag);
        if (it != source_to_sink_queues_.end()) {
            LOG_AM("Connecting source " + source_tag + " to sink " + config.id);
            new_sink->add_input_queue(source_tag, it->second);
        } else {
             LOG_ERROR_AM("Consistency error: Source " + source_tag + " exists but its output queue not found.");
        }
    }

    // 5. Store the new sink and its config
    sinks_[config.id] = std::move(new_sink);
    sink_configs_[config.id] = config; // Store original Python-facing config

    LOG_AM("Sink " + config.id + " added successfully.");
    return true;
}

bool AudioManager::remove_sink(const std::string& sink_id) {
    LOG_AM("Removing sink: " + sink_id);
    std::unique_ptr<SinkAudioMixer> sink_to_remove; // Hold pointer outside lock for destruction

    { // Scope for lock
        std::lock_guard<std::mutex> lock(manager_mutex_);
        if (!running_) {
             LOG_ERROR_AM("Cannot remove sink, manager is not running.");
             return false;
        }

        auto it = sinks_.find(sink_id);
        if (it == sinks_.end()) {
            LOG_ERROR_AM("Sink not found: " + sink_id);
            return false;
        }

        // Move ownership to local variable before erasing from map
        sink_to_remove = std::move(it->second);
        sinks_.erase(it);
        sink_configs_.erase(sink_id);
        mp3_output_queues_.erase(sink_id); // Remove MP3 queue if it exists
    } // Lock released

    // Stop the sink outside the lock
    if (sink_to_remove) {
        sink_to_remove->stop();
        // sink_to_remove is destroyed here when it goes out of scope
    }

    LOG_AM("Sink " + sink_id + " removed successfully.");
    return true;
}

bool AudioManager::configure_source(const SourceConfig& config) {
    LOG_AM("Configuring source: " + config.tag);
    std::lock_guard<std::mutex> lock(manager_mutex_);

    if (!running_) {
        LOG_ERROR_AM("Cannot configure source, manager is not running.");
        return false;
    }

    // Check if source processor already exists for this tag
    if (sources_.count(config.tag)) {
        LOG_ERROR_AM("Source processor already exists for tag: " + config.tag + ". Use update methods or remove first.");
        // Optionally, could update existing source here instead of erroring
        return false;
    }

    // Validate EQ size
    SourceConfig validated_config = config; // Make a copy to potentially modify
    if (!validated_config.initial_eq.empty() && validated_config.initial_eq.size() != EQ_BANDS) {
        LOG_ERROR_AM("Invalid initial EQ size for source " + validated_config.tag + ". Expected " + std::to_string(EQ_BANDS) + ", got " + std::to_string(validated_config.initial_eq.size()) + ". Resetting to flat.");
        validated_config.initial_eq.assign(EQ_BANDS, 1.0f);
    } else if (validated_config.initial_eq.empty()) {
         LOG_AM("No initial EQ provided for source " + validated_config.tag + ". Setting to flat.");
         validated_config.initial_eq.assign(EQ_BANDS, 1.0f);
    }

    // Store the validated configuration
    source_configs_[validated_config.tag] = validated_config;
    LOG_AM("Source configuration stored for " + validated_config.tag);

    // --- Create the source processor immediately ---
    const std::string& source_tag = validated_config.tag;

    // 2. Create necessary queues for this source
    auto rtp_queue = std::make_shared<PacketQueue>();
    auto sink_queue = std::make_shared<ChunkQueue>();
    auto cmd_queue = std::make_shared<CommandQueue>();

    rtp_to_source_queues_[source_tag] = rtp_queue;
    source_to_sink_queues_[source_tag] = sink_queue;
    command_queues_[source_tag] = cmd_queue;

    // 3. Create SourceProcessorConfig
    SourceProcessorConfig proc_config;
    proc_config.source_tag = source_tag;
    proc_config.output_channels = DEFAULT_INPUT_CHANNELS; // Target internal processing format
    proc_config.output_samplerate = DEFAULT_INPUT_SAMPLERATE; // Target internal processing format
    proc_config.initial_volume = validated_config.initial_volume;
    proc_config.initial_eq = validated_config.initial_eq;
    proc_config.initial_delay_ms = validated_config.initial_delay_ms;
    // proc_config.timeshift_buffer_duration_sec = ... // Use default from struct

    // 4. Create and Start SourceInputProcessor
    std::unique_ptr<SourceInputProcessor> new_source;
    try {
        new_source = std::make_unique<SourceInputProcessor>(proc_config, rtp_queue, sink_queue, cmd_queue);
        new_source->start();
        // Basic check if start succeeded
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        if (!new_source->is_running()) {
             throw std::runtime_error("SourceInputProcessor failed to start.");
        }
    } catch (const std::exception& e) {
        LOG_ERROR_AM("Failed to create or start SourceInputProcessor for " + source_tag + ": " + std::string(e.what()));
        // Clean up queues created for this failed source
        rtp_to_source_queues_.erase(source_tag);
        source_to_sink_queues_.erase(source_tag);
        command_queues_.erase(source_tag);
        source_configs_.erase(source_tag); // Remove stored config if processor failed
        return false; // Don't proceed if source failed
    }

    // 5. Register input queue and sync primitives with RtpReceiver
    if (rtp_receiver_) {
        // Get pointers to the mutex and CV from the new source processor
        std::mutex* proc_mutex = new_source->get_timeshift_mutex();
        std::condition_variable* proc_cv = new_source->get_timeshift_cv();
        // Call the updated add_output_queue method
        rtp_receiver_->add_output_queue(source_tag, rtp_queue, proc_mutex, proc_cv);
    } else {
         LOG_ERROR_AM("RtpReceiver is null, cannot add output target for " + source_tag);
         new_source->stop(); // Stop the newly created source processor
         // Clean up queues...
         rtp_to_source_queues_.erase(source_tag);
         source_to_sink_queues_.erase(source_tag);
         command_queues_.erase(source_tag);
         source_configs_.erase(source_tag);
         return false;
    }

    // 6. Connect this new source to all existing sinks
    LOG_AM("Connecting new source " + source_tag + " to existing sinks...");
    for (auto& sink_pair : sinks_) {
        LOG_AM("Connecting source " + source_tag + " to sink " + sink_pair.first);
        sink_pair.second->add_input_queue(source_tag, sink_queue);
    }

    // 7. Store the new source processor
    sources_[source_tag] = std::move(new_source);

    LOG_AM("Source " + source_tag + " configured and started successfully.");
    return true;
}

bool AudioManager::remove_source_config(const std::string& source_tag) {
    LOG_AM("Removing source configuration and processor for: " + source_tag);
    std::unique_ptr<SourceInputProcessor> source_to_remove; // Hold pointer outside lock
    bool config_was_removed = false;
    bool processor_was_found = false;

    { // Scope for lock
        std::lock_guard<std::mutex> lock(manager_mutex_);
        if (!running_) {
             LOG_ERROR_AM("Cannot remove source, manager is not running.");
             return false;
        }

        // 1. Attempt to remove the configuration first
        if (source_configs_.erase(source_tag) > 0) {
            config_was_removed = true;
            LOG_AM("Removed configuration for source: " + source_tag);
        }

        // 2. Attempt to find and remove the processor
        auto it = sources_.find(source_tag);
        if (it != sources_.end()) {
            processor_was_found = true;
            source_to_remove = std::move(it->second); // Move ownership for later stopping
            sources_.erase(it); // Remove from map

            // Clean up associated queues
            rtp_to_source_queues_.erase(source_tag);
            source_to_sink_queues_.erase(source_tag);
            command_queues_.erase(source_tag);
            LOG_AM("Removed queues for source: " + source_tag);

            // Tell RtpReceiver to forget about this source's queue
            if (rtp_receiver_) {
                rtp_receiver_->remove_output_queue(source_tag);
            }

            // Tell all sinks to remove this source's input queue
            LOG_AM("Disconnecting source " + source_tag + " from existing sinks...");
            for (auto& sink_pair : sinks_) {
                if (sink_pair.second) { // Check if sink pointer is valid
                    sink_pair.second->remove_input_queue(source_tag);
                }
            }
        }
    } // Mutex lock released

    // 3. Stop the processor outside the lock (if it was found)
    if (source_to_remove) {
        LOG_AM("Stopping source processor: " + source_tag);
        source_to_remove->stop();
        // source_to_remove is destroyed here when it goes out of scope
        LOG_AM("Source processor " + source_tag + " stopped and removed.");
    }

    // 4. Determine success and log final status
    if (processor_was_found) {
        // If processor was found, removal is considered successful regardless of config
        return true;
    } else if (config_was_removed) {
        // If only config was found and removed
        LOG_AM("Source configuration for " + source_tag + " removed (processor was not active).");
        return true;
    } else {
        // Neither processor nor config was found
        LOG_AM("Source configuration and processor not found for: " + source_tag);
        return false;
    }
}

void AudioManager::process_notifications() {
    LOG_AM("Notification processing thread started.");
    while (running_) { // Check atomic flag
        NewSourceNotification notification;
        // Blocking pop - waits until data available or queue is stopped
        bool success = new_source_notification_queue_->pop(notification);

        if (!success) { // pop returns false if queue was stopped
            if (running_) { // Log error only if we weren't expecting to stop
                 LOG_ERROR_AM("Notification queue pop failed unexpectedly.");
            }
            break; // Exit loop if queue stopped or failed
        }

        // Check running flag again after potentially blocking pop
        if (!running_) break;

        LOG_AM("Received notification for new source: " + notification.source_tag);
        handle_new_source(notification.source_tag);
    }
    LOG_AM("Notification processing thread finished.");
}

void AudioManager::handle_new_source(const std::string& source_tag) {
    // This function is called when the RtpReceiver detects a packet from a source IP.
    // Now, it should primarily check if this source is expected (i.e., configured).
    std::lock_guard<std::mutex> lock(manager_mutex_);

    if (!running_) return;

    // Check if a source processor *already exists* for this tag.
    // If it exists, we don't need to do anything here.
    if (sources_.count(source_tag)) {
        // LOG_AM("RTP packet received for already active source: " + source_tag); // Can be noisy
        return;
    }

    // If no processor exists, it means we received packets from an unconfigured source.
    // Log this event. We are NOT creating a processor here anymore.
    LOG_AM("Warning: Received RTP packet from unconfigured source: " + source_tag);
    // Optionally, could notify Python layer about the unconfigured source.
}


bool AudioManager::send_command_to_source(const std::string& source_tag, const ControlCommand& command) {
    std::shared_ptr<CommandQueue> target_queue;
    { // Scope for lock
        std::lock_guard<std::mutex> lock(manager_mutex_);
        if (!running_) return false; // Don't send commands if not running

        auto it = command_queues_.find(source_tag);
        if (it == command_queues_.end()) {
            LOG_ERROR_AM("Command queue not found for source: " + source_tag);
            return false;
        }
        target_queue = it->second; // Get shared_ptr to queue
    } // Lock released

    if (target_queue) {
        target_queue->push(command); // Push command (copy)
        return true;
    }
    return false; // Should not happen if found in map, but defensive check
}


// --- Control API Implementations ---

bool AudioManager::update_source_volume(const std::string& source_tag, float volume) {
    ControlCommand cmd;
    cmd.type = CommandType::SET_VOLUME;
    cmd.float_value = volume;
    return send_command_to_source(source_tag, cmd);
}

bool AudioManager::update_source_equalizer(const std::string& source_tag, const std::vector<float>& eq_values) {
     if (eq_values.size() != EQ_BANDS) {
         LOG_ERROR_AM("update_source_equalizer: Invalid EQ size (" + std::to_string(eq_values.size()) + ") for source " + source_tag);
         return false;
     }
    ControlCommand cmd;
    cmd.type = CommandType::SET_EQ;
    cmd.eq_values = eq_values; // Copy vector
    return send_command_to_source(source_tag, cmd);
}

bool AudioManager::update_source_delay(const std::string& source_tag, int delay_ms) {
    ControlCommand cmd;
    cmd.type = CommandType::SET_DELAY;
    cmd.int_value = delay_ms;
    return send_command_to_source(source_tag, cmd);
}

bool AudioManager::update_source_timeshift(const std::string& source_tag, float timeshift_sec) {
    ControlCommand cmd;
    cmd.type = CommandType::SET_TIMESHIFT;
    cmd.float_value = timeshift_sec;
    return send_command_to_source(source_tag, cmd);
}

// --- Data Retrieval API Implementation ---

std::vector<uint8_t> AudioManager::get_mp3_data(const std::string& sink_id) {
    std::shared_ptr<Mp3Queue> target_queue;
    { // Scope for lock
        std::lock_guard<std::mutex> lock(manager_mutex_);
         if (!running_) return {}; // Return empty vector if not running

        auto it = mp3_output_queues_.find(sink_id);
        if (it == mp3_output_queues_.end()) {
            // LOG_ERROR_AM("MP3 queue not found for sink: " + sink_id); // Can be noisy
            return {}; // Return empty vector
        }
        target_queue = it->second;
    } // Lock released

    if (target_queue) {
        EncodedMP3Data mp3_data;
        if (target_queue->try_pop(mp3_data)) {
            return mp3_data.mp3_data; // Return the vector (move happens implicitly)
        }
    }
    return {}; // Return empty vector if queue is null or empty
}

// --- External Control ---

bool AudioManager::set_sink_tcp_fd(const std::string& sink_id, int fd) {
     std::lock_guard<std::mutex> lock(manager_mutex_);
     if (!running_) return false;

     auto it = sinks_.find(sink_id);
     if (it == sinks_.end()) {
         LOG_ERROR_AM("Sink not found for setting TCP FD: " + sink_id);
         return false;
     }
     if (it->second) {
         it->second->set_tcp_fd(fd);
         return true;
     }
     return false; // Should not happen if found in map
}
audio_manager.h0000644000000000000000000002042615006005442012520 0ustar  rootroot#ifndef AUDIO_MANAGER_H
#define AUDIO_MANAGER_H

#include "audio_component.h" // Base class
#include "rtp_receiver.h"
#include "source_input_processor.h"
#include "sink_audio_mixer.h"
#include "thread_safe_queue.h"
#include "audio_types.h"

#include <map>
#include <string>
#include <vector>
#include <memory> // For unique_ptr, shared_ptr
#include <mutex>
#include <thread>
#include <atomic>

namespace screamrouter {
namespace audio {

// Forward declarations for queue types used internally
using NotificationQueue = utils::ThreadSafeQueue<NewSourceNotification>;
using PacketQueue = utils::ThreadSafeQueue<TaggedAudioPacket>;
using ChunkQueue = utils::ThreadSafeQueue<ProcessedAudioChunk>;
using CommandQueue = utils::ThreadSafeQueue<ControlCommand>;
using Mp3Queue = utils::ThreadSafeQueue<EncodedMP3Data>;

/**
 * @brief Central orchestrator for the C++ audio engine.
 * Manages the lifecycle of audio components (RTP Receiver, Source Processors, Sink Mixers),
 * sets up communication queues, and provides the primary interface for the Python layer.
 */
class AudioManager {
public:
    AudioManager();
    ~AudioManager();

    // Prevent copying/moving
    AudioManager(const AudioManager&) = delete;
    AudioManager& operator=(const AudioManager&) = delete;
    AudioManager(AudioManager&&) = delete;
    AudioManager& operator=(AudioManager&&) = delete;

    // --- Lifecycle Management ---
    /**
     * @brief Initializes the audio manager, starts the RTP receiver and notification processing.
     * @param rtp_listen_port The UDP port for the RTP receiver to listen on.
     * @return true on success, false on failure (e.g., RTP receiver failed to start).
     */
    bool initialize(int rtp_listen_port = 4010);

    /**
     * @brief Shuts down the audio manager, stopping all components and threads gracefully.
     */
    void shutdown();

    // --- Component Management API (for Python via pybind11) ---
    /**
     * @brief Adds a new audio sink based on the provided configuration.
     * Creates, configures, and starts a SinkAudioMixer instance.
     * Connects all currently active sources to the new sink.
     * @param config Configuration for the sink.
     * @return true if the sink was added successfully, false otherwise.
     */
    bool add_sink(const SinkConfig& config);

    /**
     * @brief Removes an existing audio sink.
     * Stops and destroys the corresponding SinkAudioMixer instance.
     * @param sink_id The unique identifier of the sink to remove.
     * @return true if the sink was removed successfully, false if not found.
     */
    bool remove_sink(const std::string& sink_id);

    /**
     * @brief Pre-configures settings for a potential audio source.
     * These settings (volume, EQ, delay) will be applied when the source
     * is automatically detected and created by the RTP receiver.
     * @param config Configuration settings for the source.
     * @return true (currently always returns true, might add validation later).
     */
    bool configure_source(const SourceConfig& config);

    /**
     * @brief Removes the pre-configured settings for a source.
     * Note: This does not stop an already active source processor for this tag.
     * @param source_tag The unique identifier (IP address or tag) of the source config to remove.
     * @return true if the configuration was found and removed, false otherwise.
     */
    bool remove_source_config(const std::string& source_tag);

    // --- Control API (for Python via pybind11) ---
    /**
     * @brief Updates the volume for an active source processor.
     * @param source_tag Identifier of the source.
     * @param volume New volume level (e.g., 0.0 to 1.0+).
     * @return true if the command was sent successfully, false if the source/command queue wasn't found.
     */
    bool update_source_volume(const std::string& source_tag, float volume);

    /**
     * @brief Updates the equalizer settings for an active source processor.
     * @param source_tag Identifier of the source.
     * @param eq_values Vector of EQ gain values (size must match EQ_BANDS).
     * @return true if the command was sent successfully, false otherwise.
     */
    bool update_source_equalizer(const std::string& source_tag, const std::vector<float>& eq_values);

    /**
     * @brief Updates the delay for an active source processor.
     * @param source_tag Identifier of the source.
     * @param delay_ms New delay in milliseconds.
     * @return true if the command was sent successfully, false otherwise.
     */
    bool update_source_delay(const std::string& source_tag, int delay_ms);

    /**
     * @brief Updates the timeshift (playback offset from now) for an active source processor.
     * @param source_tag Identifier of the source.
     * @param timeshift_sec New timeshift offset in seconds (negative values play earlier).
     * @return true if the command was sent successfully, false otherwise.
     */
    bool update_source_timeshift(const std::string& source_tag, float timeshift_sec);

    // --- Data Retrieval API (for Python via pybind11) ---
    /**
     * @brief Retrieves a chunk of encoded MP3 data from a specific sink's output queue.
     * This is a polling method (non-blocking).
     * @param sink_id Identifier of the sink.
     * @return A vector of bytes containing the MP3 data, or an empty vector if no data is available or sink/queue not found.
     */
    std::vector<uint8_t> get_mp3_data(const std::string& sink_id);

    /**
     * @brief Updates the TCP file descriptor for a specific sink.
     * Called externally when a TCP connection state changes.
     * @param sink_id Identifier of the sink.
     * @param fd The new file descriptor (-1 if disconnected).
     * @return true if the sink was found, false otherwise.
     */
    bool set_sink_tcp_fd(const std::string& sink_id, int fd);


private:
    // --- Internal State ---
    std::atomic<bool> running_{false};
    std::mutex manager_mutex_; // Protects access to internal maps/vectors

    // RTP Receiver (only one)
    std::unique_ptr<RtpReceiver> rtp_receiver_;
    std::shared_ptr<NotificationQueue> new_source_notification_queue_;
    std::thread notification_thread_; // Thread to process new source notifications

    // Sink Mixers (ID -> Mixer Ptr)
    std::map<std::string, std::unique_ptr<SinkAudioMixer>> sinks_;
    // Sink Configurations (ID -> Config) - Keep track for potential reconfiguration
    std::map<std::string, SinkConfig> sink_configs_;
    // Queues for MP3 output (Sink ID -> Queue Ptr)
    std::map<std::string, std::shared_ptr<Mp3Queue>> mp3_output_queues_;

    // Source Processors (Source Tag -> Processor Ptr)
    std::map<std::string, std::unique_ptr<SourceInputProcessor>> sources_;
    // Queues for RTP -> Source Processor (Source Tag -> Queue Ptr)
    std::map<std::string, std::shared_ptr<PacketQueue>> rtp_to_source_queues_;
    // Queues for Source Processor -> Sink Mixer (Source Tag -> Queue Ptr) - One per source, shared by sinks
    std::map<std::string, std::shared_ptr<ChunkQueue>> source_to_sink_queues_;
    // Queues for Control Commands (Source Tag -> Queue Ptr)
    std::map<std::string, std::shared_ptr<CommandQueue>> command_queues_;

    // Pre-configured source settings (Source Tag -> Config)
    std::map<std::string, SourceConfig> source_configs_;

    // --- Internal Methods ---
    /**
     * @brief The main loop for the notification processing thread.
     * Waits for notifications from the RtpReceiver and calls handle_new_source.
     */
    void process_notifications();

    /**
     * @brief Handles a new source notification.
     * Creates the necessary queues and SourceInputProcessor instance for the new source,
     * registers the input queue with the RtpReceiver, and connects the source's
     * output queue to all existing SinkAudioMixers.
     * @param source_tag The identifier of the newly detected source.
     */
    void handle_new_source(const std::string& source_tag);

    /**
     * @brief Helper function to send a control command to a specific source processor.
     * @param source_tag Identifier of the target source.
     * @param command The command to send.
     * @return true if the command queue was found and the command pushed, false otherwise.
     */
    bool send_command_to_source(const std::string& source_tag, const ControlCommand& command);
};

} // namespace audio
} // namespace screamrouter

#endif // AUDIO_MANAGER_H
audio_types.h0000644000000000000000000001133315006176406012260 0ustar  rootroot#ifndef AUDIO_TYPES_H
#define AUDIO_TYPES_H

#include <vector>
#include <string>
#include <chrono>
#include <cstdint> // For fixed-width integers like uint8_t, uint32_t

namespace screamrouter {
namespace audio {

// --- Data Structures for Inter-Thread Communication ---

/**
 * @brief Represents a raw audio packet received from the network, tagged with its source.
 *        Passed from RtpReceiver to the corresponding SourceInputProcessor.
 */
struct TaggedAudioPacket {
    std::string source_tag;                     // Identifier for the source (e.g., IP address)
    std::vector<uint8_t> audio_data;            // Raw audio payload (PCM data chunk)
    std::chrono::steady_clock::time_point received_time; // Timestamp for timeshifting/jitter
};

/**
 * @brief Represents a chunk of audio data after processing by a SourceInputProcessor.
 *        Passed from SourceInputProcessor to SinkAudioMixer(s).
 */
struct ProcessedAudioChunk {
    // Changed to int32_t to match the signed nature of processed PCM data
    std::vector<int32_t> audio_data; // Processed audio data (e.g., 288 samples of int32_t for 1152 bytes)
    // std::string source_tag; // Optional: Could be added if mixer needs to know origin beyond the queue
};

/**
 * @brief Enum defining types of control commands for SourceInputProcessor.
 */
enum class CommandType {
    SET_VOLUME,
    SET_EQ,
    SET_DELAY,
    SET_TIMESHIFT // Controls the 'backshift' amount
};

/**
 * @brief Represents a command sent from AudioManager to a SourceInputProcessor.
 */
struct ControlCommand {
    CommandType type;
    // Using separate members for simplicity over std::variant for now
    float float_value = 0.0f;         // For volume, timeshift
    int int_value = 0;                // For delay_ms
    std::vector<float> eq_values;     // For EQ bands (size should match AudioProcessor expectation, e.g., 18)
};

/**
 * @brief Notification sent from RtpReceiver to AudioManager when a new source is detected.
 */
struct NewSourceNotification {
    std::string source_tag; // Identifier (IP address) of the new source
};

/**
 * @brief Represents a chunk of MP3 encoded audio data.
 *        Passed from SinkAudioMixer to AudioManager/Python layer.
 */
struct EncodedMP3Data {
    std::vector<uint8_t> mp3_data; // Chunk of MP3 bytes
    // std::string sink_id; // Optional: Could be added if consumer needs to know origin sink
};


// --- Configuration Structs (Simplified versions for C++ internal use) ---
// These might mirror or be derived from Python-side descriptions

struct SourceConfig {
    std::string tag;
    float initial_volume = 1.0f;
    std::vector<float> initial_eq; // Size EQ_BANDS expected by AudioProcessor
    int initial_delay_ms = 0;
    // Timeshift duration is often global or sink-related, managed in SourceInputProcessor config
};

struct SinkConfig {
    std::string id; // Unique ID for this sink instance
    std::string output_ip;
    int output_port;
    int bitdepth = 16;
    int samplerate = 48000;
    int channels = 2;
    uint8_t chlayout1 = 0x03; // Default Stereo L/R
    uint8_t chlayout2 = 0x00;
    bool use_tcp = false;
    bool enable_mp3 = false; // Flag to enable MP3 output queue
    // int mp3_bitrate = 192; // Example MP3 setting if needed here
};

// Configuration for RtpReceiver component
struct RtpReceiverConfig {
    int listen_port = 40000; // Default port
    // std::string bind_ip = "0.0.0.0"; // Optional: Interface IP to bind to
};

// Configuration for SourceInputProcessor component
struct SourceProcessorConfig {
    std::string source_tag; // Unique identifier (IP or user tag)
    // Target format (from Sink) - Needed for AudioProcessor initialization
    int output_channels = 2;
    int output_samplerate = 48000;
    // Initial settings (from SourceConfig)
    float initial_volume = 1;
    std::vector<float> initial_eq = {0}; // Assuming 18 bands like current code
    int initial_delay_ms = 0;
    int timeshift_buffer_duration_sec = 5; // Default timeshift buffer duration
    // Input format hints (if needed, otherwise assume standard like 16-bit, 48kHz, 2ch)
    // int input_channels = 2;
    // int input_samplerate = 48000;
    // int input_bitdepth = 16;
};

// Configuration for SinkAudioMixer component
struct SinkMixerConfig {
    std::string sink_id; // Unique identifier (e.g., IP:Port or name)
    std::string output_ip;
    int output_port;
    int output_bitdepth;
    int output_samplerate;
    int output_channels;
    uint8_t output_chlayout1;
    uint8_t output_chlayout2;
    bool use_tcp;
    // MP3 Encoding settings (if applicable)
    // bool enable_mp3_output; // Determined by whether mp3_output_queue is provided
    // int mp3_bitrate = 192; // Example setting for LAME
};


} // namespace audio
} // namespace screamrouter

#endif // AUDIO_TYPES_H
bindings.cpp0000644000000000000000000001505115005773520012063 0ustar  rootroot#include <pybind11/pybind11.h>
#include <pybind11/stl.h> // For automatic conversions of vector, map, string, etc.
#include <pybind11/chrono.h> // If any chrono types were exposed (not currently needed)

#include "audio_manager.h"
// audio_types.h is included by audio_manager.h, but include explicitly for clarity if needed
// #include "../c_utils/audio_types.h"

namespace py = pybind11;
// Import the C++ namespace to shorten type names
using namespace screamrouter::audio;

// Define the Python module using the PYBIND11_MODULE macro
// The first argument is the name of the Python module as it will be imported (e.g., `import screamrouter_audio_engine`)
// The second argument `m` is the py::module_ object representing the module
PYBIND11_MODULE(screamrouter_audio_engine, m) {
    m.doc() = "ScreamRouter C++ Audio Engine Extension"; // Optional module docstring

    // --- Bind Configuration Structs ---
    // These structs are used to pass configuration data from Python to C++

    py::class_<SourceConfig>(m, "SourceConfig", "Configuration for an audio source")
        .def(py::init<>()) // Bind the default constructor
        // Bind member variables as read-write properties in Python
        .def_readwrite("tag", &SourceConfig::tag, "Unique identifier (e.g., IP address or user tag)")
        .def_readwrite("initial_volume", &SourceConfig::initial_volume, "Initial volume level (default: 1.0)")
        .def_readwrite("initial_eq", &SourceConfig::initial_eq, "Initial equalizer settings (list of floats, size EQ_BANDS)")
        .def_readwrite("initial_delay_ms", &SourceConfig::initial_delay_ms, "Initial delay in milliseconds (default: 0)");
        // Add __repr__ for better debugging in Python if desired
        // .def("__repr__", [](const SourceConfig &a) {
        //     return "<SourceConfig tag='" + a.tag + "'>";
        // });


    py::class_<SinkConfig>(m, "SinkConfig", "Configuration for an audio sink")
        .def(py::init<>()) // Bind the default constructor
        // Bind member variables as read-write properties
        .def_readwrite("id", &SinkConfig::id, "Unique identifier for this sink instance")
        .def_readwrite("output_ip", &SinkConfig::output_ip, "Destination IP address for UDP output")
        .def_readwrite("output_port", &SinkConfig::output_port, "Destination port for UDP output")
        .def_readwrite("bitdepth", &SinkConfig::bitdepth, "Output bit depth (e.g., 16)")
        .def_readwrite("samplerate", &SinkConfig::samplerate, "Output sample rate (e.g., 48000)")
        .def_readwrite("channels", &SinkConfig::channels, "Output channel count (e.g., 2)")
        .def_readwrite("chlayout1", &SinkConfig::chlayout1, "Scream header channel layout byte 1")
        .def_readwrite("chlayout2", &SinkConfig::chlayout2, "Scream header channel layout byte 2")
        .def_readwrite("use_tcp", &SinkConfig::use_tcp, "Whether this sink uses TCP output (managed externally)");
        // Removed .def_readwrite("enable_mp3", ...) as MP3 queue is now always created internally
        // Add __repr__
        // .def("__repr__", [](const SinkConfig &a) {
        //     return "<SinkConfig id='" + a.id + "'>";
        // });

    // --- Bind AudioManager Class ---
    // Expose the main C++ audio engine class to Python

    py::class_<AudioManager>(m, "AudioManager", "Main class for managing the C++ audio engine")
        .def(py::init<>(), "Constructor") // Bind the constructor

        // Lifecycle Methods
        .def("initialize", &AudioManager::initialize,
             py::arg("rtp_listen_port") = 4010, // Provide default value for optional arg
             "Initializes the audio manager, starts RTP listener and notification thread. Returns true on success.")
        .def("shutdown", &AudioManager::shutdown,
             "Stops all audio components and cleans up resources.")

        // Component Management Methods
        .def("add_sink", &AudioManager::add_sink,
             py::arg("config"), // Name the argument for clarity in Python calls
             "Adds and starts a new audio sink based on the SinkConfig. Returns true on success.")
        .def("remove_sink", &AudioManager::remove_sink,
             py::arg("sink_id"),
             "Stops and removes the audio sink with the given ID. Returns true on success.")
        .def("configure_source", &AudioManager::configure_source,
             py::arg("config"),
             "Pre-configures settings for a potential audio source using SourceConfig.")
        .def("remove_source_config", &AudioManager::remove_source_config,
             py::arg("source_tag"),
             "Removes pre-configured settings for a source.")

        // Control Methods
        .def("update_source_volume", &AudioManager::update_source_volume,
             py::arg("source_tag"), py::arg("volume"),
             "Updates the volume for an active source.")
        .def("update_source_equalizer", &AudioManager::update_source_equalizer,
             py::arg("source_tag"), py::arg("eq_values"),
             "Updates the equalizer settings for an active source (expects list/vector of floats).")
        .def("update_source_delay", &AudioManager::update_source_delay,
             py::arg("source_tag"), py::arg("delay_ms"),
             "Updates the delay (in ms) for an active source.")
        .def("update_source_timeshift", &AudioManager::update_source_timeshift,
             py::arg("source_tag"), py::arg("timeshift_sec"),
             "Updates the timeshift playback offset (in seconds) for an active source.")

        // Data Retrieval Methods
        .def("get_mp3_data", &AudioManager::get_mp3_data,
             py::arg("sink_id"),
             // Important: Use move policy to avoid copying potentially large byte vectors
             py::return_value_policy::move,
             "Retrieves a chunk of MP3 data (as bytes) from the specified sink's queue if available, otherwise returns empty bytes.")

        // External Control Methods (like setting TCP FD)
        .def("set_sink_tcp_fd", &AudioManager::set_sink_tcp_fd,
             py::arg("sink_id"), py::arg("fd"),
             "Updates the externally managed TCP file descriptor for a sink.");

    // Define constants if needed (e.g., EQ_BANDS)
    m.attr("EQ_BANDS") = py::int_(EQ_BANDS);

    // Note on GIL: The AudioManager methods are designed to be quick (mostly queue pushes/map lookups).
    // The actual audio processing happens in separate C++ threads not holding the GIL.
    // Therefore, explicit GIL release/acquire is likely not needed within these bound methods initially.
    // If `get_mp3_data` were changed to block, it would need `py::call_guard<py::gil_scoped_release>()`.
}
rtp_receiver.cpp0000644000000000000000000002732115006165124012756 0ustar  rootroot#include "rtp_receiver.h"
#include <iostream> // For logging/debugging
#include <vector>
#include <cstring> // For memcpy, memset
#include <chrono>
#include <stdexcept> // For runtime_error
#include <system_error> // For socket error checking
#include <utility> // For std::move

// Use namespaces for clarity
namespace screamrouter { namespace audio { using namespace utils; } }
using namespace screamrouter::audio;
using namespace screamrouter::utils;


// Define constants based on original code and RTP standard
// CHUNK_SIZE was 1152 in original code, likely the expected PCM data size per packet
const size_t EXPECTED_CHUNK_SIZE = 1152;
const size_t RTP_HEADER_SIZE = 12;
const size_t EXPECTED_PAYLOAD_SIZE = RTP_HEADER_SIZE + EXPECTED_CHUNK_SIZE;
const uint8_t SCREAM_PAYLOAD_TYPE = 127;

// Define a reasonable buffer size for recvfrom
const size_t RECEIVE_BUFFER_SIZE = 2048; // Should be larger than EXPECTED_PAYLOAD_SIZE

// Poll timeout in milliseconds
const int POLL_TIMEOUT_MS = 100; // Check for stop flag every 100ms

long number = 0;

// Simple logger helper (replace with a proper logger if available)
#define LOG(msg) std::cout << "[RtpReceiver] " << msg << std::endl
#define LOG_ERROR(msg) std::cerr << "[RtpReceiver Error] " << msg << " (errno: " << errno << ")" << std::endl

RtpReceiver::RtpReceiver(
    RtpReceiverConfig config,
    std::shared_ptr<NotificationQueue> notification_queue)
    : config_(config),
      notification_queue_(notification_queue),
      socket_fd_(-1)
{
    if (!notification_queue_) {
        throw std::runtime_error("RtpReceiver requires a valid notification queue.");
    }
    LOG("Initialized with port " + std::to_string(config_.listen_port));
}

RtpReceiver::~RtpReceiver() {
    // Ensure stop is called, even if not explicitly done by AudioManager
    // This helps prevent dangling threads if shutdown order is wrong.
    if (!stop_flag_) {
        stop();
    }
    // Join should happen in stop(), but double-check just in case stop wasn't called correctly
    if (component_thread_.joinable()) {
        LOG("Warning: Joining thread in destructor, stop() might not have been called properly.");
        component_thread_.join();
    }
    close_socket(); // Ensure socket is closed
}

bool RtpReceiver::setup_socket() {
    socket_fd_ = socket(AF_INET, SOCK_DGRAM, 0);
    if (socket_fd_ < 0) {
        LOG_ERROR("Failed to create socket");
        return false;
    }

    // Set socket options (e.g., reuse address)
    int reuse = 1;
    if (setsockopt(socket_fd_, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0) {
        LOG_ERROR("Failed to set SO_REUSEADDR");
        close_socket();
        return false;
    }

    // Prepare address structure
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // Bind to any interface
    server_addr.sin_port = htons(config_.listen_port);

    // Bind the socket
    if (bind(socket_fd_, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        LOG_ERROR("Failed to bind socket to port " + std::to_string(config_.listen_port));
        close_socket();
        return false;
    }

    LOG("Socket created and bound successfully to port " + std::to_string(config_.listen_port));
    return true;
}

void RtpReceiver::close_socket() {
    if (socket_fd_ != -1) {
        LOG("Closing socket fd " + std::to_string(socket_fd_));
        close(socket_fd_);
        socket_fd_ = -1;
    }
}

void RtpReceiver::start() {
    if (is_running()) {
        LOG("Already running.");
        return;
    }
    LOG("Starting...");
    stop_flag_ = false; // Reset stop flag

    if (!setup_socket()) {
        LOG_ERROR("Failed to setup socket. Cannot start receiver thread.");
        // Optionally throw an exception or handle the error appropriately
        return;
    }

    // Launch the thread
    try {
        component_thread_ = std::thread(&RtpReceiver::run, this);
        LOG("Receiver thread started.");
    } catch (const std::system_error& e) {
        LOG_ERROR("Failed to start thread: " + std::string(e.what()));
        close_socket(); // Clean up socket if thread failed to start
        // Rethrow or handle error
        throw;
    }
}

void RtpReceiver::stop() {
    if (stop_flag_) {
        LOG("Already stopped or stopping.");
        return;
    }
    LOG("Stopping...");
    stop_flag_ = true; // Signal the run loop to exit

    // Closing the socket can help interrupt blocking recvfrom/poll calls
    close_socket();

    // Wait for the thread to finish
    if (component_thread_.joinable()) {
        try {
            component_thread_.join();
            LOG("Receiver thread joined.");
        } catch (const std::system_error& e) {
            LOG_ERROR("Error joining thread: " + std::string(e.what()));
        }
    } else {
        LOG("Thread was not joinable (might not have started or already stopped).");
    }
}

void RtpReceiver::add_output_queue(
    const std::string& source_tag,
    std::shared_ptr<PacketQueue> queue,
    std::mutex* processor_mutex,
    std::condition_variable* processor_cv)
{
    std::lock_guard<std::mutex> lock(targets_mutex_); // Use the renamed mutex
    if (queue && processor_mutex && processor_cv) {
        output_targets_[source_tag] = SourceOutputTarget{queue, processor_mutex, processor_cv};
        LOG("Added output target for source: " + source_tag);
    } else {
        LOG_ERROR("Attempted to add output target with null queue or sync primitives for source: " + source_tag);
    }
}

void RtpReceiver::remove_output_queue(const std::string& source_tag) {
    std::lock_guard<std::mutex> lock(targets_mutex_); // Use the renamed mutex
    if (output_targets_.erase(source_tag)) { // Use the renamed map
        LOG("Removed output target for source: " + source_tag);
    } else {
        LOG("Attempted to remove non-existent target for source: " + source_tag);
    }
}

bool RtpReceiver::is_valid_rtp_payload(const uint8_t* buffer, ssize_t size) {
    // Basic size check
    if (size < RTP_HEADER_SIZE) {
        return false;
    }
    // Check payload type (byte 1, lower 7 bits)
    uint8_t payloadType = buffer[1] & 0x7F;
    return payloadType == SCREAM_PAYLOAD_TYPE;
}

void RtpReceiver::run() {
    LOG("Receiver thread entering run loop.");
    std::vector<uint8_t> receive_buffer(RECEIVE_BUFFER_SIZE);
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);

    struct pollfd fds[1];
    fds[0].fd = socket_fd_;
    fds[0].events = POLLIN; // Check for data to read

    while (!stop_flag_) {
        // Use poll for non-blocking check with timeout
        int poll_ret = poll(fds, 1, POLL_TIMEOUT_MS);

        if (poll_ret < 0) {
            // Error in poll (ignore EINTR, handle others)
            if (errno != EINTR && !stop_flag_) { // Don't log error if we are stopping anyway
                 LOG_ERROR("poll() failed");
            }
            if (!stop_flag_) { // Avoid busy-looping on error if not stopping
                 std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
            continue; // Check stop_flag_ again
        }

        if (poll_ret == 0) {
            // Timeout - no data received, loop again to check stop_flag_
            continue;
        }

        // Check if data is available on the socket
        if (fds[0].revents & POLLIN) {
            ssize_t bytes_received = recvfrom(socket_fd_, receive_buffer.data(), receive_buffer.size(), 0,
                                              (struct sockaddr *)&client_addr, &client_addr_len);

            if (bytes_received < 0) {
                // Error receiving data (ignore if caused by stop())
                if (!stop_flag_) { // Don't log error if we are stopping anyway
                    LOG_ERROR("recvfrom() failed");
                }
                continue; // Check stop_flag_ again
            }

            // Process received packet
            if (bytes_received == EXPECTED_PAYLOAD_SIZE && is_valid_rtp_payload(receive_buffer.data(), bytes_received)) {
                std::string source_tag = inet_ntoa(client_addr.sin_addr);
                auto received_time = std::chrono::steady_clock::now();

                // Check if source is new
                { // Scope for known_tags_mutex_ lock
                    std::lock_guard<std::mutex> lock(known_tags_mutex_);
                    if (known_source_tags_.find(source_tag) == known_source_tags_.end()) {
                        known_source_tags_.insert(source_tag);
                        // Unlock before pushing to queue to avoid holding lock while potentially blocking
                        lock.~lock_guard(); // Explicitly unlock before pushing
                        LOG("New source detected: " + source_tag);
                        notification_queue_->push(NewSourceNotification{source_tag});
                    }
                } // Mutex released here

                // Find the output target for this source
                SourceOutputTarget target; // Copy target info
                bool target_found = false;
                { // Scope for targets_mutex_ lock
                    std::lock_guard<std::mutex> lock(targets_mutex_);
                    auto it = output_targets_.find(source_tag);
                    if (it != output_targets_.end()) {
                        target = it->second; // Copy struct content (queue ptr, mutex ptr, cv ptr)
                        target_found = true;
                    }
                } // Mutex released here

                // Push to the queue and notify if found
                if (target_found && target.queue) { // Check if queue pointer is valid
                    TaggedAudioPacket packet;
                    // packet.audio_data = std::vector<uint8_t>(1152,0); // Pre-sizing removed, use assign
                    packet.source_tag = source_tag;
                    packet.received_time = received_time;
                    // Copy only the audio data part (after RTP header)
                    packet.audio_data.assign(receive_buffer.data() + RTP_HEADER_SIZE,
                                             receive_buffer.data() + bytes_received);
                    // The loop for number++ seems like debug code, removing for clarity
                    // for (int i=0;i<1152;i++)
                    // {
                    //     //packet.audio_data[i] = number++;
                    // }

                    // Push packet to the queue
                    target.queue->push(std::move(packet));

                    // Notify the processor's condition variable
                    if (target.processor_mutex && target.processor_cv) {
                        // Lock the processor's mutex before notifying
                        std::lock_guard<std::mutex> cv_lock(*target.processor_mutex);
                        target.processor_cv->notify_one();
                        // Mutex automatically unlocked here
                    } else {
                         LOG_ERROR("Missing mutex or CV pointer for source: " + source_tag + " - Cannot notify processor.");
                    }
                } else {
                    // LOG("No output target registered for source: " + source_tag); // Can be noisy
                }
            } else {
                 LOG("Received invalid or unexpected size packet (" + std::to_string(bytes_received) + " bytes) from " + std::string(inet_ntoa(client_addr.sin_addr)));
            }
        } else if (fds[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {
             // Socket error occurred
             LOG_ERROR("Socket error detected by poll()");
             // Consider breaking the loop or attempting recovery depending on the error
             break; // Exit loop on socket error
        }
    } // End while loop

    LOG("Receiver thread exiting run loop.");
}
rtp_receiver.h0000644000000000000000000001010615006164277012424 0ustar  rootroot#ifndef RTP_RECEIVER_H
#define RTP_RECEIVER_H

#include "audio_component.h"
#include "thread_safe_queue.h"
#include "audio_types.h"

#include <string>
#include <vector>
#include <map>
#include <memory> // For shared_ptr
#include <mutex>
#include <condition_variable> // Added
#include <set> // For known source tags

// Forward declaration
namespace screamrouter { namespace utils { template <typename T> class ThreadSafeQueue; } }

// Socket related includes
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h> // For sockaddr_in
#include <arpa/inet.h>  // For inet_ntoa
#include <unistd.h>     // For close
#include <poll.h>       // For poll

namespace screamrouter {
namespace audio {

// Using alias for clarity
using NotificationQueue = utils::ThreadSafeQueue<NewSourceNotification>;
using PacketQueue = utils::ThreadSafeQueue<TaggedAudioPacket>;

// Forward declare SourceInputProcessor to avoid circular include if needed later
// class SourceInputProcessor; // Not strictly needed if just passing pointers

// Struct to hold queue and synchronization primitives for a source processor
struct SourceOutputTarget {
    std::shared_ptr<PacketQueue> queue;
    std::mutex* processor_mutex = nullptr; // Pointer to SourceInputProcessor's timeshift_mutex_
    std::condition_variable* processor_cv = nullptr; // Pointer to SourceInputProcessor's timeshift_condition_
};

class RtpReceiver : public AudioComponent {
public:
    RtpReceiver(
        RtpReceiverConfig config,
        std::shared_ptr<NotificationQueue> notification_queue
    );

    ~RtpReceiver() override;

    // --- AudioComponent Interface ---
    void start() override;
    void stop() override;

    // --- RtpReceiver Specific ---
    /**
     * @brief Registers an output queue for packets originating from a specific source tag.
     *        Called by AudioManager when a new SourceInputProcessor is created.
     * @brief Registers an output target (queue and sync primitives) for a specific source tag.
     *        Called by AudioManager when a new SourceInputProcessor is created.
     * @param source_tag The identifier (IP address) of the source.
     * @param queue The thread-safe queue to push packets for this source.
     * @param processor_mutex Pointer to the SourceInputProcessor's timeshift mutex.
     * @param processor_cv Pointer to the SourceInputProcessor's timeshift condition variable.
     */
    void add_output_queue(
        const std::string& source_tag,
        std::shared_ptr<PacketQueue> queue,
        std::mutex* processor_mutex,
        std::condition_variable* processor_cv
    );

    /**
     * @brief Removes the output queue associated with a source tag.
     *        Called by AudioManager when a SourceInputProcessor is removed.
     * @param source_tag The identifier (IP address) of the source.
     */
    void remove_output_queue(const std::string& source_tag);

protected:
    // --- AudioComponent Interface ---
    void run() override; // The main thread loop

private:
    RtpReceiverConfig config_;
    int socket_fd_ = -1;
    std::shared_ptr<NotificationQueue> notification_queue_;

    // Map from source_tag (IP address) to the output target for that source's processor
    std::map<std::string, SourceOutputTarget> output_targets_;
    std::mutex targets_mutex_; // Protects access to output_targets_ map

    // Keep track of known source tags to avoid spamming notifications
    // Keep track of known source tags to avoid spamming notifications
    std::set<std::string> known_source_tags_;
    std::mutex known_tags_mutex_; // Protects access to known_source_tags_

    // Internal helper methods
    bool setup_socket();
    void close_socket();
    /**
     * @brief Parses the RTP header to check for validity (payload type).
     * @param buffer Pointer to the start of the received UDP payload.
     * @param size Size of the received payload.
     * @return true if the header indicates a valid Scream packet (payload type 127), false otherwise.
     */
    bool is_valid_rtp_payload(const uint8_t* buffer, ssize_t size);
};

} // namespace audio
} // namespace screamrouter

#endif // RTP_RECEIVER_H
sink_audio_mixer.cpp0000644000000000000000000011100115006205106013576 0ustar  rootroot#include "sink_audio_mixer.h"
#include <iostream> // For logging
#include <stdexcept>
#include <cstring> // For memcpy, memset
#include <vector>
#include <chrono>
#include <system_error> // For thread/socket errors
#include <algorithm> // For std::fill, std::max
#include <cmath>     // For std::chrono durations

// Use namespaces for clarity
namespace screamrouter { namespace audio { using namespace utils; } }
using namespace screamrouter::audio;
using namespace screamrouter::utils;

// Include SIMD headers if available
#ifdef __SSE2__
#include <emmintrin.h>
#endif
#ifdef __AVX2__
#include <immintrin.h>
#endif

// Simple logger helper (replace with a proper logger if available)
//#define LOG(sink_id, msg) std::cout << "[SinkMixer:" << sink_id << "] " << msg << std::endl
//#define LOG_ERROR(sink_id, msg) std::cerr << "[SinkMixer Error:" << sink_id << "] " << msg << " (errno: " << errno << ")" << std::endl
//#define LOG_WARN(sink_id, msg) std::cout << "[SinkMixer Warn:" << sink_id << "] " << msg << std::endl // Added WARN level
//#define LOG_DEBUG(sink_id, msg) std::cout << "[SinkMixer Debug:" << sink_id << "] " << msg << std::endl
#define LOG(sink_id, msg)
#define LOG_ERROR(sink_id, msg)
#define LOG_WARN(sink_id, msg)
#define LOG_DEBUG(sink_id, msg)

// Define how long to wait for input data before mixing silence/last known data
const std::chrono::milliseconds INPUT_WAIT_TIMEOUT(20); // e.g., 20ms
const int DEFAULT_MP3_BITRATE = 192; // Default bitrate if MP3 enabled


SinkAudioMixer::SinkAudioMixer(
    SinkMixerConfig config,
    std::shared_ptr<Mp3OutputQueue> mp3_output_queue)
    : config_(config),
      mp3_output_queue_(mp3_output_queue), // Store the shared_ptr (can be null)
      udp_socket_fd_(-1),
      tcp_socket_fd_(-1),
      lame_global_flags_(nullptr),
      // Fix mixing buffer size to be constant based on SINK_MIXING_BUFFER_SAMPLES
      mixing_buffer_(SINK_MIXING_BUFFER_SAMPLES, 0),
      // Fix output buffer size for double buffering (Packet Size * 2)
      output_network_buffer_(SINK_PACKET_SIZE_BYTES * 2, 0),
      mp3_encode_buffer_(SINK_MP3_BUFFER_SIZE) // Allocate MP3 buffer
 {
    LOG(config_.sink_id, "Initializing...");

    // Validate config
    if (config_.output_bitdepth != 8 && config_.output_bitdepth != 16 && config_.output_bitdepth != 24 && config_.output_bitdepth != 32) {
         LOG_ERROR(config_.sink_id, "Unsupported output bit depth: " + std::to_string(config_.output_bitdepth) + ". Defaulting to 16.");
         config_.output_bitdepth = 16;
    }
    if (config_.output_channels <= 0 || config_.output_channels > 8) { // Assuming max 8 channels based on old code
         LOG_ERROR(config_.sink_id, "Invalid output channels: " + std::to_string(config_.output_channels) + ". Defaulting to 2.");
         config_.output_channels = 2;
    }

    build_scream_header();

    if (mp3_output_queue_) {
        initialize_lame();
    }

    LOG(config_.sink_id, "Initialization complete.");
}

SinkAudioMixer::~SinkAudioMixer() {
    if (!stop_flag_) {
        stop();
    }
    if (component_thread_.joinable()) {
        LOG(config_.sink_id, "Warning: Joining thread in destructor, stop() might not have been called properly.");
        component_thread_.join();
    }
    close_networking();
    close_lame();
}

void SinkAudioMixer::build_scream_header() {
    bool output_samplerate_44100_base = (config_.output_samplerate % 44100) == 0;
    // Ensure divisor is not zero
    uint8_t output_samplerate_mult = (config_.output_samplerate > 0) ?
        ((output_samplerate_44100_base ? 44100 : 48000) / config_.output_samplerate) : 1;

    scream_header_[0] = output_samplerate_mult + (output_samplerate_44100_base << 7);
    scream_header_[1] = static_cast<uint8_t>(config_.output_bitdepth);
    scream_header_[2] = static_cast<uint8_t>(config_.output_channels);
    scream_header_[3] = config_.output_chlayout1;
    scream_header_[4] = config_.output_chlayout2;
    LOG(config_.sink_id, "Built Scream header for Rate: " + std::to_string(config_.output_samplerate) +
                         ", Depth: " + std::to_string(config_.output_bitdepth) +
                         ", Channels: " + std::to_string(config_.output_channels));
}

void SinkAudioMixer::initialize_lame() {
    if (!mp3_output_queue_) return; // Don't initialize if not enabled

    LOG(config_.sink_id, "Initializing LAME MP3 encoder...");
    lame_global_flags_ = lame_init();
    if (!lame_global_flags_) {
        LOG_ERROR(config_.sink_id, "lame_init() failed.");
        return;
    }

    lame_set_in_samplerate(lame_global_flags_, config_.output_samplerate);
    lame_set_num_channels(lame_global_flags_, config_.output_channels);
    lame_set_out_samplerate(lame_global_flags_, config_.output_samplerate); // Keep same sample rate for MP3
    lame_set_mode(lame_global_flags_, (config_.output_channels == 1) ? MONO : STEREO); // Adjust based on channels
    lame_set_quality(lame_global_flags_, 2); // 0=best, 9=worst. 2 is high quality.
    lame_set_VBR(lame_global_flags_, vbr_off); // Use CBR for streaming
    lame_set_brate(lame_global_flags_, DEFAULT_MP3_BITRATE); // Set bitrate (e.g., 192 kbps)

    int ret = lame_init_params(lame_global_flags_);
    if (ret < 0) {
        LOG_ERROR(config_.sink_id, "lame_init_params() failed with code: " + std::to_string(ret));
        lame_close(lame_global_flags_);
        lame_global_flags_ = nullptr;
        return;
    }
    lame_active_ = true; // Assume active initially
    LOG(config_.sink_id, "LAME initialized successfully.");
}

void SinkAudioMixer::close_lame() {
    if (lame_global_flags_) {
        LOG(config_.sink_id, "Closing LAME encoder.");
        lame_close(lame_global_flags_);
        lame_global_flags_ = nullptr;
    }
}

bool SinkAudioMixer::setup_networking() {
    LOG(config_.sink_id, "Setting up networking...");
    // UDP Setup
    udp_socket_fd_ = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (udp_socket_fd_ < 0) {
        LOG_ERROR(config_.sink_id, "Failed to create UDP socket");
        return false;
    }

    // Set DSCP/TOS value (Best Effort is default, EF for Expedited Forwarding is 46)
    int dscp = 46; // EF PHB for low latency audio
    int tos_value = dscp << 2;
    if (setsockopt(udp_socket_fd_, IPPROTO_IP, IP_TOS, &tos_value, sizeof(tos_value)) < 0) {
        LOG_ERROR(config_.sink_id, "Failed to set UDP socket TOS/DSCP");
        // Non-fatal, continue anyway
    }

    // Prepare UDP destination address
    memset(&udp_dest_addr_, 0, sizeof(udp_dest_addr_));
    udp_dest_addr_.sin_family = AF_INET;
    udp_dest_addr_.sin_port = htons(config_.output_port);
    if (inet_pton(AF_INET, config_.output_ip.c_str(), &udp_dest_addr_.sin_addr) <= 0) {
        LOG_ERROR(config_.sink_id, "Invalid UDP destination IP address: " + config_.output_ip);
        close(udp_socket_fd_);
        udp_socket_fd_ = -1;
        return false;
    }

    // TCP setup is handled externally via set_tcp_fd()

    LOG(config_.sink_id, "Networking setup complete (UDP target: " + config_.output_ip + ":" + std::to_string(config_.output_port) + ")");
    return true;
}

void SinkAudioMixer::close_networking() {
    if (udp_socket_fd_ != -1) {
        LOG(config_.sink_id, "Closing UDP socket fd " + std::to_string(udp_socket_fd_));
        close(udp_socket_fd_);
        udp_socket_fd_ = -1;
    }
    // Don't close tcp_socket_fd_ here, as it's managed externally
}

void SinkAudioMixer::start() {
    if (is_running()) {
        LOG(config_.sink_id, "Already running.");
        return;
    }
    LOG(config_.sink_id, "Starting...");
    stop_flag_ = false;
    output_buffer_write_pos_ = 0; // Reset write position

    if (!setup_networking()) {
        LOG_ERROR(config_.sink_id, "Networking setup failed. Cannot start mixer thread.");
        return;
    }

    // Launch the thread
    try {
        component_thread_ = std::thread(&SinkAudioMixer::run, this);
        LOG(config_.sink_id, "Thread started.");
    } catch (const std::system_error& e) {
        LOG_ERROR(config_.sink_id, "Failed to start thread: " + std::string(e.what()));
        close_networking();
        close_lame();
        throw;
    }
}

void SinkAudioMixer::stop() {
     if (stop_flag_) {
        LOG(config_.sink_id, "Already stopped or stopping.");
        return;
    }
    LOG(config_.sink_id, "Stopping...");
    stop_flag_ = true;

    // Notify condition variables to wake up waiting threads
    input_cv_.notify_all();

    if (component_thread_.joinable()) {
         try {
            component_thread_.join();
            LOG(config_.sink_id, "Thread joined.");
        } catch (const std::system_error& e) {
            LOG_ERROR(config_.sink_id, "Error joining thread: " + std::string(e.what()));
        }
    } else {
         LOG(config_.sink_id, "Thread was not joinable.");
    }

    // Cleanup resources after thread has stopped
    close_networking();
    close_lame();
}

void SinkAudioMixer::add_input_queue(const std::string& source_id, std::shared_ptr<InputChunkQueue> queue) {
    if (!queue) {
        LOG_ERROR(config_.sink_id, "Attempted to add null input queue for source: " + source_id);
        return;
    }
    {
        std::lock_guard<std::mutex> lock(queues_mutex_);
        input_queues_[source_id] = queue;
        input_active_state_[source_id] = false; // Start as inactive
        // Initialize buffer for this source (e.g., with silence)
        source_buffers_[source_id].audio_data.assign(SINK_MIXING_BUFFER_SAMPLES * config_.output_channels, 0);
        LOG(config_.sink_id, "Added input queue for source: " + source_id);
    }
    input_cv_.notify_one(); // Notify run loop in case it was waiting with no sources
}

void SinkAudioMixer::remove_input_queue(const std::string& source_id) {
     {
        std::lock_guard<std::mutex> lock(queues_mutex_);
        input_queues_.erase(source_id);
        input_active_state_.erase(source_id);
        source_buffers_.erase(source_id);
        LOG(config_.sink_id, "Removed input queue for source: " + source_id);
    }
}

void SinkAudioMixer::set_tcp_fd(int fd) {
    // This function might be called from a different thread (e.g., network management thread)
    // No lock needed if tcp_socket_fd_ is atomic, but it's just an int here.
    // Assuming this is called infrequently and potential race condition is acceptable,
    // or that external synchronization is handled by the caller.
    // For robustness, a mutex could be added if concurrent calls are expected.
    if (fd != tcp_socket_fd_) {
        LOG(config_.sink_id, "Setting TCP FD to " + std::to_string(fd));
        tcp_socket_fd_ = fd;
    }
}

bool SinkAudioMixer::wait_for_source_data(std::chrono::milliseconds timeout) {
    bool data_received = false;
    ProcessedAudioChunk chunk;

    // Lock the mutex protecting the input queues and state
    std::unique_lock<std::mutex> lock(queues_mutex_);

     // Check all queues non-blockingly first, attempting to drain available data
     // Continue checking all queues even if data_received becomes true
     for (auto const& [source_id, queue_ptr] : input_queues_) {
         LOG_DEBUG(config_.sink_id, "WaitForData: Trying non-blocking pop for source " << source_id);
         if (queue_ptr->try_pop(chunk)) { // Attempt to get data
             size_t received_samples = chunk.audio_data.size(); // Get actual sample count
             LOG_DEBUG(config_.sink_id, "WaitForData: Non-blocking pop SUCCESS for source " << source_id << ". Received=" << received_samples << " samples. Expected=" << SINK_MIXING_BUFFER_SAMPLES << " samples.");
             if (received_samples != SINK_MIXING_BUFFER_SAMPLES) { // Validate size
                 LOG_ERROR(config_.sink_id, "WaitForData: Received chunk from " + source_id + " with unexpected sample count: " + std::to_string(received_samples) + ". Expected: " + std::to_string(SINK_MIXING_BUFFER_SAMPLES) + ". Discarding.");
                 // Don't mark as active or store the buffer if size is wrong
             } else { // Size is correct
                 source_buffers_[source_id] = std::move(chunk); // Store the valid chunk
                 input_active_state_[source_id] = true; // Mark source as active for mixing
                 data_received = true; // Flag that we got at least one valid chunk
             }
         } else { // No data available right now
             LOG_DEBUG(config_.sink_id, "WaitForData: Non-blocking pop FAILED for source " << source_id);
             // No data currently available for this source *right now*
            input_active_state_[source_id] = false; // Mark as inactive for this mixing cycle
        }
    }

     // If no data was received from any queue, wait on the condition variable
     if (!data_received && !input_queues_.empty()) {        
         LOG_DEBUG(config_.sink_id, "WaitForData: No data from non-blocking pops, starting wait (" << timeout.count() << "ms)...");
         // Unlock queues_mutex before waiting, but keep input_cv_mutex locked
         lock.unlock();
         std::unique_lock<std::mutex> cv_lock(input_cv_mutex_);

         //LOG_DEBUG(config_.sink_id, "Waiting for input data...");
         auto wait_status = input_cv_.wait_for(cv_lock, timeout); // Store wait status
         cv_lock.unlock(); // Release CV mutex
         LOG_DEBUG(config_.sink_id, "WaitForData: Wait finished. Status: " << (wait_status == std::cv_status::timeout ? "Timeout" : "Notified/Spurious"));


         // Re-lock queues_mutex to check again after waiting
         lock.lock();
         LOG_DEBUG(config_.sink_id, "WaitForData: Checking queues again after wait...");
         for (auto const& [source_id, queue_ptr] : input_queues_) {
              if (input_active_state_[source_id]) continue; // Skip if already marked active from the first non-blocking check

              LOG_DEBUG(config_.sink_id, "WaitForData: Trying post-wait pop for source " << source_id);
              if (queue_ptr->try_pop(chunk)) { // Attempt to get data after waiting
                  size_t received_samples = chunk.audio_data.size(); // Get actual sample count
                  LOG_DEBUG(config_.sink_id, "WaitForData: Post-wait pop SUCCESS for source " << source_id << ". Received=" << received_samples << " samples. Expected=" << SINK_MIXING_BUFFER_SAMPLES << " samples.");
                   if (received_samples != SINK_MIXING_BUFFER_SAMPLES) { // Validate size
                       LOG_ERROR(config_.sink_id, "WaitForData: Received chunk post-wait from " + source_id + " with unexpected sample count: " + std::to_string(received_samples) + ". Expected: " + std::to_string(SINK_MIXING_BUFFER_SAMPLES) + ". Discarding.");
                       // Don't mark as active or store the buffer if size is wrong
                   } else { // Size is correct
                       source_buffers_[source_id] = std::move(chunk); // Store the valid chunk
                       input_active_state_[source_id] = true; // Mark source as active for mixing
                       data_received = true; // Flag that we got at least one valid chunk
                   }
              } else { // No data available even after waiting
                   LOG_DEBUG(config_.sink_id, "WaitForData: Post-wait pop FAILED for source " << source_id);
              }
             // No need to mark inactive again here, done in the first loop or handled above
        }
    }
    // Keep queues_mutex locked until return

    // Determine if any source is active *after* waiting/checking
    bool any_source_active = false;
    for (auto const& [source_id, is_active] : input_active_state_) {
        if (is_active) {
            any_source_active = true;
            break;
        }
    }

    return any_source_active; // Return true if at least one source provided data or was already active
}


void SinkAudioMixer::mix_buffers() {
    // Assumes queues_mutex_ is held by the caller (run loop)
    // Clear the mixing buffer (vector of int32_t) before accumulating samples
    std::fill(mixing_buffer_.begin(), mixing_buffer_.end(), 0);
    size_t active_source_count = 0;

    // The total number of samples to mix is fixed by the mixing_buffer_ size
    size_t total_samples_to_mix = mixing_buffer_.size(); // Should be SINK_MIXING_BUFFER_SAMPLES (e.g., 576)
    LOG_DEBUG(config_.sink_id, "MixBuffers: Starting mix. Target samples=" + std::to_string(total_samples_to_mix) + " (Mixing buffer size).");


    for (auto const& [source_id, is_active] : input_active_state_) { // Iterate through all potential sources
        if (is_active) { // Only process sources marked active in wait_for_source_data
            active_source_count++;
            // Check if the source buffer actually exists in the map (should always exist if active)
            auto buf_it = source_buffers_.find(source_id);
            if (buf_it == source_buffers_.end()) {
                 LOG_ERROR(config_.sink_id, "Mixing error: Source buffer not found for active source " + source_id);
                 continue; // Skip this source
            }
            const auto& source_data = buf_it->second.audio_data; // Use iterator

            size_t samples_in_source = source_data.size(); // Get actual sample count from the stored chunk
            LOG_DEBUG(config_.sink_id, "MixBuffers: Mixing source " + source_id + ". Source samples=" + std::to_string(samples_in_source) + ". Expected=" + std::to_string(total_samples_to_mix) + ".");

            // *** Check source data size against the fixed mixing buffer size ***
            // This check is redundant if wait_for_source_data correctly discards invalid chunks, but kept for safety.
            if (samples_in_source != total_samples_to_mix) {
                 LOG_ERROR(config_.sink_id, "MixBuffers: Source buffer for " + source_id + " size mismatch! Expected " + std::to_string(total_samples_to_mix) + ", got " + std::to_string(samples_in_source) + ". Skipping source.");
                 continue; // Skip this source
            }

            // Now we expect samples_in_source == total_samples_to_mix
            LOG_DEBUG(config_.sink_id, "MixBuffers: Accumulating " + std::to_string(total_samples_to_mix) + " samples from " + source_id);

            // *** Iterate over the entire mixing buffer size ***
            for (size_t i = 0; i < total_samples_to_mix; ++i) {
                // Accessing mixing_buffer_[i]. Size is total_samples_to_mix. Safe.
                // Accessing source_data[i]. Size >= total_samples_to_mix. Safe.
                int64_t sum = static_cast<int64_t>(mixing_buffer_[i]) + source_data[i];
                // Clamp the sum to 32-bit integer range
                if (sum > INT32_MAX) {
                    mixing_buffer_[i] = INT32_MAX;
                } else if (sum < INT32_MIN) { // Check against INT32_MIN for underflow
                    mixing_buffer_[i] = INT32_MIN;
                } else {
                    mixing_buffer_[i] = static_cast<int32_t>(sum);
                }
            }
        } // end if(is_active)
    } // end for loop over sources
    LOG_DEBUG(config_.sink_id, "MixBuffers: Mix complete. Mixed " + std::to_string(active_source_count) + " active sources into mixing_buffer_ (" + std::to_string(total_samples_to_mix) + " samples).");
}


// Restored original bit-shifting logic (copies MSBs)
void SinkAudioMixer::downscale_buffer() {
    // Converts 32-bit mixing_buffer_ to target bit depth into output_network_buffer_
    size_t output_byte_depth = config_.output_bitdepth / 8; // Bytes per sample in target format (e.g., 16-bit -> 2 bytes)
    // Calculate the number of samples based on the mixing buffer size (int32_t)
    size_t samples_to_convert = mixing_buffer_.size(); // Should be SINK_MIXING_BUFFER_SAMPLES (e.g., 576)

    // Calculate the total number of bytes this conversion *should* produce
    size_t expected_bytes_to_write = samples_to_convert * output_byte_depth; // e.g., 576 samples * 2 bytes/sample = 1152 bytes for 16-bit stereo
    LOG_DEBUG(config_.sink_id, "Downscale: Converting " + std::to_string(samples_to_convert) + " samples (int32) to " + std::to_string(config_.output_bitdepth) + "-bit. Expected output bytes=" + std::to_string(expected_bytes_to_write) + ".");


    // Ensure we don't write past the end of the output buffer's allocated space
    // Note: output_network_buffer_ is double buffered (size = SINK_PACKET_SIZE_BYTES * 2 = (1152+5)*2 = 2314 bytes)
    // We write data *after* the header space reserved at the beginning.
    size_t available_space = output_network_buffer_.size() - SINK_HEADER_SIZE - output_buffer_write_pos_;

    if (expected_bytes_to_write > available_space) {
        LOG_ERROR(config_.sink_id, "Downscale buffer overflow detected! Available space=" + std::to_string(available_space) + ", needed=" + std::to_string(expected_bytes_to_write) + ". WritePos=" + std::to_string(output_buffer_write_pos_) + ". BufferSize=" + std::to_string(output_network_buffer_.size()));
        // Limit the operation to prevent overflow, but data will be lost/corrupted.
        // Calculate how many full samples can fit in the available space.
        size_t max_samples_possible = available_space / output_byte_depth;
        samples_to_convert = max_samples_possible; // Limit samples
        expected_bytes_to_write = samples_to_convert * output_byte_depth; // Adjust expected bytes accordingly
        LOG_ERROR(config_.sink_id, "Downscale: Limiting conversion to " + std::to_string(samples_to_convert) + " samples (" + std::to_string(expected_bytes_to_write) + " bytes) due to space limit.");
        if (samples_to_convert == 0) {
             LOG_ERROR(config_.sink_id, "Downscale buffer has no space left. available=" + std::to_string(available_space));
             return; // Nothing can be written
        }
    }

    // Get pointers for reading (from mixing_buffer_) and writing (to output_network_buffer_)
    uint8_t* write_ptr_start = output_network_buffer_.data() + SINK_HEADER_SIZE + output_buffer_write_pos_; // Start writing after header space + current position
    uint8_t* write_ptr = write_ptr_start;
    const int32_t* read_ptr = mixing_buffer_.data(); // Read from the start of the 32-bit mixed buffer

    // Perform the conversion using bit-shifting
    for (size_t i = 0; i < samples_to_convert; ++i) {
        int32_t sample = read_ptr[i]; // Read the full 32-bit sample
        switch (config_.output_bitdepth) { // Convert based on the sink's configured output bit depth
            case 16: // Target: 16-bit
                // Writes MSB first (e.g., AA), then next MSB (e.g., BB) assuming network byte order matters?
                // Let's stick to the original order: BB then AA for 0xAABBCCDD
                // Write 2 bytes for 16-bit output
                *write_ptr++ = static_cast<uint8_t>((sample >> 16) & 0xFF); // BB (Byte 1)
                *write_ptr++ = static_cast<uint8_t>((sample >> 24) & 0xFF); // AA (Byte 0)
                break;
            case 24: // Target: 24-bit
                 // Original order: CC, BB, AA for 0xAABBCCDD
                 // Write 3 bytes for 24-bit output
                *write_ptr++ = static_cast<uint8_t>((sample >> 8) & 0xFF);  // CC (Byte 2)
                *write_ptr++ = static_cast<uint8_t>((sample >> 16) & 0xFF); // BB (Byte 1)
                *write_ptr++ = static_cast<uint8_t>((sample >> 24) & 0xFF); // AA (Byte 0)
                break;
            case 32: // Target: 32-bit
                 // Original order: DD, CC, BB, AA for 0xAABBCCDD
                 // Write 4 bytes for 32-bit output
                *write_ptr++ = static_cast<uint8_t>((sample) & 0xFF);       // DD (Byte 3)
                *write_ptr++ = static_cast<uint8_t>((sample >> 8) & 0xFF);  // CC (Byte 2)
                *write_ptr++ = static_cast<uint8_t>((sample >> 16) & 0xFF); // BB (Byte 1)
                *write_ptr++ = static_cast<uint8_t>((sample >> 24) & 0xFF); // AA (Byte 0)
                break;
             // Note: Bit depth 8 is not handled here, but was validated in constructor
        }
    }
    // Calculate bytes actually written based on pointer difference
    size_t bytes_written = write_ptr - write_ptr_start;
    LOG_DEBUG(config_.sink_id, "Downscale: Conversion loop finished. Bytes written=" + std::to_string(bytes_written) + ". Expected=" + std::to_string(expected_bytes_to_write) + ".");
    if (bytes_written != expected_bytes_to_write) {
         LOG_ERROR(config_.sink_id, "Downscale: Mismatch between bytes written (" + std::to_string(bytes_written) + ") and expected bytes (" + std::to_string(expected_bytes_to_write) + ").");
    }

    // Update the write position in the output_network_buffer_
    output_buffer_write_pos_ += bytes_written;
    LOG_DEBUG(config_.sink_id, "Downscale complete. output_buffer_write_pos_=" + std::to_string(output_buffer_write_pos_));
}


void SinkAudioMixer::send_network_buffer(size_t length) {
    // This function sends a complete network packet of the specified length.
    // The length should typically be SINK_PACKET_SIZE_BYTES (header + payload).
    LOG_DEBUG(config_.sink_id, "SendNet: Preparing to send buffer. Requested length=" + std::to_string(length) + " bytes. Expected packet size=" + std::to_string(SINK_PACKET_SIZE_BYTES) + " bytes.");
    if (length == 0) {
        LOG_ERROR(config_.sink_id, "SendNet: Attempted to send network buffer with length 0.");
        return;
    }
    // Ensure length includes header and doesn't exceed buffer capacity
    if (length < SINK_HEADER_SIZE) {
         LOG_ERROR(config_.sink_id, "SendNet: Attempted to send network buffer with length " + std::to_string(length) + " < header size " + std::to_string(SINK_HEADER_SIZE));
         return; // Invalid length
    }
     // Check against expected packet size (SINK_PACKET_SIZE_BYTES = 1157)
     if (length != SINK_PACKET_SIZE_BYTES) {
         LOG_WARN(config_.sink_id, "SendNet: Sending packet with length " + std::to_string(length) + " which differs from expected SINK_PACKET_SIZE_BYTES (" + std::to_string(SINK_PACKET_SIZE_BYTES) + ").");
     }
    // Ensure length doesn't exceed the *total* allocated buffer size (double buffer)
    if (length > output_network_buffer_.size()) {
         LOG_ERROR(config_.sink_id, "SendNet: Attempted to send network buffer with length " + std::to_string(length) + " > total buffer size " + std::to_string(output_network_buffer_.size()));
         length = output_network_buffer_.size(); // Prevent overflow, but indicates an issue elsewhere
         LOG_ERROR(config_.sink_id, "SendNet: Clamping send length to buffer size: " + std::to_string(length));
    }

    // Add the pre-built Scream header to the start of the buffer *before* sending
    memcpy(output_network_buffer_.data(), scream_header_, SINK_HEADER_SIZE); // Copy header to the very beginning
    LOG_DEBUG(config_.sink_id, "SendNet: Header (" + std::to_string(SINK_HEADER_SIZE) + " bytes) copied to buffer start.");

    // Send via UDP
    if (udp_socket_fd_ != -1) {
        LOG_DEBUG(config_.sink_id, "SendNet: Sending " + std::to_string(length) + " bytes via UDP to " + config_.output_ip + ":" + std::to_string(config_.output_port));
        // Send from the beginning of the buffer, including the header
        ssize_t sent_bytes = sendto(udp_socket_fd_,
                                    output_network_buffer_.data(),
                                    length, // Send the full packet length (header + payload)
                                    0, // Flags
                                    (struct sockaddr *)&udp_dest_addr_,
                                    sizeof(udp_dest_addr_));
        if (sent_bytes < 0) {
            // EAGAIN or EWOULDBLOCK might be acceptable if non-blocking, but UDP usually doesn't block here.
            LOG_ERROR(config_.sink_id, "SendNet: UDP sendto failed");
        } else if (static_cast<size_t>(sent_bytes) != length) {
             LOG_ERROR(config_.sink_id, "SendNet: UDP sendto sent partial data: " + std::to_string(sent_bytes) + "/" + std::to_string(length));
        } else {
             LOG_DEBUG(config_.sink_id, "SendNet: UDP send successful (" + std::to_string(sent_bytes) + " bytes).");
        }
    } else {
         LOG_DEBUG(config_.sink_id, "SendNet: UDP socket not valid, skipping UDP send.");
    }

    // Send via TCP (if connected)
    if (tcp_socket_fd_ != -1) {
        LOG_DEBUG(config_.sink_id, "SendNet: Sending " + std::to_string(length) + " bytes via TCP (fd=" + std::to_string(tcp_socket_fd_) + ").");
        // Send from the beginning of the buffer, including the header
        ssize_t sent_bytes = send(tcp_socket_fd_,
                                  output_network_buffer_.data(),
                                  length, // Send the full packet length (header + payload)
                                  MSG_NOSIGNAL); // Prevent SIGPIPE if connection closed
        if (sent_bytes < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                 LOG_WARN(config_.sink_id, "SendNet: TCP send would block (EAGAIN/EWOULDBLOCK). Data dropped for TCP.");
            } else {
                LOG_ERROR(config_.sink_id, "SendNet: TCP send failed");
                // Consider closing or signaling error for this TCP connection
                // set_tcp_fd(-1); // Example: Mark TCP as disconnected
            }
            // If EAGAIN/EWOULDBLOCK, buffer is full, data is dropped for TCP in this model
        } else if (static_cast<size_t>(sent_bytes) != length) {
             LOG_ERROR(config_.sink_id, "SendNet: TCP send sent partial data: " + std::to_string(sent_bytes) + "/" + std::to_string(length));
             // Handle partial send if necessary (e.g., retry)
        } else {
             LOG_DEBUG(config_.sink_id, "SendNet: TCP send successful (" + std::to_string(sent_bytes) + " bytes).");
        }
    } else {
         LOG_DEBUG(config_.sink_id, "SendNet: TCP socket not valid (fd=" + std::to_string(tcp_socket_fd_) + "), skipping TCP send.");
    }
}


void SinkAudioMixer::encode_and_push_mp3() {
    return;
    if (!mp3_output_queue_ || !lame_global_flags_) {
        return; // MP3 output not enabled or LAME not initialized
    }

    // Check if the MP3 queue is being consumed (simple check based on size)
    // A more robust check might involve feedback from the consumer.
    // This approximates the old select() check on the write FD.
    if (mp3_output_queue_->size() > 10) { // If queue is backing up, assume inactive consumer
        if (lame_active_) {
            LOG(config_.sink_id, "MP3 output queue full, pausing encoding.");
            lame_active_ = false;
        }
        return; // Don't encode if consumer likely inactive
    } else {
         if (!lame_active_) {
             LOG(config_.sink_id, "MP3 output queue draining, resuming encoding.");
             lame_active_ = true;
         }
    }


    // LAME expects interleaved samples. mixing_buffer_ is already interleaved.
    // LAME input function depends on sample format. We have int32_t.
    // We need to convert int32_t to float or short for LAME. Let's use short.
    // This requires downscaling/clipping similar to network output but to 16-bit signed.

    std::vector<short> lame_input_buffer(mixing_buffer_.size());
    for(size_t i = 0; i < mixing_buffer_.size(); ++i) {
        // Shift, clamp, and cast to short
        int32_t sample32 = mixing_buffer_[i];
        int32_t sample16 = sample32 >> 16; // Simple shift, might lose precision
        if (sample16 > INT16_MAX) sample16 = INT16_MAX;
        if (sample16 < INT16_MIN) sample16 = INT16_MIN;
        lame_input_buffer[i] = static_cast<short>(sample16);
    }

    // Calculate number of input samples per channel
    int samples_per_channel = mixing_buffer_.size() / config_.output_channels;

    int mp3_bytes_encoded = lame_encode_buffer_interleaved(
        lame_global_flags_,
        lame_input_buffer.data(),
        samples_per_channel,
        mp3_encode_buffer_.data(),
        mp3_encode_buffer_.size() // Max size of output buffer
    );

    if (mp3_bytes_encoded < 0) {
        LOG_ERROR(config_.sink_id, "LAME encoding failed with code: " + std::to_string(mp3_bytes_encoded));
    } else if (mp3_bytes_encoded > 0) {
        EncodedMP3Data mp3_data;
        mp3_data.mp3_data.assign(mp3_encode_buffer_.begin(), mp3_encode_buffer_.begin() + mp3_bytes_encoded);
        mp3_output_queue_->push(std::move(mp3_data));
    }
}


void SinkAudioMixer::run() {
    LOG(config_.sink_id, "Entering run loop.");

    LOG_DEBUG(config_.sink_id, "RunLoop: Starting iteration.");
    while (!stop_flag_) {
        // 1. Wait for and retrieve data from source queues
        LOG_DEBUG(config_.sink_id, "RunLoop: Waiting for source data...");
        bool data_available = wait_for_source_data(INPUT_WAIT_TIMEOUT);
        LOG_DEBUG(config_.sink_id, "RunLoop: Wait finished. Data available: " << data_available);

        if (stop_flag_) {
             LOG_DEBUG(config_.sink_id, "RunLoop: Stop flag checked after wait, breaking.");
             break; // Check flag again after potentially waiting
        }

        // Lock queues mutex for mixing and state access
        std::unique_lock<std::mutex> lock(queues_mutex_);

        if (data_available || !input_queues_.empty()) { // Mix even if no new data, using last known buffer state
            LOG_DEBUG(config_.sink_id, "RunLoop: Data available or queues not empty, proceeding to mix.");
            // 2. Mix data from active source buffers
            LOG_DEBUG(config_.sink_id, "RunLoop: Mixing buffers...");
            mix_buffers();
            LOG_DEBUG(config_.sink_id, "RunLoop: Mixing complete.");

            // Unlock queues mutex before potentially long operations
            lock.unlock();
            LOG_DEBUG(config_.sink_id, "RunLoop: Queues mutex unlocked.");

            // 3. Encode to MP3 (if enabled)
            encode_and_push_mp3();

            // 4. Downscale mixed buffer to network format
            LOG_DEBUG(config_.sink_id, "RunLoop: Downscaling buffer...");
            downscale_buffer(); // Appends to output_network_buffer_
            LOG_DEBUG(config_.sink_id, "RunLoop: Downscaling complete. WritePos=" << output_buffer_write_pos_);

            // 5. Send network data if a full packet's worth of *payload* bytes has been accumulated
            // We check against SINK_CHUNK_SIZE_BYTES (1152) because that's the payload size we accumulate via downscale_buffer
            if (output_buffer_write_pos_ >= SINK_CHUNK_SIZE_BYTES) {
                LOG_DEBUG(config_.sink_id, "RunLoop: Output buffer ready to send. WritePos=" << output_buffer_write_pos_ << " bytes. ChunkSizeBytes=" << SINK_CHUNK_SIZE_BYTES << " bytes.");
                // Send the first packet (from start of double buffer), total size includes header
                send_network_buffer(SINK_PACKET_SIZE_BYTES); // Send 1157 bytes (header + 1152 payload)
                LOG_DEBUG(config_.sink_id, "RunLoop: Network buffer sent (size=" << SINK_PACKET_SIZE_BYTES << ").");

                // Shift the remaining data (if any) from the second half of the buffer to the beginning (after header space)
                size_t bytes_remaining_after_send = output_buffer_write_pos_ - SINK_CHUNK_SIZE_BYTES;
                LOG_DEBUG(config_.sink_id, "RunLoop: Rotating output buffer... Shifting " << bytes_remaining_after_send << " bytes from second half to start.");
                if (bytes_remaining_after_send > 0) {
                    // Use memmove for potentially overlapping regions.
                    // Source: Start of the data *after* the first sent chunk (at index SINK_PACKET_SIZE_BYTES)
                    // Destination: Start of the payload area (at index SINK_HEADER_SIZE)
                    // Length: The number of bytes remaining after sending the first chunk
                    memmove(output_network_buffer_.data() + SINK_HEADER_SIZE,      // Dest
                           output_network_buffer_.data() + SINK_PACKET_SIZE_BYTES, // Src
                           bytes_remaining_after_send);                            // Len
                }
                LOG_DEBUG(config_.sink_id, "RunLoop: Output buffer rotated.");

                // Adjust write position to reflect the remaining data
                output_buffer_write_pos_ = bytes_remaining_after_send; // New write pos is the number of bytes shifted
                LOG_DEBUG(config_.sink_id, "RunLoop: Adjusted write pos to " << output_buffer_write_pos_);
            } else {
                 LOG_DEBUG(config_.sink_id, "RunLoop: Output buffer not full enough yet for payload. WritePos=" << output_buffer_write_pos_ << " bytes. Need=" << SINK_CHUNK_SIZE_BYTES << " bytes.");
            }
        } else {
            // No input queues connected or no data available from wait_for_source_data
            LOG_DEBUG(config_.sink_id, "RunLoop: No data available and input queues empty. Sleeping briefly.");
            lock.unlock();
            // Add a small sleep to prevent busy-waiting if there are truly no inputs or no data
            std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Sleep 10ms
        }
        LOG_DEBUG(config_.sink_id, "RunLoop: End of iteration.");
    } // End while loop

    LOG(config_.sink_id, "Exiting run loop.");
}
sink_audio_mixer.h0000644000000000000000000001246015006201061013250 0ustar  rootroot#ifndef SINK_AUDIO_MIXER_H
#define SINK_AUDIO_MIXER_H

#include "audio_component.h"
#include "thread_safe_queue.h"
#include "audio_types.h"

#include <string>
#include <vector>
#include <map>
#include <memory> // For shared_ptr, unique_ptr
#include <mutex>
#include <condition_variable>
#include <lame/lame.h> // For LAME MP3 encoding

// Socket related includes
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h> // For sockaddr_in
#include <arpa/inet.h>  // For inet_pton, inet_ntoa
#include <unistd.h>     // For close
#include <poll.h>       // For poll

namespace screamrouter {
namespace audio {

// Using aliases for clarity
using InputChunkQueue = utils::ThreadSafeQueue<ProcessedAudioChunk>;
using Mp3OutputQueue = utils::ThreadSafeQueue<EncodedMP3Data>;

// Define constants based on the network protocol requirement of 1152 bytes output payload
const size_t SINK_CHUNK_SIZE_BYTES = 1152; // Network output payload size (protocol spec)
const size_t SINK_HEADER_SIZE = 5;
const size_t SINK_PACKET_SIZE_BYTES = SINK_CHUNK_SIZE_BYTES + SINK_HEADER_SIZE; // 1152 + 5 = 1157 bytes
// Mixing buffer holds enough 32-bit samples to generate 1152 bytes after downscaling.
// For 16-bit stereo output (current test case): 1152 bytes / (16/8 bytes/sample) = 576 samples.
// For 32-bit stereo output: 1152 bytes / (32/8 bytes/sample) = 288 samples.
// Setting based on the 16-bit stereo requirement for now.
const size_t SINK_MIXING_BUFFER_SAMPLES = 576; // Samples needed for 1152 bytes @ 16-bit stereo
const size_t SINK_MP3_BUFFER_SIZE = SINK_CHUNK_SIZE_BYTES * 8; // Generous buffer for MP3 output

class SinkAudioMixer : public AudioComponent {
public:
    // Input queues map: Key is a unique source identifier (e.g., source_tag from SourceProcessorConfig)
    using InputQueueMap = std::map<std::string, std::shared_ptr<InputChunkQueue>>;

    SinkAudioMixer(
        SinkMixerConfig config,
        std::shared_ptr<Mp3OutputQueue> mp3_output_queue // Can be nullptr if MP3 not needed
    );

    ~SinkAudioMixer() override;

    // --- AudioComponent Interface ---
    void start() override;
    void stop() override;

    // --- SinkAudioMixer Specific ---
    /**
     * @brief Adds an input queue from a SourceInputProcessor.
     * @param source_id Unique identifier for the source.
     * @param queue Shared pointer to the source's output queue.
     */
    void add_input_queue(const std::string& source_id, std::shared_ptr<InputChunkQueue> queue);

    /**
     * @brief Removes an input queue.
     * @param source_id Unique identifier for the source to remove.
     */
    void remove_input_queue(const std::string& source_id);

    /**
     * @brief Updates the TCP file descriptor if the connection changes.
     *        Assumes external management of the TCP connection itself.
     * @param fd The new TCP socket file descriptor, or -1 if disconnected.
     */
    void set_tcp_fd(int fd);

protected:
    // --- AudioComponent Interface ---
    void run() override; // The main thread loop

private:
    SinkMixerConfig config_;
    std::shared_ptr<Mp3OutputQueue> mp3_output_queue_; // Null if MP3 output disabled

    // Input queues from SourceInputProcessors
    InputQueueMap input_queues_;
    std::mutex queues_mutex_; // Protects access to input_queues_ map and related state maps
    // Track active state per source queue (true if recently received data)
    std::map<std::string, bool> input_active_state_;
    // Buffers to hold the latest chunk from each source for mixing
    std::map<std::string, ProcessedAudioChunk> source_buffers_;
    // Condition variable to wait for input data
    std::condition_variable input_cv_;
    std::mutex input_cv_mutex_; // Mutex specifically for the input condition variable

    // Network state
    int udp_socket_fd_ = -1;
    int tcp_socket_fd_ = -1; // Managed externally via set_tcp_fd()
    struct sockaddr_in udp_dest_addr_; // Store the actual struct, not pointer

    // Mixing buffer (32-bit)
    std::vector<int32_t> mixing_buffer_;
    // Network output buffer (double buffer)
    std::vector<uint8_t> output_network_buffer_; // Size = SINK_PACKET_SIZE_BYTES * 2
    size_t output_buffer_write_pos_ = 0; // Position where next downscaled byte goes
    uint8_t scream_header_[SINK_HEADER_SIZE]; // Store precomputed Scream header

    // LAME MP3 Encoder state
    lame_t lame_global_flags_ = nullptr;
    std::vector<uint8_t> mp3_encode_buffer_; // Temporary buffer for encoded MP3 data
    bool lame_active_ = false; // Track if MP3 stream is being consumed

    // Internal Methods
    bool setup_networking(); // Create UDP socket, prepare UDP dest addr
    void close_networking(); // Close sockets
    void build_scream_header();
    void initialize_lame();
    void close_lame();

    // Main loop helpers
    bool wait_for_source_data(std::chrono::milliseconds timeout); // Waits for data on input queues, updates source_buffers_ and input_active_state_
    void mix_buffers(); // Mixes data from active sources in source_buffers_ into mixing_buffer_
    void downscale_buffer(); // Converts mixing_buffer_ to target bit depth into output_network_buffer_
    void send_network_buffer(size_t length); // Sends data via UDP or TCP
    void encode_and_push_mp3(); // Encodes mixing_buffer_ using LAME and pushes to mp3_output_queue_
};

} // namespace audio
} // namespace screamrouter

#endif // SINK_AUDIO_MIXER_H
source_input_processor.cpp0000644000000000000000000006301015006205667015105 0ustar  rootroot#include "source_input_processor.h"
#include <iostream> // For logging
#include <stdexcept>
#include <cstring> // For memcpy
#include <algorithm> // For std::min, std::max
#include <cmath>     // For std::chrono durations
#include <thread>    // For sleep_for

// Use namespaces for clarity
namespace screamrouter { namespace audio { using namespace utils; } }
using namespace screamrouter::audio;
using namespace screamrouter::utils;

// Simple logger helper (replace with a proper logger if available)
//#define LOG(source_tag, msg) std::cout << "[SourceProc:" << source_tag << "] " << msg << std::endl
//#define LOG_ERROR(source_tag, msg) std::cerr << "[SourceProc Error:" << source_tag << "] " << msg << std::endl
//#define LOG_DEBUG(source_tag, msg) std::cout << "[SourceProc Debug:" << source_tag << "] " << msg << std::endl // For verbose logging

#define LOG(source_tag, msg)
#define LOG_ERROR(source_tag, msg)
#define LOG_DEBUG(source_tag, msg)

// Define how often to cleanup the timeshift buffer (e.g., every second)
const std::chrono::milliseconds TIMESIFT_CLEANUP_INTERVAL(1000);


SourceInputProcessor::SourceInputProcessor(
    SourceProcessorConfig config,
    std::shared_ptr<InputPacketQueue> input_queue,
    std::shared_ptr<OutputChunkQueue> output_queue,
    std::shared_ptr<CommandQueue> command_queue)
    : config_(config),
      input_queue_(input_queue),
      output_queue_(output_queue),
      command_queue_(command_queue),
      current_volume_(config.initial_volume),
      current_eq_(config.initial_eq),
      current_delay_ms_(config.initial_delay_ms),
      current_timeshift_backshift_sec_(0.0f) // Start with no timeshift backshift
{
    if (!input_queue_ || !output_queue_ || !command_queue_) {
        throw std::runtime_error("SourceInputProcessor requires valid input, output, and command queues.");
    }
    // Ensure EQ vector has the correct size if provided, otherwise initialize default
    if (current_eq_.size() != EQ_BANDS) {
        LOG(config_.source_tag, "Warning: Initial EQ size mismatch (" + std::to_string(current_eq_.size()) + " vs " + std::to_string(EQ_BANDS) + "). Resetting to default (flat).");
        current_eq_.assign(EQ_BANDS, 1.0f);
        config_.initial_eq = current_eq_; // Update config to match
    }

    LOG(config_.source_tag, "Initializing...");
    initialize_audio_processor();
    // update_timeshift_target_time(); // REMOVED
    LOG(config_.source_tag, "Initialization complete.");
}

SourceInputProcessor::~SourceInputProcessor() {
    if (!stop_flag_) {
        LOG(config_.source_tag, "Destructor called while still running. Stopping...");
        stop(); // Ensure stop logic is triggered if not already stopped
    }
     // Join threads here
     if (input_thread_.joinable()) {
        LOG(config_.source_tag, "Joining input thread in destructor...");
        input_thread_.join();
        LOG(config_.source_tag, "Input thread joined.");
    }
     if (output_thread_.joinable()) {
        LOG(config_.source_tag, "Joining output thread in destructor...");
        output_thread_.join();
        LOG(config_.source_tag, "Output thread joined.");
    }
     LOG(config_.source_tag, "Destructor finished.");
}

void SourceInputProcessor::initialize_audio_processor() {
    LOG(config_.source_tag, "Initializing AudioProcessor...");
    std::lock_guard<std::mutex> lock(audio_processor_mutex_);
    try {
        // Assuming input format is fixed for now (e.g., 16-bit, 2ch, 48kHz)
        // This might need to become dynamic based on RTP payload or config later
        audio_processor_ = std::make_unique<AudioProcessor>(
            DEFAULT_INPUT_CHANNELS,
            config_.output_channels,
            DEFAULT_INPUT_BITDEPTH,
            DEFAULT_INPUT_SAMPLERATE,
            config_.output_samplerate,
            current_volume_
        );
        // Set initial EQ
        audio_processor_->setEqualizer(current_eq_.data());
        LOG(config_.source_tag, "AudioProcessor created.");
    } catch (const std::exception& e) {
        LOG_ERROR(config_.source_tag, "Failed to initialize AudioProcessor: " + std::string(e.what()));
        // Handle error appropriately, maybe rethrow or set a failed state
        throw;
    }
}

void SourceInputProcessor::start() {
     if (is_running()) {
        LOG(config_.source_tag, "Already running.");
        return;
    }
    LOG(config_.source_tag, "Starting...");
    // Reset state specific to this component
    timeshift_buffer_read_idx_ = 0;
    process_buffer_.clear();
    // Implementation for start: set flag, launch thread
    stop_flag_ = false;
    try {
        component_thread_ = std::thread(&SourceInputProcessor::run, this);
        LOG(config_.source_tag, "Component thread launched.");
    } catch (const std::system_error& e) {
        LOG_ERROR(config_.source_tag, "Failed to start component thread: " + std::string(e.what()));
        stop_flag_ = true; // Ensure stopped state if launch fails
        // Rethrow or handle error appropriately
        throw;
    }
}


void SourceInputProcessor::stop() {
    if (stop_flag_) {
        LOG(config_.source_tag, "Already stopped or stopping.");
        return;
    }
    LOG(config_.source_tag, "Stopping...");

    // Set the stop flag FIRST (used by loops)
    stop_flag_ = true; // Set the atomic flag

    // Notify condition variables/queues AFTER setting stop_flag_
    timeshift_condition_.notify_all(); // Wake up output loop if waiting
    input_queue_->stop(); // Signal the input queue to stop blocking pop calls

    // Implementation for stop: join the component thread
    if (component_thread_.joinable()) {
        try {
            component_thread_.join();
            LOG(config_.source_tag, "Component thread joined.");
        } catch (const std::system_error& e) {
            LOG_ERROR(config_.source_tag, "Error joining component thread: " + std::string(e.what()));
            // Handle error appropriately
        }
    } else {
        LOG(config_.source_tag, "Component thread was not joinable in stop().");
    }
}


void SourceInputProcessor::process_commands() {
    ControlCommand cmd;
    // Use try_pop for non-blocking check
    while (command_queue_->try_pop(cmd)) {
        LOG(config_.source_tag, "Processing command: " + std::to_string(static_cast<int>(cmd.type)));
        bool needs_processor_update = false;
        bool needs_timeshift_update = false;

        { // Scope for mutex lock
            std::lock_guard<std::mutex> lock(audio_processor_mutex_); // Protects current settings and audio_processor_ calls
            std::lock_guard<std::mutex> ts_lock(timeshift_mutex_); // Protects timeshift settings

            switch (cmd.type) {
                case CommandType::SET_VOLUME:
                    current_volume_ = cmd.float_value;
                    needs_processor_update = true;
                    break;
                case CommandType::SET_EQ:
                    if (cmd.eq_values.size() == EQ_BANDS) {
                        current_eq_ = cmd.eq_values;
                        needs_processor_update = true;
                    } else {
                        LOG_ERROR(config_.source_tag, "Invalid EQ size in command: " + std::to_string(cmd.eq_values.size()));
                    }
                    break;
                case CommandType::SET_DELAY:
                    current_delay_ms_ = cmd.int_value;
                    needs_timeshift_update = true;
                    break;
                case CommandType::SET_TIMESHIFT:
                    current_timeshift_backshift_sec_ = cmd.float_value;
                    needs_timeshift_update = true;
                    break;
                default:
                    LOG_ERROR(config_.source_tag, "Unknown command type received.");
                    break;
            }
        } // Mutexes released here

        // Apply updates outside the lock if possible
        if (needs_processor_update && audio_processor_) {
             std::lock_guard<std::mutex> lock(audio_processor_mutex_);
             if (cmd.type == CommandType::SET_VOLUME) audio_processor_->setVolume(current_volume_);
             if (cmd.type == CommandType::SET_EQ) audio_processor_->setEqualizer(current_eq_.data());
        }
        if (needs_timeshift_update) {
            // Wake up output loop in case it was waiting based on old settings
            timeshift_condition_.notify_one();
        }
    }
}

void SourceInputProcessor::handle_new_input_packet(TaggedAudioPacket& packet) {
    size_t received_bytes = packet.audio_data.size();
    LOG_DEBUG(config_.source_tag, "InputLoop: Received packet. Size=" + std::to_string(received_bytes) + " bytes. Expected=" + std::to_string(INPUT_CHUNK_BYTES) + " bytes.");

    // Ensure packet data has the expected size before adding
    if (received_bytes != INPUT_CHUNK_BYTES) {
        LOG_ERROR(config_.source_tag, "Received packet with unexpected data size: " + std::to_string(received_bytes) + ". Discarding.");
        return;
    }

    {
        std::lock_guard<std::mutex> lock(timeshift_mutex_);
        // Add to the end of the deque
        timeshift_buffer_.push_back(std::move(packet)); // Move packet into buffer
    } // Mutex released

    // Notify the output_loop that new data might make it ready
    timeshift_condition_.notify_one();
}

// update_timeshift_target_time is REMOVED


void SourceInputProcessor::cleanup_timeshift_buffer() {
    // Assumes timeshift_mutex_ is locked
    if (timeshift_buffer_.empty()) {
        return;
    }
    // Calculate the oldest acceptable timestamp based on buffer duration
    auto now = std::chrono::steady_clock::now();
    auto max_age = std::chrono::seconds(config_.timeshift_buffer_duration_sec);
    auto oldest_allowed_time = now - max_age;

    // Remove packets older than the allowed time, BUT ensure we don't remove the packet currently being read
    size_t remove_count = 0;
    while (remove_count < timeshift_buffer_read_idx_ && // Only check packets before the read index
           !timeshift_buffer_.empty() &&
           timeshift_buffer_.front().received_time < oldest_allowed_time)
    {
        timeshift_buffer_.pop_front();
        remove_count++;
    }

    // Adjust the read index since we removed elements from the front
    if (remove_count > 0) {
        if (timeshift_buffer_read_idx_ >= remove_count) {
             timeshift_buffer_read_idx_ -= remove_count;
        } else {
             // Should not happen if logic is correct, but reset defensively
             LOG_ERROR(config_.source_tag, "Timeshift buffer read index inconsistency during cleanup.");
             timeshift_buffer_read_idx_ = 0;
        }
       LOG_DEBUG(config_.source_tag, "Cleaned up " + std::to_string(remove_count) + " old packets.");
    }
}


// get_next_input_chunk is REMOVED

void SourceInputProcessor::process_audio_chunk(const std::vector<uint8_t>& input_chunk_data) {
    if (!audio_processor_) {
        LOG_ERROR(config_.source_tag, "AudioProcessor not initialized. Cannot process chunk.");
        return;
    }
    size_t input_bytes = input_chunk_data.size();
    LOG_DEBUG(config_.source_tag, "ProcessAudio: Processing chunk. Input Size=" + std::to_string(input_bytes) + " bytes. Expected=" + std::to_string(INPUT_CHUNK_BYTES) + " bytes.");
    if (input_bytes != INPUT_CHUNK_BYTES) {
         LOG_ERROR(config_.source_tag, "process_audio_chunk called with incorrect data size: " + std::to_string(input_bytes) + ". Skipping processing.");
         return;
    }
    // Calculate expected output samples based on input bytes, input format, and output channels
    // Assuming 16-bit stereo input -> 1152 / (16/8) = 576 samples input
    // Output samples = input samples * output_channels / input_channels (if no resampling)
    // For 2ch->2ch, expect 576 output samples.
    size_t expected_output_samples = (INPUT_CHUNK_BYTES / (DEFAULT_INPUT_BITDEPTH / 8)) * config_.output_channels / DEFAULT_INPUT_CHANNELS;
    // Allocate a reasonably large buffer, AudioProcessor should handle its own output size.
    // Let's allocate based on OUTPUT_CHUNK_SAMPLES which should match expected_output_samples in the common case.
    std::vector<int32_t> processor_output_buffer(expected_output_samples * 2); // Provide some extra space

    int processed_samples = 0;
    { // Lock mutex for accessing AudioProcessor
        std::lock_guard<std::mutex> lock(audio_processor_mutex_);
        processed_samples = audio_processor_->processAudio(input_chunk_data.data(), processor_output_buffer.data());
    }

    if (processed_samples > 0) {
        // Append processed samples to the internal process_buffer_
        process_buffer_.insert(process_buffer_.end(),
                               processor_output_buffer.begin(),
                               processor_output_buffer.begin() + processed_samples);
        LOG_DEBUG(config_.source_tag, "ProcessAudio: Appended " + std::to_string(processed_samples) + " samples. process_buffer_ size=" + std::to_string(process_buffer_.size()) + " samples.");
    } else if (processed_samples < 0) {
         LOG_ERROR(config_.source_tag, "AudioProcessor::processAudio returned an error code: " + std::to_string(processed_samples));
    } else {
         LOG_DEBUG(config_.source_tag, "ProcessAudio: AudioProcessor returned 0 samples.");
    }
}

void SourceInputProcessor::push_output_chunk_if_ready() {
    // Check if we have enough samples for a full output chunk
    size_t required_samples = OUTPUT_CHUNK_SAMPLES; // Should be 576 for 16-bit stereo sink target
    size_t current_buffer_size = process_buffer_.size();

    LOG_DEBUG(config_.source_tag, "PushOutput: Checking buffer. Current=" + std::to_string(current_buffer_size) + " samples. Required=" + std::to_string(required_samples) + " samples.");

    while (current_buffer_size >= required_samples) {
        ProcessedAudioChunk output_chunk;
        // Copy the required number of samples
         output_chunk.audio_data.assign(process_buffer_.begin(), process_buffer_.begin() + required_samples);
         size_t pushed_samples = output_chunk.audio_data.size();

         // Push to the output queue
         LOG_DEBUG(config_.source_tag, "PushOutput: Pushing chunk with " + std::to_string(pushed_samples) + " samples (Expected=" + std::to_string(required_samples) + ") to Sink queue.");
         if (pushed_samples != required_samples) {
             LOG_ERROR(config_.source_tag, "PushOutput: Mismatch between pushed samples (" + std::to_string(pushed_samples) + ") and required samples (" + std::to_string(required_samples) + ").");
         }
         output_queue_->push(std::move(output_chunk));

         // Remove the copied samples from the process buffer
        process_buffer_.erase(process_buffer_.begin(), process_buffer_.begin() + required_samples);
        current_buffer_size = process_buffer_.size(); // Update size after erasing

        LOG_DEBUG(config_.source_tag, "PushOutput: Pushed chunk. Remaining process_buffer_ size=" + std::to_string(current_buffer_size) + " samples.");
    }
}

// --- New/Modified Thread Loops ---

void SourceInputProcessor::input_loop() {
    LOG(config_.source_tag, "Input loop started.");
    TaggedAudioPacket new_packet;
    // Loop exits when pop returns false (queue stopped and empty)
    while (input_queue_->pop(new_packet)) {
         if (stop_flag_) break; // Check component stop flag as well
         handle_new_input_packet(new_packet); // Adds to buffer and notifies output loop
    }
    LOG(config_.source_tag, "Input loop exiting.");
}

void SourceInputProcessor::output_loop() {
    LOG(config_.source_tag, "Output loop started.");
    std::vector<uint8_t> current_input_chunk_data;
    current_input_chunk_data.reserve(INPUT_CHUNK_BYTES);
    auto last_cleanup_time = std::chrono::steady_clock::now();
    auto loop_start_time = std::chrono::steady_clock::now(); // Time each loop iteration

    // Define a timeout for the condition variable wait
    // Adjust this value based on expected network conditions and desired responsiveness
    const std::chrono::milliseconds wait_timeout(100); // e.g., 100ms timeout

    while (!stop_flag_) {
        bool data_retrieved = false;
        loop_start_time = std::chrono::steady_clock::now(); // Reset timer at start of loop
        std::chrono::microseconds retrieve_duration(0); // Initialize here

        { // Scope for timeshift mutex lock
            std::unique_lock<std::mutex> lock(timeshift_mutex_);

            LOG_DEBUG(config_.source_tag, "OutputLoop: Waiting. BufSize=" << timeshift_buffer_.size() << ", ReadIdx=" << timeshift_buffer_read_idx_);

            // Wait using wait_for with a timeout
            auto predicate = [&] {
                // Check stop flag first inside predicate
                if (stop_flag_) return true;

                auto check_start = std::chrono::steady_clock::now();
                bool ready = check_readiness_condition();
                auto check_end = std::chrono::steady_clock::now();
                auto check_duration = std::chrono::duration_cast<std::chrono::microseconds>(check_end - check_start);
                // Log readiness check inside the loop if debugging heavily
                // LOG_DEBUG(config_.source_tag, "OutputLoop: Wait predicate check took " << check_duration.count() << "us. Ready=" << ready);
                return ready; // Return true if ready (or if stop_flag_ was set)
            };

            // wait_for returns false if timeout occurred before condition met
            if (!timeshift_condition_.wait_for(lock, wait_timeout, predicate)) {
                // Timeout occurred! Condition was not met within wait_timeout.
                if (stop_flag_) {
                    LOG_DEBUG(config_.source_tag, "OutputLoop: Stop flag set during timeout wait, breaking.");
                    break; // Exit outer loop if stopped
                }

                // If not stopped, timeout means data wasn't ready in time.
                // What to do?
                // Option 1: Log and continue loop (will wait again). Good if temporary glitch.
                // Option 2: Try to skip ahead? Risky, might lose sync.
                // Option 3: Generate silence? Requires more logic.
                // Let's log and continue for now.
                LOG_DEBUG(config_.source_tag, "OutputLoop: Wait timed out after " << wait_timeout.count() << "ms. No data ready.");
                // We might still want to cleanup the buffer periodically even on timeouts
                 auto now = std::chrono::steady_clock::now();
                 if (now - last_cleanup_time > TIMESIFT_CLEANUP_INTERVAL) {
                     cleanup_timeshift_buffer();
                     last_cleanup_time = now;
                 }
                continue; // Go back to the start of the while loop to wait again
            }

            // If wait succeeded (didn't time out and predicate is true) OR stop_flag_ became true:
            LOG_DEBUG(config_.source_tag, "OutputLoop: Woke up/Wait satisfied. StopFlag=" << stop_flag_);

            // If stopped while waiting or after waking up, exit loop
            if (stop_flag_) {
                LOG_DEBUG(config_.source_tag, "OutputLoop: Stop flag set, breaking wait loop.");
                break;
            }

            // ---- If we got here, the predicate (check_readiness_condition) was true ----
            auto retrieve_start = std::chrono::steady_clock::now();
            // Data should be ready because the predicate was met
            if (timeshift_buffer_read_idx_ < timeshift_buffer_.size()) {
                 LOG_DEBUG(config_.source_tag, "OutputLoop: Data ready. Retrieving packet at index " << timeshift_buffer_read_idx_);
                 current_input_chunk_data = timeshift_buffer_[timeshift_buffer_read_idx_].audio_data;
                 // Note: Copying data here. Could be optimized with move if TaggedAudioPacket is not needed after this.
                 timeshift_buffer_read_idx_++;
                 data_retrieved = true;
                 LOG_DEBUG(config_.source_tag, "OutputLoop: Read index advanced to " << timeshift_buffer_read_idx_);
            } else {
                 // This case should ideally not happen if wait condition and predicate are correct
                 LOG_ERROR(config_.source_tag, "Output loop woke up ready, but read index (" << timeshift_buffer_read_idx_ << ") is out of bounds for buffer size (" << timeshift_buffer_.size() << ").");
                 // Reset read index defensively? Or just continue? Let's continue for now.
                 continue; // Continue loop to re-evaluate state
            }
            auto retrieve_end = std::chrono::steady_clock::now();
            retrieve_duration = std::chrono::duration_cast<std::chrono::microseconds>(retrieve_end - retrieve_start); // Assign here


             // Periodically cleanup the timeshift buffer (while lock is held)
             auto now = std::chrono::steady_clock::now();
             if (now - last_cleanup_time > TIMESIFT_CLEANUP_INTERVAL) {
                 cleanup_timeshift_buffer();
                 last_cleanup_time = now;
             }
        } // Mutex lock released

        auto wait_end = std::chrono::steady_clock::now();
        auto wait_duration = std::chrono::duration_cast<std::chrono::milliseconds>(wait_end - loop_start_time);
        // This logging might be confusing now due to potential timeouts, adjust as needed
        LOG_DEBUG(config_.source_tag, "OutputLoop: Wait/Check phase finished in " << wait_duration.count() << "ms. Retrieve took " << retrieve_duration.count() << "us. DataRetrieved=" << data_retrieved);


        // Process the retrieved data (outside the timeshift lock)
        if (data_retrieved) {
            auto process_start = std::chrono::steady_clock::now();
            LOG_DEBUG(config_.source_tag, "OutputLoop: Processing retrieved chunk.");
            process_audio_chunk(current_input_chunk_data);
            push_output_chunk_if_ready();
            LOG_DEBUG(config_.source_tag, "OutputLoop: Finished processing chunk.");
            auto process_end = std::chrono::steady_clock::now();
            auto process_duration = std::chrono::duration_cast<std::chrono::microseconds>(process_end - process_start);
            LOG_DEBUG(config_.source_tag, "OutputLoop: Processing & Push took " << process_duration.count() << "us.");
        } else {
             // This branch might be reached if stopped during wait or after a timeout where we 'continue'd
             LOG_DEBUG(config_.source_tag, "OutputLoop: No data retrieved this iteration (timeout or stopped?).");
        }
    } // end while (!stop_flag_)

    LOG(config_.source_tag, "Output loop exiting.");
}

// Make sure the check_readiness_condition remains the same as it correctly
// implements the time-based logic for this single-source processor.
bool SourceInputProcessor::check_readiness_condition() {
    // Assumes timeshift_mutex_ is already locked by the caller (the wait predicate)
    if (timeshift_buffer_read_idx_ >= timeshift_buffer_.size()) {
        // LOG_DEBUG(config_.source_tag, "CheckReady: Read index out of bounds (" << timeshift_buffer_read_idx_ << " >= " << timeshift_buffer_.size() << ")");
        return false; // Cannot be ready if index is out of bounds or buffer empty relative to index
    }

    // Calculate the target play time for the next packet
    auto packet_received_time = timeshift_buffer_.at(timeshift_buffer_read_idx_).received_time;
    auto delay_duration = std::chrono::milliseconds(current_delay_ms_);
    auto backshift_duration = std::chrono::duration_cast<std::chrono::steady_clock::duration>(
                                  std::chrono::duration<double>(current_timeshift_backshift_sec_));
    auto scheduled_play_time = packet_received_time + delay_duration - backshift_duration;

    // Get current time
    auto now = std::chrono::steady_clock::now();
    auto time_until_play = std::chrono::duration_cast<std::chrono::milliseconds>(scheduled_play_time - now);

    // Log detailed timing information (only if needed, can be verbose)
    // LOG_DEBUG(config_.source_tag, "CheckReady: Idx=" << timeshift_buffer_read_idx_
    //             << ", BufSize=" << timeshift_buffer_.size()
    //             << ", Delay=" << current_delay_ms_ << "ms"
    //             << ", Backshift=" << current_timeshift_backshift_sec_ << "s"
    //             << ", ScheduledIn=" << time_until_play.count() << "ms");

    bool ready = scheduled_play_time <= now;

    // LOG_DEBUG(config_.source_tag, "CheckReady: Result = " << ready);
    return ready;
}

void SourceInputProcessor::run() {
    LOG(config_.source_tag, "Entering run loop (thread manager).");

    // Start the dedicated input and output threads
    try {
        input_thread_ = std::thread(&SourceInputProcessor::input_loop, this);
        LOG(config_.source_tag, "Input thread launched.");
        output_thread_ = std::thread(&SourceInputProcessor::output_loop, this);
        LOG(config_.source_tag, "Output thread launched.");
    } catch (const std::system_error& e) {
        LOG_ERROR(config_.source_tag, "Failed to start worker threads: " + std::string(e.what()));
        stop_flag_ = true; // Signal stop if threads failed to launch
        // Notify potentially waiting threads even if launch failed partially
        timeshift_condition_.notify_all();
        // input_queue_->notify_all(); // Removed - stop() handles notification
        return; // Exit run loop immediately
    }

    // This thread now only processes commands until stop is signaled
    while (!stop_flag_) {
        process_commands(); // Check for commands

        // Sleep briefly to prevent busy-waiting
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    // --- Cleanup after stop_flag_ is set ---
    LOG(config_.source_tag, "Run loop exiting (stop signaled).");
    // Joining of input_thread_ and output_thread_ happens in the destructor.
    // Ensure worker threads are signaled to stop (already done in stop())
}
source_input_processor.h0000644000000000000000000001116615006201044014540 0ustar  rootroot#ifndef SOURCE_INPUT_PROCESSOR_H
#define SOURCE_INPUT_PROCESSOR_H

#include "audio_component.h"
#include "thread_safe_queue.h"
#include "audio_types.h"
#include "../c_utils/audio_processor.h" // Include the existing AudioProcessor

#include <string>
#include <vector>
#include <deque>
#include <chrono>
#include <memory> // For unique_ptr, shared_ptr
#include <mutex>
#include <condition_variable>

namespace screamrouter {
namespace audio {

// Using aliases for clarity
using InputPacketQueue = utils::ThreadSafeQueue<TaggedAudioPacket>;
using OutputChunkQueue = utils::ThreadSafeQueue<ProcessedAudioChunk>;
using CommandQueue = utils::ThreadSafeQueue<ControlCommand>;

// Define constants based on original code/assumptions
const size_t INPUT_CHUNK_BYTES = 1152; // Expected size of audio_data in TaggedAudioPacket
const int DEFAULT_INPUT_BITDEPTH = 16; // Assume 16-bit input unless specified
const int DEFAULT_INPUT_CHANNELS = 2;  // Assume stereo input unless specified
const int DEFAULT_INPUT_SAMPLERATE = 48000; // Assume 48kHz input unless specified
// Match the number of samples SinkAudioMixer expects in its mixing buffer (SINK_MIXING_BUFFER_SAMPLES)
// which is 576 for the current 16-bit stereo output target.
const size_t OUTPUT_CHUNK_SAMPLES = 576; // Total interleaved 32-bit samples expected in ProcessedAudioChunk

class SourceInputProcessor : public AudioComponent {
public:
    SourceInputProcessor(
        SourceProcessorConfig config,
        std::shared_ptr<InputPacketQueue> input_queue,
        std::shared_ptr<OutputChunkQueue> output_queue,
        std::shared_ptr<CommandQueue> command_queue
    );

    ~SourceInputProcessor() override;

    // --- AudioComponent Interface ---
    void start() override;
    void stop() override;

    // --- Getters for Synchronization Primitives ---
    std::mutex* get_timeshift_mutex() { return &timeshift_mutex_; }
    std::condition_variable* get_timeshift_cv() { return &timeshift_condition_; }

protected:
    // --- AudioComponent Interface ---
    void run() override; // The main thread loop - will now manage input/output threads

    // --- Thread loop functions ---
    void input_loop();
    void output_loop();

private:
    SourceProcessorConfig config_;
    std::shared_ptr<InputPacketQueue> input_queue_;
    std::shared_ptr<OutputChunkQueue> output_queue_;
    std::shared_ptr<CommandQueue> command_queue_;

    // Internal State
    std::unique_ptr<AudioProcessor> audio_processor_;
    std::mutex audio_processor_mutex_; // Protects audio_processor_ and related settings

    // Timeshift buffer (stores raw input packets)
    std::deque<TaggedAudioPacket> timeshift_buffer_;
    size_t timeshift_buffer_read_idx_ = 0; // Index of the next packet to read
    std::chrono::steady_clock::time_point timeshift_target_play_time_; // Calculated target time
    std::mutex timeshift_mutex_; // Protects timeshift buffer and related vars
    std::condition_variable timeshift_condition_; // To wake up run loop when data arrives/is ready

    // Processing buffer (holds output from AudioProcessor before pushing full chunks)
    std::vector<int32_t> process_buffer_;
    // size_t process_buffer_samples_ = 0; // Tracked by process_buffer_.size()

    // Current settings (can be updated by commands)
    float current_volume_;
    std::vector<float> current_eq_;
    int current_delay_ms_;
    float current_timeshift_backshift_sec_; // How far back to play from 'now'

    // Thread management (stop_flag_ is inherited from AudioComponent)
    std::thread input_thread_;
    std::thread output_thread_;

    // Methods
    void process_commands(); // Check command queue and update state (non-blocking)
    bool get_next_input_chunk(std::vector<uint8_t>& chunk_data); // Handles timeshift logic, pulls from input_queue_
    void update_timeshift_target_time(); // Recalculate target play time based on backshift/delay
    // bool is_timeshift_data_ready(std::chrono::steady_clock::time_point& ready_packet_time); // Replaced by check_readiness_condition
    bool check_readiness_condition(); // Checks if the next packet is ready based on scheduled time vs now
    void cleanup_timeshift_buffer(); // Remove old data
    void handle_new_input_packet(TaggedAudioPacket& packet); // Adds packet to timeshift buffer, notifies CV

    // Audio processing methods
    void initialize_audio_processor(); // Creates/updates the AudioProcessor instance
    void process_audio_chunk(const std::vector<uint8_t>& input_chunk_data); // Calls audio_processor_->processAudio
    void push_output_chunk_if_ready(); // Pushes a full ProcessedAudioChunk to output_queue_
};

} // namespace audio
} // namespace screamrouter

#endif // SOURCE_INPUT_PROCESSOR_H
thread_safe_queue.h0000644000000000000000000001011315005717771013404 0ustar  rootroot#ifndef THREAD_SAFE_QUEUE_H
#define THREAD_SAFE_QUEUE_H

#include <deque>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory> // For std::move

namespace screamrouter {
namespace utils {

template <typename T>
class ThreadSafeQueue {
public:
    ThreadSafeQueue() : stop_requested_(false) {}

    // Non-copyable and non-movable for simplicity, manage via pointers (e.g., shared_ptr)
    ThreadSafeQueue(const ThreadSafeQueue&) = delete;
    ThreadSafeQueue& operator=(const ThreadSafeQueue&) = delete;
    ThreadSafeQueue(ThreadSafeQueue&&) = delete;
    ThreadSafeQueue& operator=(ThreadSafeQueue&&) = delete;

    /**
     * @brief Pushes an item onto the queue. Thread-safe.
     * @param item The item to push (will be moved).
     */
    void push(T item) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            if (stop_requested_) {
                // Optional: Throw an exception or handle if pushing after stop is invalid
                return;
            }
            queue_.push_back(std::move(item));
        } // Mutex released here
        cond_.notify_one();
    }

    /**
     * @brief Pops an item from the queue. Blocks if the queue is empty until an item
     *        is available or stop() is called. Thread-safe.
     * @param item Reference to store the popped item.
     * @return true if an item was successfully popped, false if the queue was stopped.
     */
    bool pop(T& item) {
        std::unique_lock<std::mutex> lock(mutex_);
        cond_.wait(lock, [this] { return !queue_.empty() || stop_requested_; });

        if (stop_requested_ && queue_.empty()) {
            return false; // Stopped and no items left
        }

        if (!queue_.empty()) {
            item = std::move(queue_.front());
            queue_.pop_front();
            return true;
        }

        // Should not be reached if logic is correct, but handle defensively
        return false;
    }

    /**
     * @brief Attempts to pop an item from the queue without blocking. Thread-safe.
     * @param item Reference to store the popped item if successful.
     * @return true if an item was popped, false if the queue was empty.
     */
    bool try_pop(T& item) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty() || stop_requested_) { // Don't pop if stopped, even if items remain? Or allow draining? Let's allow draining.
             if (queue_.empty()) {
                return false;
             }
        }
        item = std::move(queue_.front());
        queue_.pop_front();
        return true;
    }

    /**
     * @brief Signals the queue to stop blocking operations and notifies waiting threads.
     *        After calling stop(), subsequent push operations might be ignored or throw,
     *        and pop operations will return false once the queue is empty. Thread-safe.
     */
    void stop() {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            stop_requested_ = true;
        } // Mutex released here
        cond_.notify_all(); // Wake up all waiting threads
    }

    /**
     * @brief Checks if the queue is currently empty. Thread-safe.
     * @return true if the queue is empty, false otherwise.
     */
    bool empty() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

    /**
     * @brief Gets the current number of items in the queue. Thread-safe.
     * @return The number of items in the queue.
     */
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }

    /**
     * @brief Checks if the queue has been stopped. Thread-safe.
     * @return true if stop() has been called, false otherwise.
     */
    bool is_stopped() const {
        // No lock needed for atomic read
        return stop_requested_;
    }

private:
    mutable std::mutex mutex_; // Mutable to allow locking in const methods like empty() and size()
    std::condition_variable cond_;
    std::deque<T> queue_;
    std::atomic<bool> stop_requested_;
};

} // namespace utils
} // namespace screamrouter

#endif // THREAD_SAFE_QUEUE_H

audio_processor.cpp0000644000000000000000000026400015006206411013455 0ustar  rootrootlayout_mixer.cpp0000644000000000000000000003174314774634217013030 0ustar  rootroot#include <stdexcept>
#include <string.h>
#define MAX_CHANNELS 8
class layout_mixer {
public:
    float speaker_mix[MAX_CHANNELS][MAX_CHANNELS] = {{1}};
    int input_channels = 0;
    int output_channels = 0;
    
    // constructor to initialize the variables
    layout_mixer(int input_ch, int output_ch) : input_channels(input_ch), output_channels(output_ch) {
        if (input_ch > MAX_CHANNELS || output_ch > MAX_CHANNELS) {
            throw std::invalid_argument("Number of channels cannot exceed " + std::to_string(MAX_CHANNELS));
        }
        build_speaker_mix_table();
    }

    void build_speaker_mix_table()
    { // Fills out the speaker mix table speaker_mix[][] with the current configuration.
        memset(speaker_mix, 0, sizeof(speaker_mix));
        // speaker_mix[input channel][output channel] = gain;
        // Ex: To map Left on Stereo to Right on Stereo at half volume you would do:
        // speaker_mix[0][1] = .5;
        switch (input_channels)
        {
        case 1: // Mono, Ch 0: Left
            // Mono -> All
            for (int output_channel = 0; output_channel < MAX_CHANNELS; output_channel++) // Write the left (first) speaker to every channel
                speaker_mix[0][output_channel] = 1;
            break;
        case 2: // Stereo, Ch 0: Left, Ch 1: Right
            switch (output_channels)
            {
            case 1:                     // Stereo -> Mono
                speaker_mix[0][0] = .5; // Left to mono .5 vol
                speaker_mix[1][0] = .5; // Right to mono .5 vol
                break;
            case 2:                    // Stereo -> Stereo
                speaker_mix[0][0] = 1; // Left to Left
                speaker_mix[1][1] = 1; // Right to Right
                break;
            case 4:
                speaker_mix[0][0] = 1; // Left to Front Left
                speaker_mix[1][1] = 1; // Right to Front Right
                speaker_mix[0][2] = 1; // Left to Back Left
                speaker_mix[1][3] = 1; // Right to Back Right
                break;
            case 6: // Stereo -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = 1;  // Left to Front Left
                speaker_mix[0][5] = 1;  // Left to Rear Left
                speaker_mix[1][1] = 1;  // Right to Front Right
                speaker_mix[1][6] = 1;  // Right to Rear Right
                speaker_mix[0][3] = .5; // Left to Center Half Vol
                speaker_mix[1][3] = .5; // Right to Center Half Vol
                speaker_mix[0][4] = .5; // Right to Sub Half Vol
                speaker_mix[1][4] = .5; // Left to Sub Half Vol
                break;
            case 8: // Stereo -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1;  // Left to Front Left
                speaker_mix[0][6] = 1;  // Left to Side Left
                speaker_mix[0][4] = 1;  // Left to Rear Left
                speaker_mix[1][1] = 1;  // Right to Front Right
                speaker_mix[1][7] = 1;  // Right to Side Right
                speaker_mix[1][5] = 1;  // Right to Rear Right
                speaker_mix[0][2] = .5; // Left to Center Half Vol
                speaker_mix[1][2] = .5; // Right to Center Half Vol
                speaker_mix[0][3] = .5; // Right to Sub Half Vol
                speaker_mix[1][3] = .5; // Left to Sub Half Vol
                break;
            }
            break;
        case 4:
            switch (output_channels)
            {
            case 1:                      // Quad -> Mono
                speaker_mix[0][0] = .25; // Front Left to Mono
                speaker_mix[1][0] = .25; // Front Right to Mono
                speaker_mix[2][0] = .25; // Rear Left to Mono
                speaker_mix[3][0] = .25; // Rear Right to Mono
                break;
            case 2:                     // Quad -> Stereo
                speaker_mix[0][0] = .5; // Front Left to Left
                speaker_mix[1][1] = .5; // Front Right to Right
                speaker_mix[2][0] = .5; // Rear Left to Left
                speaker_mix[3][1] = .5; // Rear Right to Right
                break;
            case 4:
                speaker_mix[0][0] = 1; // Front Left to Front Left
                speaker_mix[1][1] = 1; // Front Right to Front Right
                speaker_mix[2][2] = 1; // Rear Left to Rear Left
                speaker_mix[3][3] = 1; // Rear Right to Rear Right
                break;
            case 6: // Quad -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = 1;   // Front Left to Front Left
                speaker_mix[1][1] = 1;   // Front Right to Front Right
                speaker_mix[0][2] = .5;  // Front Left to Center
                speaker_mix[1][2] = .5;  // Front Right to Center
                speaker_mix[0][3] = .25; // Front Left to LFE
                speaker_mix[1][3] = .25; // Front Right to LFE
                speaker_mix[2][3] = .25; // Rear Left to LFE
                speaker_mix[3][3] = .25; // Rear Right to LFE
                speaker_mix[2][4] = 1;   // Rear Left to Rear Left
                speaker_mix[3][5] = 1;   // Rear Right to Rear Right
                break;
            case 8: // Quad -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1;   // Front Left to Front Left
                speaker_mix[1][1] = 1;   // Front Right to Front Right
                speaker_mix[0][2] = .5;  // Front Left to Center
                speaker_mix[1][2] = .5;  // Front Right to Center
                speaker_mix[0][3] = .25; // Front Left to LFE
                speaker_mix[1][3] = .25; // Front Right to LFE
                speaker_mix[2][3] = .25; // Rear Left to LFE
                speaker_mix[3][3] = .25; // Rear Right to LFE
                speaker_mix[2][4] = 1;   // Rear Left to Rear Left
                speaker_mix[3][5] = 1;   // Rear Right to Rear Right
                speaker_mix[0][6] = .5;  // Front Left to Side Left
                speaker_mix[1][7] = .5;  // Front Right to Side Right
                speaker_mix[2][6] = .5;  // Rear Left to Side Left
                speaker_mix[3][7] = .5;  // Rear Right to Side Right
                break;
            }
            break;
        case 6:
            switch (output_channels)
            {
            case 1:                     // 5.1 Surround -> Mono
                speaker_mix[0][0] = .2; // Front Left to Mono
                speaker_mix[1][0] = .2; // Front Right to Mono
                speaker_mix[2][0] = .2; // Center to Mono
                speaker_mix[4][0] = .2; // Rear Left to Mono
                speaker_mix[5][0] = .2; // Rear Right to Mono
                break;
            case 2:                      // 5.1 Surround -> Stereo
                speaker_mix[0][0] = .33; // Front Left to Left
                speaker_mix[1][1] = .33; // Front Right to Right
                speaker_mix[2][0] = .33; // Center to Left
                speaker_mix[2][1] = .33; // Center to Right
                speaker_mix[4][0] = .33; // Rear Left to Left
                speaker_mix[5][1] = .33; // Rear Right to Right
                break;
            case 4:
                speaker_mix[0][0] = .66; // Front Left to Front Left
                speaker_mix[1][1] = .66; // Front Right to Front Right
                speaker_mix[2][0] = .33; // Center to Front Left
                speaker_mix[2][1] = .33; // Center to Front Right
                speaker_mix[4][2] = 1;   // Rear Left to Rear Left
                speaker_mix[5][3] = 1;   // Rear Right to Rear Right
                break;
            case 6: // 5.1 Surround -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = 1; // Front Left to Front Left
                speaker_mix[1][1] = 1; // Front Right to Front Right
                speaker_mix[2][2] = 1; // Center to Center
                speaker_mix[3][3] = 1; // LFE to LFE
                speaker_mix[4][4] = 1; // Rear Left to Rear Left
                speaker_mix[5][5] = 1; // Rear Right to Rear Right
                break;
            case 8: // 5.1 Surround -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1;  // Front Left to Front Left
                speaker_mix[1][1] = 1;  // Front Right to Front Right
                speaker_mix[2][2] = 1;  // Center to Center
                speaker_mix[3][3] = 1;  // LFE to LFE
                speaker_mix[4][4] = 1;  // Rear Left to Rear Left
                speaker_mix[5][5] = 1;  // Rear Right to Rear Right
                speaker_mix[0][6] = .5; // Front Left to Side Left
                speaker_mix[1][7] = .5; // Front Right to Side Right
                speaker_mix[4][6] = .5; // Rear Left to Side Left
                speaker_mix[5][7] = .5; // Rear Right to Side Right
                break;
            }
            break;
        case 8:
            switch (output_channels)
            {
            case 1:                              // 7.1 Surround -> Mono
                speaker_mix[0][0] = 1.0f / 7.0f; // Front Left to Mono
                speaker_mix[1][0] = 1.0f / 7.0f; // Front Right to Mono
                speaker_mix[2][0] = 1.0f / 7.0f; // Center to Mono
                speaker_mix[4][0] = 1.0f / 7.0f; // Rear Left to Mono
                speaker_mix[5][0] = 1.0f / 7.0f; // Rear Right to Mono
                speaker_mix[6][0] = 1.0f / 7.0f; // Side Left to Mono
                speaker_mix[7][0] = 1.0f / 7.0f; // Side Right to Mono
                break;
            case 2:                       // 7.1 Surround -> Stereo
                speaker_mix[0][0] = .5;   // Front Left to Left
                speaker_mix[1][1] = .5;   // Front Right to Right
                speaker_mix[2][0] = .25;  // Center to Left
                speaker_mix[2][1] = .25;  // Center to Right
                speaker_mix[4][0] = .125; // Rear Left to Left
                speaker_mix[5][1] = .125; // Rear Right to Right
                speaker_mix[6][0] = .125; // Side Left to Left
                speaker_mix[7][1] = .125; // Side Right to Right
                break;
            case 4:                      // 7.1 Surround -> Quad
                speaker_mix[0][0] = .5;  // Front Left to Front Left
                speaker_mix[1][1] = .5;  // Front Right to Front Right
                speaker_mix[2][0] = .25; // Center to Front Left
                speaker_mix[2][1] = .25; // Center to Front Right
                speaker_mix[4][2] = .66; // Rear Left to Rear Left
                speaker_mix[5][3] = .66; // Rear Right to Rear Right
                speaker_mix[6][0] = .25; // Side Left to Front Left
                speaker_mix[7][1] = .25; // Side Left to Front Right
                speaker_mix[6][2] = .33; // Side Left to Rear Left
                speaker_mix[7][3] = .33; // Side Left to Rear Right
                break;
            case 6: // 7.1 Surround -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = .66; // Front Left to Front Left
                speaker_mix[1][1] = .66; // Front Right to Front Right
                speaker_mix[2][2] = 1;   // Center to Center
                speaker_mix[3][3] = 1;   // LFE to LFE
                speaker_mix[4][4] = .66; // Rear Left to Rear Left
                speaker_mix[5][5] = .66; // Rear Right to Rear Right
                speaker_mix[6][0] = .33; // Side Left to Front Left
                speaker_mix[7][1] = .33; // Side Right to Front Right
                speaker_mix[6][4] = .33; // Side Left to Rear Left
                speaker_mix[7][5] = .33; // Side Right to Rear Right
                break;
            case 8: // 7.1 Surround -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1; // Front Left to Front Left
                speaker_mix[1][1] = 1; // Front Right to Front Right
                speaker_mix[2][2] = 1; // Center to Center
                speaker_mix[3][3] = 1; // LFE to LFE
                speaker_mix[4][4] = 1; // Rear Left to Rear Left
                speaker_mix[5][5] = 1; // Rear Right to Rear Right
                speaker_mix[6][6] = 1; // Side Left to Side Left
                speaker_mix[7][7] = 1; // Side Right to Side Right
                break;
            }
            break;
        }
    }

    void mix_speakers(int32_t** in_buffer, int32_t** remixed_out_buffer, int sample_count) {
        for (int pos = 0; pos < sample_count; pos++)
            for (int input_channel = 0; input_channel < input_channels; input_channel++)
                for (int output_channel = 0; output_channel < output_channels; output_channel++)
                        remixed_out_buffer[input_channel][output_channel] = 0;
        for (int pos = 0; pos < sample_count; pos++)
            for (int input_channel = 0; input_channel < input_channels; input_channel++)
                for (int output_channel = 0; output_channel < output_channels; output_channel++)
                    remixed_out_buffer[output_channel][pos] += in_buffer[input_channel][pos] * speaker_mix[input_channel][output_channel];
    }
};rtp_receiver.cpp0000644000000000000000000001360615000443333012752 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <lame/lame.h>
#include <algorithm>
#include <string>
#include <pthread.h>
#include <sched.h>
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio stream
#define RTP_HEADER_SIZE 12 // Size of the Scream header, which contains information about the output audio stream
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE) // Total packet size including header and chunk
#define TAG_LENGTH 45
#define DATA_RECEIVE_POS (TAG_LENGTH - (RTP_HEADER_SIZE - HEADER_SIZE))

bool running = true; // Flag to control loop execution

uint8_t buffer[TAG_LENGTH + RTP_HEADER_SIZE + CHUNK_SIZE] = {0}; // Vector of pointers to receive buffers for input streams

uint8_t header[HEADER_SIZE] = {0};

vector<int> output_fds; // Vector of file descriptors for audio input streams

int listen_fd = 0; // fd for audio input

int data_fd = 0; // fd for writing IPs to

vector<string> known_ip_procs = {};

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      &listen_fd,
                      &data_fd};
int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

struct sockaddr_in receive_addr;

socklen_t receive_addr_len = sizeof(receive_addr);

void log(const string &message, bool endl = true, bool tag = true) {
    printf("%s %s%s", tag?"[RTP Listener]":"", message.c_str(), endl?"\n":"");
}

// Function to process fixed command line arguments like IP address and output port
void process_args(int argc, char** argv) {
    if (argc <= config_argc)
        ::exit(-1);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
void process_fd_args(int argc, char* argv[]) {
    for (int argi = config_argc; argi < argc; argi++) {
        output_fds.push_back(atoi(argv[argi]));
    }
}

void setup_header() { // Sets up the Scream header
    int output_samplerate = 48000;
    int output_bitdepth = 16;
    int output_channels = 2;
    int output_chlayout1 = 0x03;
    int output_chlayout2 = 0x00;
    bool output_samplerate_44100_base = (output_samplerate % 44100) == 0;
    // cppcheck-suppress knownConditionTrueFalse
    uint8_t output_samplerate_mult = (output_samplerate_44100_base?44100:48000) / output_samplerate;
    header[0] = output_samplerate_mult + (output_samplerate_44100_base << 7);
    header[1] = output_bitdepth;
    header[2] = output_channels;
    header[3] = output_chlayout1;
    header[4] = output_chlayout2;
    log("Set up Header, Rate: " + to_string(output_samplerate) + ", Bit-Depth" + to_string(output_bitdepth) + ", Channels" + to_string(output_channels));
}

bool parseHeader() {
    // Parse RTP header (first 12 bytes of buffer)
    /*uint8_t version = (buffer[DATA_RECEIVE_POS] >> 6) & 0x03;
    bool padding = (buffer[DATA_RECEIVE_POS] >> 5) & 0x01;
    bool extension = (buffer[DATA_RECEIVE_POS] >> 4) & 0x01;
    uint8_t csrcCount = buffer[DATA_RECEIVE_POS] & 0x0F;
    bool marker = (buffer[DATA_RECEIVE_POS + 1] >> 7) & 0x01;*/
    uint8_t payloadType = buffer[DATA_RECEIVE_POS + 1] & 0x7F;
    /*uint16_t sequenceNumber = (buffer[DATA_RECEIVE_POS + 2] << 8) | buffer[DATA_RECEIVE_POS + 3];
    uint32_t timestamp = (buffer[DATA_RECEIVE_POS + 4] << 24) | (buffer[DATA_RECEIVE_POS + 5] << 16) |
                         (buffer[DATA_RECEIVE_POS + 6] << 8) | buffer[DATA_RECEIVE_POS + 7];
    uint32_t ssrc = (buffer[DATA_RECEIVE_POS + 8] << 24) | (buffer[DATA_RECEIVE_POS + 9] << 16) |
                    (buffer[DATA_RECEIVE_POS + 10] << 8) | buffer[DATA_RECEIVE_POS + 11];*/
    return payloadType == 127; // Return true if parsing was successful
}

bool receive() {
    int bytes = recvfrom(listen_fd, buffer + DATA_RECEIVE_POS, RTP_HEADER_SIZE+CHUNK_SIZE, 0, (struct sockaddr *) &receive_addr, &receive_addr_len);
    if (bytes == -1) 
        ::exit(-1);
    if (bytes != RTP_HEADER_SIZE+CHUNK_SIZE)
        return false;
    return true;
}

void send() {
    memset(buffer, 0, TAG_LENGTH);
    strcpy(reinterpret_cast<char*>(buffer), inet_ntoa(receive_addr.sin_addr));
    string ip_address = string(reinterpret_cast<char*>(buffer));
    if (find(known_ip_procs.begin(), known_ip_procs.end(), ip_address) == known_ip_procs.end()) {
        known_ip_procs.push_back(ip_address);
        write(data_fd, (ip_address + "\n").c_str(), ip_address.length());
    }
    memcpy(buffer + TAG_LENGTH, header, HEADER_SIZE);
    for (int fd_idx=0;fd_idx<output_fds.size();fd_idx++)
        write(output_fds[fd_idx], buffer, PACKET_SIZE + TAG_LENGTH);
}

int main(int argc, char* argv[]) {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1", true, true);
    } else {
        log("Successfully pinned to CPU core 1", true, true);
    }

    process_args(argc, argv);

    process_fd_args(argc, argv);
    log("Input FDs: ", false, true);
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]) + " ", false, false);
    log("", true, false);
    setup_header();

    while (running)
        if (receive())
            if (parseHeader())
                send();
        else
            sleep(.2);
    return 0;
}
scream_per_process_receiver.cpp0000644000000000000000000001232215000443373016021 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <sys/select.h>
#include <sys/time.h>
#include <lame/lame.h>
#include <algorithm>
#include <string>
#include <pthread.h>
#include <sched.h>
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define IP_LENGTH 15
#define PROGRAM_TAG_LENGTH 30
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio strea
#define PACKET_SIZE (CHUNK_SIZE + PROGRAM_TAG_LENGTH + HEADER_SIZE) // Total packet size including header and chunk

bool running = true; // Flag to control loop execution

uint8_t buffer[IP_LENGTH + PACKET_SIZE] = {0}; // Vector of pointers to receive buffers for input streams
char* tag = reinterpret_cast<char*>(buffer);

vector<int> output_fds; // Vector of file descriptors for audio input streams

int listen_fd = 0; // fd for audio input

int data_fd = 0; // fd for writing IPs to

vector<string> known_ip_procs = {};

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      &listen_fd,
                      &data_fd};

int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

struct sockaddr_in receive_addr;

socklen_t receive_addr_len = sizeof(receive_addr);

void log(const string &message, bool endl = true, bool tag = true) {
    printf("%s %s%s", tag?"[Scream Per-Port Listener]":"", message.c_str(), endl?"\n":"");
}

// Function to process fixed command line arguments like IP address and output port
void process_args(int argc, char** argv) {
    if (argc <= config_argc)
        ::exit(-1);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
void process_fd_args(int argc, char* argv[]) {
    for (int argi = config_argc; argi < argc; argi++) {
        output_fds.push_back(atoi(argv[argi]));
    }
}

bool receive() {
    int bytes = recvfrom(listen_fd, buffer + IP_LENGTH, PACKET_SIZE, 0, (struct sockaddr *) &receive_addr, &receive_addr_len);
    //printf("Packet in Bytes: %i Process: %s\n", bytes, buffer);
    if (bytes == -1) 
        ::exit(-1);
    if (bytes != PACKET_SIZE)
        return false;
    return true;
}

void set_tag() {
    //Format for buffer is
    //XXX.XXX.XXX.XXXTAGTAGTAGTAGTAGTAGTAGTAGTAGTA\0DATADATA...
    //If the IP does not fill the full size empty space is filled with spaces.
    //The buffer has the TAG and data in it already and just needs the IP written
    memset(tag, ' ', IP_LENGTH); // Clear with space
    strcpy(tag, inet_ntoa(receive_addr.sin_addr)); // Write IP to start
    tag[strlen(tag)] = ' '; // Clear null terminator
    tag[IP_LENGTH + PROGRAM_TAG_LENGTH - 1] = 0; // Ensure it's got a null terminator at the end of the tag
}

void check_if_known() {
   bool already_known = false;
    for (int idx=0;idx<known_ip_procs.size();idx++) {
        if (known_ip_procs.at(idx) == tag) {
            already_known = true;
            break;
        }
    }
    if (!already_known) {
        dprintf(data_fd, "%s\n", tag);
        known_ip_procs.push_back(tag);
    } 
}


void send() {

    // Use select to check if sockets are ready for writing
    fd_set write_fds;
    struct timeval timeout;
    
    // Set timeout to 0 seconds, 100 microseconds (non-blocking)
    timeout.tv_sec = 0;
    timeout.tv_usec = 100;
    
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++) {
        // Initialize the file descriptor set
        FD_ZERO(&write_fds);
        FD_SET(output_fds[fd_idx], &write_fds);
        
        // Check if this socket is ready for writing
        int select_result = select(output_fds[fd_idx] + 1, NULL, &write_fds, NULL, &timeout);
        
        // Write only if select indicates the socket is ready
        if (select_result > 0 && FD_ISSET(output_fds[fd_idx], &write_fds)) {
            write(output_fds[fd_idx], buffer, PACKET_SIZE + IP_LENGTH);
        }
    }
}

int main(int argc, char* argv[]) {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1", true, true);
    } else {
        log("Successfully pinned to CPU core 1", true, true);
    }

    log("Start");
    process_args(argc, argv);

    process_fd_args(argc, argv);
    log("Input FDs: ", false, true);
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]) + " ", false, false);
    log("", true, false);

    while (running)
        if (receive())
        {
            set_tag();
            check_if_known();
            send();
        } else {
            sleep(.01);
        }
    return 0;
}
scream_receiver.cpp0000644000000000000000000000737215000443353013424 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <lame/lame.h>
#include <algorithm>
#include <string>
#include <pthread.h>
#include <sched.h>
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio stream
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE) // Total packet size including header and chunk
#define TAG_LENGTH 45

bool running = true; // Flag to control loop execution

uint8_t buffer[TAG_LENGTH + PACKET_SIZE] = {0}; // Vector of pointers to receive buffers for input streams

vector<int> output_fds; // Vector of file descriptors for audio input streams

int listen_fd = 0; // fd for audio input

int data_fd = 0; // fd for writing IPs to

vector<string> known_ip_procs = {};

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      &listen_fd,
                      &data_fd};

int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

struct sockaddr_in receive_addr;

socklen_t receive_addr_len = sizeof(receive_addr);

void log(const string &message, bool endl = true, bool tag = true) {
    printf("%s %s%s", tag?"[RTP Listener]":"", message.c_str(), endl?"\n":"");
}

// Function to process fixed command line arguments like IP address and output port
void process_args(int argc, char** argv) {
    if (argc <= config_argc)
        ::exit(-1);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
void process_fd_args(int argc, char* argv[]) {
    for (int argi = config_argc; argi < argc; argi++) {
        output_fds.push_back(atoi(argv[argi]));
    }
}

bool receive() {
    int bytes = recvfrom(listen_fd, buffer + TAG_LENGTH, PACKET_SIZE, 0, (struct sockaddr *) &receive_addr, &receive_addr_len);
    if (bytes == -1) 
        ::exit(-1);
    if (bytes != PACKET_SIZE)
        return false;
    return true;
}

void send() {
    memset(buffer, 0, TAG_LENGTH);
    strcpy(reinterpret_cast<char*>(buffer), inet_ntoa(receive_addr.sin_addr));
    string ip_address = string(reinterpret_cast<char*>(buffer));
    if (find(known_ip_procs.begin(), known_ip_procs.end(), ip_address) == known_ip_procs.end()) {
        known_ip_procs.push_back(ip_address);
        write(data_fd, (ip_address + "\n").c_str(), ip_address.length());
    }
    for (int fd_idx=0;fd_idx<output_fds.size();fd_idx++)
        write(output_fds[fd_idx], buffer, PACKET_SIZE + TAG_LENGTH);
}

int main(int argc, char* argv[]) {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1", true, true);
    } else {
        log("Successfully pinned to CPU core 1", true, true);
    }

    process_args(argc, argv);

    process_fd_args(argc, argv);
    log("Input FDs: ", false, true);
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]) + " ", false, false);
    log("", true, false);

    while (running)
        if (receive())
            send();
        else
            sleep(.2);
    return 0;
}
sink_audio_mixer.cpp0000644000000000000000000005131615006141757013625 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <lame/lame.h>
#ifdef __SSE2__
#include <emmintrin.h>
#endif
#include <immintrin.h>
#include <pthread.h>
#include <sched.h>
#include "audio_processor.h"
#include "dcaenc/dcaenc.h"
#include <sys/time.h>

AudioProcessor *lameProcessor = NULL;
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio stream
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE) // Total packet size including header and chunk

bool running = true; // Flag to control loop execution

// Buffer system overview:
// 1. receive_buffers: Array of input buffers, one per audio source. Each buffer stores CHUNK_SIZE bytes of 32-bit audio samples
// 2. mixing_buffer: Single buffer where all active input streams are mixed together
// 3. output_buffer: Double-buffered output storage (2x PACKET_SIZE) allowing continuous streaming
// 4. mp3_buffer: Temporary storage for MP3 encoded data before sending

vector<int32_t*> receive_buffers; // Vector of input buffers, one per audio source
int32_t* mixing_buffer = new int32_t[CHUNK_SIZE / sizeof(int32_t)]; // Target buffer for mixed audio data
uint8_t *mixing_buffer_uint8 = (uint8_t*)mixing_buffer; // Byte-level access to mixing buffer for downsampling
char output_buffer[PACKET_SIZE * 2] = {0}; // Double-buffered output (2x PACKET_SIZE) for continuous streaming
int output_buffer_pos = 0; // Current write position in output_buffer
uint8_t mp3_buffer[CHUNK_SIZE * 8]; // Temporary storage for MP3 encoded data
int mp3_buffer_pos = 0; // Current position in MP3 buffer

lame_t lame = lame_init();

struct sockaddr_in udp_dest_addr = {}; // Socket address structure for UDP socket destination
int udp_output_fd = 0; // File descriptor for the UDP socket

struct timeval receive_timeout;
fd_set read_fds;

int tcp_output_fd = 0; // File descriptor for the TCP socket
int mp3_write_fd = 0; // File descriptor to write mp3 to
vector<int> output_fds; // Vector of file descriptors for audio input streams
bool active[1024] = {0}; // Vector to store whether each input stream is active or not
bool output_active = false; // Flag to indicate if there's any data to be sent over the network
string output_ip = ""; // IP address of the UDP socket destination
int output_port = 0; // Port number of the UDP socket destination
int output_bitdepth = 0; // Bit depth of the output audio stream
int output_samplerate = 0; // Sample rate of the output audio stream
int output_channels = 0; // Number of channels in the output audio stream
int output_chlayout1 = 0; // Channel layout part 1 for the output audio stream
int output_chlayout2 = 0; // Channel layout part 2 for the output audio stream
int use_dts = 0; // Is it outputting DTS?
dcaenc_context_s *dca_context; // DTS encoding context

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      NULL, // output_ip (string)
                      &output_port,
                      &output_bitdepth,
                      &output_samplerate,
                      &output_channels,
                      &output_chlayout1,
                      &output_chlayout2,
                      &tcp_output_fd,
                      &mp3_write_fd};
int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

inline void log(const string &message) {
    printf("[Sink Output Processor %s:%i] %s\n", output_ip.c_str(), output_port, message.c_str());
}

// Function to process fixed command line arguments like IP address and output port
inline void process_args(char* argv[], int argc) {
    if (argc <= config_argc)
        ::exit(-1);
    // cppcheck-suppress ctuArrayIndex
    output_ip = string(argv[1]);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
inline void process_fd_args(char* argv[], int argc) {
    for (int argi = config_argc; argi < argc; argi++)
        output_fds.push_back(atoi(argv[argi]));
}

inline void setup_header() { // Sets up the Scream header
    bool output_samplerate_44100_base = (output_samplerate % 44100) == 0;
    uint8_t output_samplerate_mult = (output_samplerate_44100_base?44100:48000) / output_samplerate;
    output_buffer[0] = output_samplerate_mult + (output_samplerate_44100_base << 7);
    output_buffer[1] = output_bitdepth;
    output_buffer[2] = output_channels;
    output_buffer[3] = output_chlayout1;
    output_buffer[4] = output_chlayout2;
    log("Set up Header, Rate: " + to_string(output_samplerate) + ", Bit-Depth" + to_string(output_bitdepth) + ", Channels" + to_string(output_channels));
}

inline void setup_udp() { // Sets up the UDP socket for output
    log("UDP Set Up");
    udp_output_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    udp_dest_addr.sin_family = AF_INET;
    udp_dest_addr.sin_port = htons(output_port);
    inet_pton(AF_INET, output_ip.c_str(), &udp_dest_addr.sin_addr);
    int dscp = 63;
    int val = dscp << 2;
    setsockopt(udp_output_fd, IPPROTO_IP, IP_TOS, &val, sizeof(val));
    if (tcp_output_fd > 0) {
        setsockopt(tcp_output_fd, IPPROTO_IP, IP_TOS, &val, sizeof(val));
        fd_set fd;
        timeval tv;
        FD_ZERO(&fd);
        FD_SET(tcp_output_fd, &fd);
        tv.tv_sec = 15;
        tv.tv_usec = 0;
        u_long yes = 1;
        fcntl(tcp_output_fd, F_SETFL, fcntl(tcp_output_fd, F_GETFL, 0) | O_NONBLOCK);
        fcntl(tcp_output_fd, F_SETFL, fcntl(tcp_output_fd, F_GETFL, 0) | O_NDELAY);
        setsockopt(tcp_output_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        int newsize = 1152 * 16;
        setsockopt(tcp_output_fd, SOL_SOCKET, SO_SNDBUF, &newsize, sizeof(newsize));
        newsize = 1152 * 8;
        setsockopt(mp3_write_fd, SOL_SOCKET, SO_SNDBUF, &newsize, sizeof(newsize));
        bool trew = true;
        setsockopt(mp3_write_fd, SOL_SOCKET, SOCK_NONBLOCK, &trew, sizeof(trew));
        int flags = fcntl(mp3_write_fd, F_GETFL, 0);
        fcntl(mp3_write_fd, F_SETFL, flags | O_NONBLOCK);
        setsockopt (tcp_output_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        log("TCP Set Up");
    }
}

inline void setup_buffers() { // Sets up buffers to receive data from input fds
    log("Buffers Set Up");
    setbuf(stdout, NULL);
    for (int buf_idx = 0; buf_idx < output_fds.size(); buf_idx++)
        receive_buffers.push_back(static_cast<int32_t*>(malloc(CHUNK_SIZE)));
}

inline void setup_lame() {
    lame_set_in_samplerate(lame, output_samplerate);
    lame_set_VBR(lame, vbr_off);
    lame_init_params(lame);
}

bool lame_active = true;
struct timeval lame_timeout;
fd_set lame_fd;

inline void write_lame() {
    FD_ZERO(&lame_fd);
    FD_SET(mp3_write_fd, &lame_fd);
    lame_timeout.tv_sec = 0;
    lame_timeout.tv_usec = 0;
    int result = select(mp3_write_fd + 1, NULL, &lame_fd, NULL, &lame_timeout);
    // ScreamRouter will stop reading from the MP3 FD if there's no clients. Don't encode if there's no reader.
    if (result > 0 && FD_ISSET(mp3_write_fd, &lame_fd)) {
        if (!lame_active) {
            lame_active = true;
            log("MP3 Stream Active");
        }
        int32_t processed_buffer[CHUNK_SIZE / sizeof(uint32_t)];
        int processed_samples = lameProcessor->processAudio(reinterpret_cast<const uint8_t*>(mixing_buffer), processed_buffer);

        mp3_buffer_pos = lame_encode_buffer_interleaved_int(lame, processed_buffer, processed_samples / 2, mp3_buffer, CHUNK_SIZE * 8);
        
        if (mp3_buffer_pos > 0)
            write(mp3_write_fd, mp3_buffer, mp3_buffer_pos);
    }
    else {
        if (lame_active) {
            lame_active = false;
            log("MP3 Stream Inactive");
        }
    }
}

// Synchronization mechanism for multiple input streams:
// 1. Checks which input streams have data ready using non-blocking select()
// 2. Waits up to 15ms for lagging streams to catch up
// 3. Marks streams as inactive if they consistently lag behind
// 4. Detects when inactive streams become active again
inline void mark_fds_active_inactive() {
    fd_set check_fds;
    fd_set active_fds;
    FD_ZERO(&check_fds);
    FD_ZERO(&active_fds);
    int max_fd = 0;
    int total_active = 0;
    
    // Find the max fd and set up active_fds
    for (int idx = 0; idx < output_fds.size(); idx++) {
        if (active[idx]) {
            FD_SET(output_fds[idx], &active_fds);
            if (output_fds[idx] > max_fd) {
                max_fd = output_fds[idx];
            }
            total_active++;
        }
    }
    
    // Run a select against all active FDs with zero timeout
    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    fd_set ready_fds = active_fds;
    int result = select(max_fd + 1, &ready_fds, NULL, NULL, &tv);
    
    // If all active FDs have data, we're done with this part
    if (result == total_active) {
        // All active FDs have data, nothing to check
    } else {
        // Store all active FDs that do not have data pending in check_fds
        for (int idx = 0; idx < output_fds.size(); idx++) {
            if (active[idx] && !FD_ISSET(output_fds[idx], &ready_fds)) {
                FD_SET(output_fds[idx], &check_fds);
            }
        }
        
        // If there are FDs in check_fds, poll every 1ms for up to 20ms
        if (result < total_active) {
            struct timeval start_time, current_time;
            gettimeofday(&start_time, NULL);
            long elapsed_usec = 0;
            bool all_good = false;
            while (elapsed_usec <= 15000) {
                // Check if 30ms have elapsed for timeout
                gettimeofday(&current_time, NULL);
                elapsed_usec = (current_time.tv_sec - start_time.tv_sec) * 1000000 + 
                                   (current_time.tv_usec - start_time.tv_usec);
                
                // Poll with 1ms timeout
                fd_set temp_check_fds = check_fds;
                tv.tv_sec = 0;
                tv.tv_usec = 1000; // 1ms
                result = select(max_fd + 1, &temp_check_fds, NULL, NULL, &tv);
                
                if (result <= 0) {
                    continue; // No FDs ready or error
                }
                
                // Remove FDs that now have data from check_fds
                for (int idx = 0; idx < output_fds.size(); idx++) {
                    if (active[idx] && FD_ISSET(output_fds[idx], &temp_check_fds)) {
                        FD_CLR(output_fds[idx], &check_fds);
                    }
                }
                
                // If all FDs now have data, we can stop polling
                if (FD_ISSET(0, &check_fds) == 0) {
                    all_good = true;
                    break;
                }
            }
            if (!all_good) {
                // After 20ms, mark any remaining FDs in check_fds as false in active[]
                for (int idx = 0; idx < output_fds.size(); idx++) {
                    if (active[idx] && FD_ISSET(output_fds[idx], &check_fds)) {
                        active[idx] = false;
                        log("Input " + std::to_string(idx) + " inactive");
                    }
                }
            }
        }
    }
    
    // Run a zero-ms select on all inactive FDs
    FD_ZERO(&check_fds);
    max_fd = 0;
    
    for (int idx = 0; idx < output_fds.size(); idx++) {
        if (!active[idx]) {
            FD_SET(output_fds[idx], &check_fds);
            if (output_fds[idx] > max_fd) {
                max_fd = output_fds[idx];
            }
        }
    }
    
    if (max_fd > 0) {
        tv.tv_sec = 0;
        tv.tv_usec = 0;
        fd_set temp_check_fds = check_fds;
        result = select(max_fd + 1, &temp_check_fds, NULL, NULL, &tv);
        
        // If any inactive FDs are now active, set them to true in active[]
        if (result > 0) {
            for (int idx = 0; idx < output_fds.size(); idx++) {
                if (!active[idx] && FD_ISSET(output_fds[idx], &temp_check_fds)) {
                    active[idx] = true;
                    log("Input " + std::to_string(idx) + " active");
                    total_active++;
                }
            }
        }
    }
}

// Buffer reading mechanism:
// 1. Uses mark_fds_active_inactive() to determine which inputs are ready
// 2. For each active input:
//    - Uses non-blocking select() to check for available data
//    - Reads data in chunks until CHUNK_SIZE bytes are collected
//    - Handles partial reads and temporary unavailability
// 3. Sets output_active flag when data is successfully read
inline bool handle_receive_buffers() {
    output_active = false;
    mark_fds_active_inactive();
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++) {
        if (active[fd_idx]) {
            fd_set read_set;
            struct timeval timeout;
            timeout.tv_sec = 0;
            timeout.tv_usec = 15000;
            
            for (int bytes_in = 0; running && bytes_in < CHUNK_SIZE;) {
                FD_ZERO(&read_set);
                FD_SET(output_fds[fd_idx], &read_set);
                
                int ready = select(output_fds[fd_idx] + 1, &read_set, NULL, NULL, &timeout);
                if (ready < 1) {
                    break;
                }
                
                if (FD_ISSET(output_fds[fd_idx], &read_set)) {
                    int bytes_read = read(output_fds[fd_idx], 
                                        receive_buffers[fd_idx] + bytes_in, 
                                        CHUNK_SIZE - bytes_in);
                    if (bytes_read <= 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) continue;
                        log("Read error: " + string(strerror(errno)));
                        return false;
                    }
                    bytes_in += bytes_read;
                }
            }
            output_active = true;
        }
    }
    return output_active;
}

// Audio mixing process:
// 1. Uses SIMD instructions when available (AVX2 or SSE2) for efficient mixing
// 2. Adds samples from all active input streams into mixing_buffer
// 3. Includes overflow protection in non-SIMD path
// 4. Processing happens in 32-bit integer format for maximum dynamic range
void mix_buffers() {
#if defined(__AVX2__)
    for (int buf_pos = 0; buf_pos < CHUNK_SIZE / sizeof(int32_t); buf_pos += 8) {
        __m256i mixing = _mm256_setzero_si256();
        for (int input_buf_idx = 0; input_buf_idx < receive_buffers.size(); input_buf_idx++) {
            if (!active[input_buf_idx])
                continue;
            __m256i receive = _mm256_loadu_si256((__m256i*)&receive_buffers[input_buf_idx][buf_pos]);
            mixing = _mm256_add_epi32(mixing, receive);
        }
        _mm256_storeu_si256((__m256i*)&mixing_buffer[buf_pos], mixing);
    }
#elif defined(__SSE2__)
    for (int buf_pos = 0; buf_pos < CHUNK_SIZE / sizeof(int32_t); buf_pos += 4) {
        __m128i mixing = _mm_setzero_si128();
        for (int input_buf_idx = 0; input_buf_idx < receive_buffers.size(); input_buf_idx++) {
            if (!active[input_buf_idx])
                continue;
            __m128i receive = _mm_load_si128((__m128i*)&receive_buffers[input_buf_idx][buf_pos]);
            mixing = _mm_add_epi32(mixing, receive);
        }
        _mm_store_si128((__m128i*)&mixing_buffer[buf_pos], mixing);
    }
#else
    for (int buf_pos = 0; buf_pos < CHUNK_SIZE / sizeof(int32_t); buf_pos++) {
        mixing_buffer[buf_pos] = 0;
        for (int input_buf_idx = 0; input_buf_idx < receive_buffers.size(); input_buf_idx++) {
            if (!active[input_buf_idx])
                continue;
            mixing_buffer[buf_pos] += receive_buffers[input_buf_idx][buf_pos];
        }
        if (mixing_buffer[buf_pos] > INT32_MAX) {
            mixing_buffer[buf_pos] = INT32_MAX;
        } else if (mixing_buffer[buf_pos] < INT32_MIN) {
            mixing_buffer[buf_pos] = INT32_MIN;
        }
    }
#endif
}

// Buffer format conversion:
// 1. Converts 32-bit mixed samples to target bit depth (e.g., 16-bit or 24-bit)
// 2. Writes converted data to output_buffer after header
// 3. Maintains proper byte alignment for different output formats
inline void downscale_buffer() {
    int output_bytedepth = output_bitdepth / 8;
    for (int input_pos = 0;input_pos < CHUNK_SIZE; input_pos++) {
        if (output_buffer_pos % output_bytedepth == 0)
            input_pos += sizeof(uint32_t) - output_bytedepth;
        output_buffer[HEADER_SIZE + output_buffer_pos++] = mixing_buffer_uint8[input_pos];
    }
}

inline void send_buffer() { // Sends a buffer over TCP or UDP depending on which is active
    if (tcp_output_fd) {
        int result = send(tcp_output_fd, output_buffer + HEADER_SIZE, CHUNK_SIZE, 0);
        if (result <= 0) {
            if (errno != EAGAIN) { // Resource Temporary Unavailable (buffer full)
                log("Got TCP error: " + to_string(errno) + ")");
                //close(tcp_output_fd);
                tcp_output_fd = 0;
            }
        }
    } else
        sendto(udp_output_fd, output_buffer, PACKET_SIZE, 0, (struct sockaddr *)&udp_dest_addr, sizeof(udp_dest_addr));
}

// Double buffer management:
// 1. Implements a sliding window over output_buffer
// 2. Moves last CHUNK_SIZE bytes to start of buffer when needed
// 3. Ensures continuous streaming without gaps between packets
inline void rotate_buffer() {
    if (output_buffer_pos >= CHUNK_SIZE) {
        memcpy(output_buffer + HEADER_SIZE, output_buffer + PACKET_SIZE, CHUNK_SIZE);
        output_buffer_pos -= CHUNK_SIZE;
    }
}

inline void dts_encode() {
    if (use_dts == 1) {

    }
}

#include <exception>
#include <stdexcept>
#include <cxxabi.h>
#include <execinfo.h>

void print_stacktrace(int skip = 1) {
    void *callstack[128];
    int frames = backtrace(callstack, 128);
    char **strs = backtrace_symbols(callstack, frames);
    
    for (int i = skip; i < frames; ++i) {
        int status;
        char *demangled = abi::__cxa_demangle(strs[i], NULL, 0, &status);
        if (status == 0) {
            std::cerr << demangled << std::endl;
            free(demangled);
        } else {
            std::cerr << strs[i] << std::endl;
        }
    }
    free(strs);
}

int main(int argc, char* argv[]) {
    try {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1");
    } else {
        log("Successfully pinned to CPU core 1");
    }

    process_args(argv, argc);
    if (use_dts == 1)
    {
        if (output_channels != 6) {
            log("DTS requires 6 channels (5.1), but only " + to_string(output_channels) + " were specified. Exiting.");
            exit(1);
        }
        if (output_samplerate != 44100 && output_samplerate != 48000) {
            log("DTS requires 44.1kHz or 48kHz but  " + to_string(output_channels) + " was specified. Exiting.");
            exit(1);
        }
        dca_context = dcaenc_create(
                        output_samplerate,
                        DCAENC_CHANNELS_3FRONT_2REAR,
                        1509000, // DVD bitrate
                        DCAENC_FLAG_IEC_WRAP | DCAENC_FLAG_LFE | DCAENC_FLAG_28BIT | DCAENC_FLAG_PERFECT_QMF);
    }
    lameProcessor = new AudioProcessor(output_channels, 2, 32, output_samplerate, output_samplerate, 1);
    log("Starting Ouput Mixer, sending UDP to " + output_ip +  ":" + to_string(output_port) + ", TCP Enabled: " + (tcp_output_fd > 0?"Yes":"No"));
    process_fd_args(argv, argc);
    log("Input FDs: ");
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]));
    setup_header();
    setup_lame();
    setup_udp();
    setup_buffers();

    while (running) {
        if (!handle_receive_buffers()) {
            sleep(.5);
            continue;
        }
        mix_buffers();
        write_lame();
        downscale_buffer();
        if (output_buffer_pos < CHUNK_SIZE)
          continue;
        send_buffer();
        rotate_buffer();
    }
    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
        std::cerr << "Stack trace:" << std::endl;
        print_stacktrace();
    } catch (...) {
        std::cerr << "Caught unknown exception" << std::endl;
        std::cerr << "Stack trace:" << std::endl;
        print_stacktrace();
}
    return 0;
}
source_input_processor.cpp0000644000000000000000000003766415006161511015112 0ustar  rootroot#include <iostream>
#include <vector>
#include <string>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <deque>
#include <chrono>
#include <thread>
#include <atomic>
#include <sstream>
#include <climits>
#include <mutex>
#include <condition_variable>
#include <cstring>
#include <pthread.h>
#include <sched.h>
#include "audio_processor.h"

using namespace std;

#define CHUNK_SIZE 1152
#define HEADER_SIZE 5
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE)
#define TAG_SIZE 45

uint8_t packet_in_buffer[PACKET_SIZE + TAG_SIZE];
uint8_t receive_buffer[CHUNK_SIZE];
int32_t processed_buffer[CHUNK_SIZE * 8];
uint8_t *processed_buffer_int8 = (uint8_t *)processed_buffer;

int process_buffer_pos = 0;

string input_ip = "";
int fd_in = 0, fd_out = 0, data_fd_in = 0;
int output_channels = 0, output_samplerate = 0, output_chlayout1 = 0, output_chlayout2 = 0;
int delay = 0, timeshift_buffer_dur = 0;
float volume = 1;
std::chrono::steady_clock::time_pointtimeshift_last_change;
unsigned long timeshift_buffer_pos = 0;
float timeshift_backshift = 0;
std::mutex timeshift_mutex;
std::condition_variable timeshift_condition;

const auto TIMESHIFT_NOREMOVE_TIME = std::chrono::minutes(5);

std::deque<std::pair<std::chrono::steady_clock::time_point, std::vector<uint8_t>>> timeshift_buffer;
std::atomic<bool> threads_running(true);

uint8_t input_header[HEADER_SIZE] = {0};
int input_channels = 0, input_samplerate = 0, input_bitdepth = 0, input_chlayout1 = 0, input_chlayout2 = 0;

unique_ptr<AudioProcessor> audioProcessor = NULL;
std::mutex audioProcessor_mutex;

float new_eq[EQ_BANDS] = {1};

int *int_args[] = {
    NULL, &fd_in, &fd_out, &data_fd_in, &output_channels, &output_samplerate, &output_chlayout1, &output_chlayout2,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    &delay, &timeshift_buffer_dur,
};

float *float_args[] = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    &volume,
    &new_eq[0], &new_eq[1], &new_eq[2], &new_eq[3], &new_eq[4], &new_eq[5], &new_eq[6], &new_eq[7], &new_eq[8], &new_eq[9],
    &new_eq[10],&new_eq[11],&new_eq[12],&new_eq[13],&new_eq[14],&new_eq[15],&new_eq[16],&new_eq[17],
    NULL, NULL,
};

int config_argc = sizeof(int_args) / sizeof(int *);

void log(const string& message) {
    cerr << "[Source Input Processor " << getpid() << "] " << message << endl;
}

void process_args(int argc, char *argv[]) {
    if (argc <= config_argc) {
        log("Too few args");
        threads_running = false;
        return; // Return early to prevent accessing out-of-bounds array elements
    }
    input_ip = string(argv[1]);
    for (int argi = 0; argi < config_argc; argi++)
        if (int_args[argi] != NULL)
            *(int_args[argi]) = atoi(argv[argi + 1]);
    for (int argi = 0; argi < config_argc; argi++)
        if (float_args[argi] != NULL)
            *(float_args[argi]) = atof(argv[argi + 1]);
}

// This function checks if the incoming packet header has changed and updates the input parameters accordingly.
void check_update_header() {
    // Compare the current header with the new one received in the packet buffer.
    if (memcmp(input_header, packet_in_buffer + TAG_SIZE, HEADER_SIZE) != 0) {
        log("Got new header");
        // Update the input header with the new data.
        memcpy(input_header, packet_in_buffer + TAG_SIZE, HEADER_SIZE);
        
        // Extract sample rate from the header and convert it to integer format.
        input_samplerate = (input_header[0] & 0x7F) * ((input_header[0] & 0x80) ? 44100 : 48000);
        
        // Extract bit depth from the header and convert it to integer format.
        input_bitdepth = input_header[1];
        
        // Extract number of channels from the header and convert it to integer format.
        input_channels = input_header[2];
        
        // Extract channel layout from the header and convert it to integer format.
        input_chlayout1 = input_header[3];
        input_chlayout2 = input_header[4];
        
        log("Sample Rate: " + to_string(input_samplerate) + " -> " + to_string(output_samplerate));
        log("Bit Depth: " + to_string(input_bitdepth) + " -> 32");
        log("Channels: " + to_string(input_channels) + " -> " + to_string(output_channels));
        
        // Lock the audio processor mutex before updating the audio processor settings.
        audioProcessor_mutex.lock();
        // Create a new AudioProcessor instance with updated parameters.
        audioProcessor = make_unique<AudioProcessor>(input_channels, output_channels, input_bitdepth, input_samplerate, output_samplerate, volume);
        audioProcessor->setEqualizer(new_eq);
        // Unlock the audio processor mutex after updating the settings.
        audioProcessor_mutex.unlock();
    }
}

void receive_data_thread() {
    fd_set read_fds;
    struct timeval timeout;
    
    while (threads_running) {
        // Set up select with 5ms timeout
        FD_ZERO(&read_fds);
        FD_SET(fd_in, &read_fds);
        timeout.tv_sec = 0;
        timeout.tv_usec = 5000; // 5ms timeout
        
        // Wait for data with timeout
        int select_result = select(fd_in + 1, &read_fds, NULL, NULL, &timeout);
        
        // If select failed or timed out, continue the loop
        if (select_result <= 0) {
            continue;
        }
        
        // Check if our fd is ready for reading
        if (!FD_ISSET(fd_in, &read_fds)) {
            continue;
        }
        
        int bytes;
        while ((bytes = read(fd_in, packet_in_buffer, TAG_SIZE + PACKET_SIZE)) != TAG_SIZE + PACKET_SIZE ||
                (strcmp(input_ip.c_str(), reinterpret_cast<const char*>(packet_in_buffer)) != 0)) {
                    if (bytes == -1)
                        threads_running = false;
            }
        check_update_header();
        auto received_time = std::chrono::steady_clock::now();
        std::vector<uint8_t> new_packet(CHUNK_SIZE);
        memcpy(new_packet.data(), packet_in_buffer + TAG_SIZE + HEADER_SIZE, CHUNK_SIZE);
        
        // Critical section - add data to buffer
        {
            std::lock_guard<std::mutex> lock(timeshift_mutex);
            timeshift_buffer.emplace_back(received_time, std::move(new_packet));
            // Notify while holding the lock - this is actually the recommended pattern for condition variables
            timeshift_condition.notify_one(); // Notify waiting threads that new data is available
        }
    }
}

bool data_ready() {
    // Check if we have data and haven't reached the end
    if (timeshift_buffer.empty() || timeshift_buffer.size() <= timeshift_buffer_pos) {
        return false;
    }

    // Get current packet's scheduled play time
    auto current_time = timeshift_buffer.at(timeshift_buffer_pos).first + 
                       std::chrono::milliseconds(delay) + 
                       std::chrono::milliseconds((int)(timeshift_backshift*1000));

    // If we're at the last packet, don't allow playback
    if (timeshift_buffer_pos == timeshift_buffer.size() - 1) {
        return false;
    }

    // Otherwise check if it's time to play this packet
    return current_time <= std::chrono::steady_clock::now();
}

bool receive_data() {
    try {
        std::unique_lock<std::mutex> process_lock(timeshift_mutex);
        
        // If no data is ready, wait for notification with a timeout
        if (!data_ready()) {
            timeshift_condition.wait_for(process_lock, std::chrono::seconds(1), [&]() -> bool {
                return data_ready();
            });
        }

        if (!data_ready())
            return false;
        
        // Copy the data while holding the lock
        memcpy(receive_buffer, timeshift_buffer.at(timeshift_buffer_pos++).second.data(), CHUNK_SIZE);

        // Check if we need to clean up old data
        if (!timeshift_buffer.empty() && 
            timeshift_buffer.front().first + std::chrono::milliseconds(delay) + 
            std::chrono::milliseconds((int)(timeshift_backshift*1000)) + 
            std::chrono::seconds(timeshift_buffer_dur) < std::chrono::steady_clock::now()) {
            
            if (timeshift_last_change + TIMESHIFT_NOREMOVE_TIME < std::chrono::steady_clock::now()) {
                timeshift_buffer.pop_front();
                timeshift_buffer_pos--;
            }
        }
        
        return true;
        
    } catch (std::out_of_range) {
        log("Out of range 1");
        return false;
    }
}

void change_timeshift() {
    if (timeshift_buffer.size() == 0) {
        timeshift_buffer_pos = 0;
        timeshift_backshift = 0;
    } else {
        timeshift_mutex.lock();
        auto desired_time = std::chrono::steady_clock::now() - 
                            std::chrono::milliseconds((int)(timeshift_backshift*1000)) - 
                            std::chrono::milliseconds(delay);
        long closest_buffer_delta = LONG_MAX;
        
        for (long i=0; i<timeshift_buffer.size(); i++) {
            std::chrono::steady_clock::duration cur_delta = timeshift_buffer.at(i).first - desired_time;
            long cur_delta_num = abs(std::chrono::duration_cast<std::chrono::milliseconds>(cur_delta).count());
            if (cur_delta_num < closest_buffer_delta) {
                closest_buffer_delta = cur_delta_num;
                timeshift_buffer_pos = i;
            }
        }
        
        timeshift_backshift = std::chrono::duration_cast<std::chrono::duration<float>>(
            std::chrono::steady_clock::now() - timeshift_buffer.at(timeshift_buffer_pos).first + 
            std::chrono::milliseconds(delay)
        ).count();
        timeshift_mutex.unlock();
    }
}

void data_input_thread() {
    char line[256];
    fd_set read_fds;
    struct timeval timeout;

    while (threads_running) {
        // Set up select with 5ms timeout
        FD_ZERO(&read_fds);
        FD_SET(data_fd_in, &read_fds);
        timeout.tv_sec = 0;
        timeout.tv_usec = 5000; // 5ms timeout
        
        // Wait for data with timeout
        int select_result = select(data_fd_in + 1, &read_fds, NULL, NULL, &timeout);
        
        // If select failed or timed out, continue the loop
        if (select_result <= 0) {
            continue;
        }
        
        // Check if our fd is ready for reading
        if (!FD_ISSET(data_fd_in, &read_fds)) {
            continue;
        }
        
        if (read(data_fd_in, line, sizeof(line)) > 0) {
            std::string input(line);
            std::istringstream iss(input);
            std::string command;

            while (std::getline(iss, command)) {
                std::istringstream command_stream(command);
                std::string variable;
                float value;

                if (command_stream >> variable >> value) {
                    if (variable[0] == 'b' && variable.length() > 1 && std::isdigit(variable[1])) {
                        int index = std::stoi(variable.substr(1)) - 1;
                        if (index >= 0 && index < EQ_BANDS) {
                            new_eq[index] = value;
                        }
                    } else if (variable == "v") {
                        if (!audioProcessor)
                            continue;
                        volume = value;
                        audioProcessor_mutex.lock();
                        audioProcessor->setVolume(volume);
                        audioProcessor_mutex.unlock();
                    } else if (variable == "t") {
                        timeshift_backshift = value;
                        change_timeshift();
                    } else if (variable == "d") {
                        delay = (int)value;
                        change_timeshift();
                    }
                } else if (command == "a") {
                    if (!audioProcessor)
                        continue;
                    audioProcessor_mutex.lock();
                    audioProcessor->setEqualizer(new_eq);
                    audioProcessor_mutex.unlock();
                }
            }
        }
        
        // No need for sleep here as select already provides the timeout
    }
}

void write_output_buffer() {
    write(fd_out, processed_buffer_int8, CHUNK_SIZE);
    for (int pos = 0; pos < sizeof(processed_buffer) - CHUNK_SIZE; pos++)
        processed_buffer_int8[pos] = processed_buffer_int8[pos + CHUNK_SIZE];
    process_buffer_pos -= CHUNK_SIZE / sizeof(int32_t);
}

#include <exception>
#include <stdexcept>
#include <cxxabi.h>
#include <execinfo.h>

void print_stacktrace() {
    const int MAX_STACK_FRAMES = 100;
    void* stack_traces[MAX_STACK_FRAMES];
    int trace_size = backtrace(stack_traces, MAX_STACK_FRAMES);
    char** stack_strings = backtrace_symbols(stack_traces, trace_size);

    std::cerr << "Stack trace:" << std::endl;
    for (int i = 0; i < trace_size; ++i) {
        std::string stack_string(stack_strings[i]);
        size_t pos = stack_string.find('(');
        size_t pos2 = stack_string.find('+', pos);
        if (pos != std::string::npos && pos2 != std::string::npos) {
            std::string mangled_name = stack_string.substr(pos + 1, pos2 - pos - 1);
            int status;
            char* demangled_name = abi::__cxa_demangle(mangled_name.c_str(), nullptr, nullptr, &status);
            if (status == 0) {
                std::cerr << "  " << i << ": " << demangled_name << std::endl;
                free(demangled_name);
            } else {
                std::cerr << "  " << i << ": " << stack_strings[i] << std::endl;
            }
        } else {
            std::cerr << "  " << i << ": " << stack_strings[i] << std::endl;
        }
    }
    free(stack_strings);
}

void monitor_buffer_levels() {
        while (threads_running) {
        
        // Check process buffer
        size_t process_buffer_size = process_buffer_pos * sizeof(int32_t);
        
        // Calculate percentages
        double process_buffer_percentage = (double)process_buffer_size / (CHUNK_SIZE * 8) * 100;
        
        // Log if any buffer exceeds thresholds
        if (process_buffer_percentage > 100) {
            log("CRITICAL: Buffer overflow - Process: " + std::to_string(process_buffer_percentage) + "%");
        }
        
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

int main(int argc, char *argv[]) {
    try {
        // Pin to CPU core 1
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(1, &cpuset);
        pthread_t current_thread = pthread_self();
        if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
            log("Failed to set CPU affinity to core 1");
        } else {
            log("Successfully pinned to CPU core 1");
        }

        timeshift_last_change = std::chrono::steady_clock::time_point(std::chrono::steady_clock::duration::min());
        process_args(argc, argv);
        log("Starting source input processor " + input_ip);

        std::thread receive_thread(receive_data_thread);
        std::thread data_thread(data_input_thread);
        std::thread monitor_thread(monitor_buffer_levels);

        while (threads_running) {
            if (!receive_data()) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }
            if (audioProcessor) {
                audioProcessor_mutex.lock();
                int processed_samples = audioProcessor->processAudio(receive_buffer, processed_buffer + process_buffer_pos);
                audioProcessor_mutex.unlock();
                process_buffer_pos += processed_samples;

                while (process_buffer_pos >= CHUNK_SIZE / sizeof(int32_t))
                    write_output_buffer();
            }
        }

        receive_thread.join();
        data_thread.join();
        monitor_thread.join();

        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Exception caught: " << e.what() << std::endl;
        print_stacktrace();
        return 1;
    } catch (...) {
        std::cerr << "Unknown exception caught" << std::endl;
        print_stacktrace();
        return 1;
    }
}
speaker_mix.cpp0000644000000000000000000003037614774646173012623 0ustar  rootroot#include "audio_processor.h"
#include <emmintrin.h>
#include <immintrin.h>


void AudioProcessor::updateSpeakerMix() {
    // Fills out the speaker mix table speaker_mix[][] with the current configuration.
    memset(speaker_mix, 0, sizeof(speaker_mix));
    // speaker_mix[input channel][output channel] = gain;
    // Ex: To map Left on Stereo to Right on Stereo at half volume you would do:
    // speaker_mix[0][1] = .5;
    switch (inputChannels)
    {
    case 1: // Mono, Ch 0: Left
        // Mono -> All
        for (int output_channel = 0; output_channel < MAX_CHANNELS; output_channel++) // Write the left (first) speaker to every channel
            speaker_mix[0][output_channel] = 1;
        break;
    case 2: // Stereo, Ch 0: Left, Ch 1: Right
        switch (outputChannels)
        {
        case 1:                     // Stereo -> Mono
            speaker_mix[0][0] = .5; // Left to mono .5 vol
            speaker_mix[1][0] = .5; // Right to mono .5 vol
            break;
        case 2:                    // Stereo -> Stereo
            speaker_mix[0][0] = 1; // Left to Left
            speaker_mix[1][1] = 1; // Right to Right
            break;
        case 4:
            speaker_mix[0][0] = 1; // Left to Front Left
            speaker_mix[1][1] = 1; // Right to Front Right
            speaker_mix[0][2] = 1; // Left to Back Left
            speaker_mix[1][3] = 1; // Right to Back Right
            break;
        case 6: // Stereo -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = 1;  // Left to Front Left
            speaker_mix[0][5] = 1;  // Left to Rear Left
            speaker_mix[1][1] = 1;  // Right to Front Right
            speaker_mix[1][6] = 1;  // Right to Rear Right
            speaker_mix[0][3] = .5; // Left to Center Half Vol
            speaker_mix[1][3] = .5; // Right to Center Half Vol
            speaker_mix[0][4] = .5; // Right to Sub Half Vol
            speaker_mix[1][4] = .5; // Left to Sub Half Vol
            break;
        case 8: // Stereo -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1;  // Left to Front Left
            speaker_mix[0][6] = 1;  // Left to Side Left
            speaker_mix[0][4] = 1;  // Left to Rear Left
            speaker_mix[1][1] = 1;  // Right to Front Right
            speaker_mix[1][7] = 1;  // Right to Side Right
            speaker_mix[1][5] = 1;  // Right to Rear Right
            speaker_mix[0][2] = .5; // Left to Center Half Vol
            speaker_mix[1][2] = .5; // Right to Center Half Vol
            speaker_mix[0][3] = .5; // Right to Sub Half Vol
            speaker_mix[1][3] = .5; // Left to Sub Half Vol
            break;
        }
        break;
    case 4:
        switch (outputChannels)
        {
        case 1:                      // Quad -> Mono
            speaker_mix[0][0] = .25; // Front Left to Mono
            speaker_mix[1][0] = .25; // Front Right to Mono
            speaker_mix[2][0] = .25; // Rear Left to Mono
            speaker_mix[3][0] = .25; // Rear Right to Mono
            break;
        case 2:                     // Quad -> Stereo
            speaker_mix[0][0] = .5; // Front Left to Left
            speaker_mix[1][1] = .5; // Front Right to Right
            speaker_mix[2][0] = .5; // Rear Left to Left
            speaker_mix[3][1] = .5; // Rear Right to Right
            break;
        case 4:
            speaker_mix[0][0] = 1; // Front Left to Front Left
            speaker_mix[1][1] = 1; // Front Right to Front Right
            speaker_mix[2][2] = 1; // Rear Left to Rear Left
            speaker_mix[3][3] = 1; // Rear Right to Rear Right
            break;
        case 6: // Quad -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = 1;   // Front Left to Front Left
            speaker_mix[1][1] = 1;   // Front Right to Front Right
            speaker_mix[0][2] = .5;  // Front Left to Center
            speaker_mix[1][2] = .5;  // Front Right to Center
            speaker_mix[0][3] = .25; // Front Left to LFE
            speaker_mix[1][3] = .25; // Front Right to LFE
            speaker_mix[2][3] = .25; // Rear Left to LFE
            speaker_mix[3][3] = .25; // Rear Right to LFE
            speaker_mix[2][4] = 1;   // Rear Left to Rear Left
            speaker_mix[3][5] = 1;   // Rear Right to Rear Right
            break;
        case 8: // Quad -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1;   // Front Left to Front Left
            speaker_mix[1][1] = 1;   // Front Right to Front Right
            speaker_mix[0][2] = .5;  // Front Left to Center
            speaker_mix[1][2] = .5;  // Front Right to Center
            speaker_mix[0][3] = .25; // Front Left to LFE
            speaker_mix[1][3] = .25; // Front Right to LFE
            speaker_mix[2][3] = .25; // Rear Left to LFE
            speaker_mix[3][3] = .25; // Rear Right to LFE
            speaker_mix[2][4] = 1;   // Rear Left to Rear Left
            speaker_mix[3][5] = 1;   // Rear Right to Rear Right
            speaker_mix[0][6] = .5;  // Front Left to Side Left
            speaker_mix[1][7] = .5;  // Front Right to Side Right
            speaker_mix[2][6] = .5;  // Rear Left to Side Left
            speaker_mix[3][7] = .5;  // Rear Right to Side Right
            break;
        }
        break;
    case 6:
        switch (outputChannels)
        {
        case 1:                     // 5.1 Surround -> Mono
            speaker_mix[0][0] = .2; // Front Left to Mono
            speaker_mix[1][0] = .2; // Front Right to Mono
            speaker_mix[2][0] = .2; // Center to Mono
            speaker_mix[4][0] = .2; // Rear Left to Mono
            speaker_mix[5][0] = .2; // Rear Right to Mono
            break;
        case 2:                      // 5.1 Surround -> Stereo
            speaker_mix[0][0] = .33; // Front Left to Left
            speaker_mix[1][1] = .33; // Front Right to Right
            speaker_mix[2][0] = .33; // Center to Left
            speaker_mix[2][1] = .33; // Center to Right
            speaker_mix[4][0] = .33; // Rear Left to Left
            speaker_mix[5][1] = .33; // Rear Right to Right
            break;
        case 4:
            speaker_mix[0][0] = .66; // Front Left to Front Left
            speaker_mix[1][1] = .66; // Front Right to Front Right
            speaker_mix[2][0] = .33; // Center to Front Left
            speaker_mix[2][1] = .33; // Center to Front Right
            speaker_mix[4][2] = 1;   // Rear Left to Rear Left
            speaker_mix[5][3] = 1;   // Rear Right to Rear Right
            break;
        case 6: // 5.1 Surround -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = 1; // Front Left to Front Left
            speaker_mix[1][1] = 1; // Front Right to Front Right
            speaker_mix[2][2] = 1; // Center to Center
            speaker_mix[3][3] = 1; // LFE to LFE
            speaker_mix[4][4] = 1; // Rear Left to Rear Left
            speaker_mix[5][5] = 1; // Rear Right to Rear Right
            break;
        case 8: // 5.1 Surround -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1;  // Front Left to Front Left
            speaker_mix[1][1] = 1;  // Front Right to Front Right
            speaker_mix[2][2] = 1;  // Center to Center
            speaker_mix[3][3] = 1;  // LFE to LFE
            speaker_mix[4][4] = 1;  // Rear Left to Rear Left
            speaker_mix[5][5] = 1;  // Rear Right to Rear Right
            speaker_mix[0][6] = .5; // Front Left to Side Left
            speaker_mix[1][7] = .5; // Front Right to Side Right
            speaker_mix[4][6] = .5; // Rear Left to Side Left
            speaker_mix[5][7] = .5; // Rear Right to Side Right
            break;
        }
        break;
    case 8:
        switch (outputChannels)
        {
        case 1:                              // 7.1 Surround -> Mono
            speaker_mix[0][0] = 1.0f / 7.0f; // Front Left to Mono
            speaker_mix[1][0] = 1.0f / 7.0f; // Front Right to Mono
            speaker_mix[2][0] = 1.0f / 7.0f; // Center to Mono
            speaker_mix[4][0] = 1.0f / 7.0f; // Rear Left to Mono
            speaker_mix[5][0] = 1.0f / 7.0f; // Rear Right to Mono
            speaker_mix[6][0] = 1.0f / 7.0f; // Side Left to Mono
            speaker_mix[7][0] = 1.0f / 7.0f; // Side Right to Mono
            break;
        case 2:                       // 7.1 Surround -> Stereo
            speaker_mix[0][0] = .5;   // Front Left to Left
            speaker_mix[1][1] = .5;   // Front Right to Right
            speaker_mix[2][0] = .25;  // Center to Left
            speaker_mix[2][1] = .25;  // Center to Right
            speaker_mix[4][0] = .125; // Rear Left to Left
            speaker_mix[5][1] = .125; // Rear Right to Right
            speaker_mix[6][0] = .125; // Side Left to Left
            speaker_mix[7][1] = .125; // Side Right to Right
            break;
        case 4:                      // 7.1 Surround -> Quad
            speaker_mix[0][0] = .5;  // Front Left to Front Left
            speaker_mix[1][1] = .5;  // Front Right to Front Right
            speaker_mix[2][0] = .25; // Center to Front Left
            speaker_mix[2][1] = .25; // Center to Front Right
            speaker_mix[4][2] = .66; // Rear Left to Rear Left
            speaker_mix[5][3] = .66; // Rear Right to Rear Right
            speaker_mix[6][0] = .25; // Side Left to Front Left
            speaker_mix[7][1] = .25; // Side Left to Front Right
            speaker_mix[6][2] = .33; // Side Left to Rear Left
            speaker_mix[7][3] = .33; // Side Left to Rear Right
            break;
        case 6: // 7.1 Surround -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = .66; // Front Left to Front Left
            speaker_mix[1][1] = .66; // Front Right to Front Right
            speaker_mix[2][2] = 1;   // Center to Center
            speaker_mix[3][3] = 1;   // LFE to LFE
            speaker_mix[4][4] = .66; // Rear Left to Rear Left
            speaker_mix[5][5] = .66; // Rear Right to Rear Right
            speaker_mix[6][0] = .33; // Side Left to Front Left
            speaker_mix[7][1] = .33; // Side Right to Front Right
            speaker_mix[6][4] = .33; // Side Left to Rear Left
            speaker_mix[7][5] = .33; // Side Right to Rear Right
            break;
        case 8: // 7.1 Surround -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1; // Front Left to Front Left
            speaker_mix[1][1] = 1; // Front Right to Front Right
            speaker_mix[2][2] = 1; // Center to Center
            speaker_mix[3][3] = 1; // LFE to LFE
            speaker_mix[4][4] = 1; // Rear Left to Rear Left
            speaker_mix[5][5] = 1; // Rear Right to Rear Right
            speaker_mix[6][6] = 1; // Side Left to Side Left
            speaker_mix[7][7] = 1; // Side Right to Side Right
            break;
        }
        break;
    }
}

void AudioProcessor::mixSpeakers() {
    //memset(remixed_channel_buffers, 0, sizeof(remixed_channel_buffers));
    for (int pos = 0; pos < channel_buffer_pos; pos++) {
        for (int output_channel = 0; output_channel < outputChannels; output_channel++) {
            float mixed_sample = 0.0f;
            for (int input_channel = 0; input_channel < inputChannels; input_channel++) {
                mixed_sample += static_cast<float>(channel_buffers[input_channel][pos]) 
                                * speaker_mix[input_channel][output_channel];
            }
            // Apply soft clipping
            mixed_sample = softClip(mixed_sample / INT32_MAX);
            // Convert back to int32_t
            remixed_channel_buffers[output_channel][pos] = static_cast<int32_t>(mixed_sample * INT32_MAX);
        }
    }
}

void AudioProcessor::splitBufferToChannels() {
    for (int i = 0; i < resample_buffer_pos; i++) {
        int channel = i % inputChannels;
        int pos = i / inputChannels;
        channel_buffers[channel][pos] = resampled_buffer[i];
    }
    channel_buffer_pos = resample_buffer_pos / inputChannels;
}

void AudioProcessor::mergeChannelsToBuffer() {
    merged_buffer_pos = 0;
    for (int pos = 0; pos < channel_buffer_pos; ++pos) {
        for (int channel = 0; channel < outputChannels; ++channel) {
            merged_buffer[merged_buffer_pos++] = remixed_channel_buffers[channel][pos];
        }
    }
}
audio_processor.h0000644000000000000000000000444314707023704013136 0ustar  rootroot#ifndef AUDIO_PROCESSOR_H
#define AUDIO_PROCESSOR_H

#include <cstdint>
#include <cstring>
#include <thread>
#include <atomic>
#include "libsamplerate/include/samplerate.h"

#define MAX_CHANNELS 8
#define EQ_BANDS 18
#define CHUNK_SIZE 1152

struct SRC_STATE_tag;
typedef SRC_STATE_tag SRC_STATE;
class Biquad;

class AudioProcessor {
public:
    AudioProcessor(int inputChannels, int outputChannels, int inputBitDepth, int inputSampleRate, int outputSampleRate, float volume);
    ~AudioProcessor();

    int processAudio(const uint8_t* inputBuffer, int32_t* outputBuffer);
    void setVolume(float newVolume);
    void setEqualizer(const float* newEq);

protected:
    int inputChannels, outputChannels;
    int inputSampleRate, outputSampleRate;
    int inputBitDepth;
    float volume;
    float eq[EQ_BANDS];
    float speaker_mix[MAX_CHANNELS][MAX_CHANNELS];

    uint8_t receive_buffer[CHUNK_SIZE * 4];
    int32_t scaled_buffer[CHUNK_SIZE * 32];
    uint8_t *scaled_buffer_int8 = (uint8_t *)scaled_buffer;
    int32_t resampled_buffer[CHUNK_SIZE * 32];
    int32_t channel_buffers[MAX_CHANNELS][CHUNK_SIZE * 32];
    int32_t remixed_channel_buffers[MAX_CHANNELS][CHUNK_SIZE * 32];
    int32_t merged_buffer[CHUNK_SIZE * 32];
    int32_t processed_buffer[CHUNK_SIZE * 32]; 

    int scale_buffer_pos = 0;
    int process_buffer_pos = 0;
    int merged_buffer_pos = 0;
    int resample_buffer_pos = 0;
    int channel_buffer_pos = 0;

    SRC_STATE* sampler;
    SRC_STATE* downsampler;
    float resampler_data_in[CHUNK_SIZE * MAX_CHANNELS * 8];
    float resampler_data_out[CHUNK_SIZE * MAX_CHANNELS * 8];

    Biquad* filters[MAX_CHANNELS][EQ_BANDS];
    Biquad* dcFilters[MAX_CHANNELS];

    void updateSpeakerMix();
    void setupBiquad();
    void initializeSampler();
    void scaleBuffer();
    void volumeAdjust();
    float softClip(float sample);
    void resample();
    void downsample();
    void splitBufferToChannels();
    void mixSpeakers();
    void equalize();
    void mergeChannelsToBuffer();
    void noiseShapingDither();
    void setupDCFilter();
    void removeDCOffset();
    bool isProcessingRequired();
    bool isProcessingRequiredCheck();
    void monitorBuffers();

    // Buffer monitoring thread
    std::thread monitor_thread;
    std::atomic<bool> monitor_running;
};

#endif // AUDIO_PROCESSOR_H
layout_mixer.h0000644000000000000000000000000014672710230012436 0ustar  rootrootutils.h0000644000000000000000000000000014650565122011061 0ustar  rootrootlayout_mixer.cpp0000644000000000000000000003174314774634217013030 0ustar  rootroot#include <stdexcept>
#include <string.h>
#define MAX_CHANNELS 8
class layout_mixer {
public:
    float speaker_mix[MAX_CHANNELS][MAX_CHANNELS] = {{1}};
    int input_channels = 0;
    int output_channels = 0;
    
    // constructor to initialize the variables
    layout_mixer(int input_ch, int output_ch) : input_channels(input_ch), output_channels(output_ch) {
        if (input_ch > MAX_CHANNELS || output_ch > MAX_CHANNELS) {
            throw std::invalid_argument("Number of channels cannot exceed " + std::to_string(MAX_CHANNELS));
        }
        build_speaker_mix_table();
    }

    void build_speaker_mix_table()
    { // Fills out the speaker mix table speaker_mix[][] with the current configuration.
        memset(speaker_mix, 0, sizeof(speaker_mix));
        // speaker_mix[input channel][output channel] = gain;
        // Ex: To map Left on Stereo to Right on Stereo at half volume you would do:
        // speaker_mix[0][1] = .5;
        switch (input_channels)
        {
        case 1: // Mono, Ch 0: Left
            // Mono -> All
            for (int output_channel = 0; output_channel < MAX_CHANNELS; output_channel++) // Write the left (first) speaker to every channel
                speaker_mix[0][output_channel] = 1;
            break;
        case 2: // Stereo, Ch 0: Left, Ch 1: Right
            switch (output_channels)
            {
            case 1:                     // Stereo -> Mono
                speaker_mix[0][0] = .5; // Left to mono .5 vol
                speaker_mix[1][0] = .5; // Right to mono .5 vol
                break;
            case 2:                    // Stereo -> Stereo
                speaker_mix[0][0] = 1; // Left to Left
                speaker_mix[1][1] = 1; // Right to Right
                break;
            case 4:
                speaker_mix[0][0] = 1; // Left to Front Left
                speaker_mix[1][1] = 1; // Right to Front Right
                speaker_mix[0][2] = 1; // Left to Back Left
                speaker_mix[1][3] = 1; // Right to Back Right
                break;
            case 6: // Stereo -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = 1;  // Left to Front Left
                speaker_mix[0][5] = 1;  // Left to Rear Left
                speaker_mix[1][1] = 1;  // Right to Front Right
                speaker_mix[1][6] = 1;  // Right to Rear Right
                speaker_mix[0][3] = .5; // Left to Center Half Vol
                speaker_mix[1][3] = .5; // Right to Center Half Vol
                speaker_mix[0][4] = .5; // Right to Sub Half Vol
                speaker_mix[1][4] = .5; // Left to Sub Half Vol
                break;
            case 8: // Stereo -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1;  // Left to Front Left
                speaker_mix[0][6] = 1;  // Left to Side Left
                speaker_mix[0][4] = 1;  // Left to Rear Left
                speaker_mix[1][1] = 1;  // Right to Front Right
                speaker_mix[1][7] = 1;  // Right to Side Right
                speaker_mix[1][5] = 1;  // Right to Rear Right
                speaker_mix[0][2] = .5; // Left to Center Half Vol
                speaker_mix[1][2] = .5; // Right to Center Half Vol
                speaker_mix[0][3] = .5; // Right to Sub Half Vol
                speaker_mix[1][3] = .5; // Left to Sub Half Vol
                break;
            }
            break;
        case 4:
            switch (output_channels)
            {
            case 1:                      // Quad -> Mono
                speaker_mix[0][0] = .25; // Front Left to Mono
                speaker_mix[1][0] = .25; // Front Right to Mono
                speaker_mix[2][0] = .25; // Rear Left to Mono
                speaker_mix[3][0] = .25; // Rear Right to Mono
                break;
            case 2:                     // Quad -> Stereo
                speaker_mix[0][0] = .5; // Front Left to Left
                speaker_mix[1][1] = .5; // Front Right to Right
                speaker_mix[2][0] = .5; // Rear Left to Left
                speaker_mix[3][1] = .5; // Rear Right to Right
                break;
            case 4:
                speaker_mix[0][0] = 1; // Front Left to Front Left
                speaker_mix[1][1] = 1; // Front Right to Front Right
                speaker_mix[2][2] = 1; // Rear Left to Rear Left
                speaker_mix[3][3] = 1; // Rear Right to Rear Right
                break;
            case 6: // Quad -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = 1;   // Front Left to Front Left
                speaker_mix[1][1] = 1;   // Front Right to Front Right
                speaker_mix[0][2] = .5;  // Front Left to Center
                speaker_mix[1][2] = .5;  // Front Right to Center
                speaker_mix[0][3] = .25; // Front Left to LFE
                speaker_mix[1][3] = .25; // Front Right to LFE
                speaker_mix[2][3] = .25; // Rear Left to LFE
                speaker_mix[3][3] = .25; // Rear Right to LFE
                speaker_mix[2][4] = 1;   // Rear Left to Rear Left
                speaker_mix[3][5] = 1;   // Rear Right to Rear Right
                break;
            case 8: // Quad -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1;   // Front Left to Front Left
                speaker_mix[1][1] = 1;   // Front Right to Front Right
                speaker_mix[0][2] = .5;  // Front Left to Center
                speaker_mix[1][2] = .5;  // Front Right to Center
                speaker_mix[0][3] = .25; // Front Left to LFE
                speaker_mix[1][3] = .25; // Front Right to LFE
                speaker_mix[2][3] = .25; // Rear Left to LFE
                speaker_mix[3][3] = .25; // Rear Right to LFE
                speaker_mix[2][4] = 1;   // Rear Left to Rear Left
                speaker_mix[3][5] = 1;   // Rear Right to Rear Right
                speaker_mix[0][6] = .5;  // Front Left to Side Left
                speaker_mix[1][7] = .5;  // Front Right to Side Right
                speaker_mix[2][6] = .5;  // Rear Left to Side Left
                speaker_mix[3][7] = .5;  // Rear Right to Side Right
                break;
            }
            break;
        case 6:
            switch (output_channels)
            {
            case 1:                     // 5.1 Surround -> Mono
                speaker_mix[0][0] = .2; // Front Left to Mono
                speaker_mix[1][0] = .2; // Front Right to Mono
                speaker_mix[2][0] = .2; // Center to Mono
                speaker_mix[4][0] = .2; // Rear Left to Mono
                speaker_mix[5][0] = .2; // Rear Right to Mono
                break;
            case 2:                      // 5.1 Surround -> Stereo
                speaker_mix[0][0] = .33; // Front Left to Left
                speaker_mix[1][1] = .33; // Front Right to Right
                speaker_mix[2][0] = .33; // Center to Left
                speaker_mix[2][1] = .33; // Center to Right
                speaker_mix[4][0] = .33; // Rear Left to Left
                speaker_mix[5][1] = .33; // Rear Right to Right
                break;
            case 4:
                speaker_mix[0][0] = .66; // Front Left to Front Left
                speaker_mix[1][1] = .66; // Front Right to Front Right
                speaker_mix[2][0] = .33; // Center to Front Left
                speaker_mix[2][1] = .33; // Center to Front Right
                speaker_mix[4][2] = 1;   // Rear Left to Rear Left
                speaker_mix[5][3] = 1;   // Rear Right to Rear Right
                break;
            case 6: // 5.1 Surround -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = 1; // Front Left to Front Left
                speaker_mix[1][1] = 1; // Front Right to Front Right
                speaker_mix[2][2] = 1; // Center to Center
                speaker_mix[3][3] = 1; // LFE to LFE
                speaker_mix[4][4] = 1; // Rear Left to Rear Left
                speaker_mix[5][5] = 1; // Rear Right to Rear Right
                break;
            case 8: // 5.1 Surround -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1;  // Front Left to Front Left
                speaker_mix[1][1] = 1;  // Front Right to Front Right
                speaker_mix[2][2] = 1;  // Center to Center
                speaker_mix[3][3] = 1;  // LFE to LFE
                speaker_mix[4][4] = 1;  // Rear Left to Rear Left
                speaker_mix[5][5] = 1;  // Rear Right to Rear Right
                speaker_mix[0][6] = .5; // Front Left to Side Left
                speaker_mix[1][7] = .5; // Front Right to Side Right
                speaker_mix[4][6] = .5; // Rear Left to Side Left
                speaker_mix[5][7] = .5; // Rear Right to Side Right
                break;
            }
            break;
        case 8:
            switch (output_channels)
            {
            case 1:                              // 7.1 Surround -> Mono
                speaker_mix[0][0] = 1.0f / 7.0f; // Front Left to Mono
                speaker_mix[1][0] = 1.0f / 7.0f; // Front Right to Mono
                speaker_mix[2][0] = 1.0f / 7.0f; // Center to Mono
                speaker_mix[4][0] = 1.0f / 7.0f; // Rear Left to Mono
                speaker_mix[5][0] = 1.0f / 7.0f; // Rear Right to Mono
                speaker_mix[6][0] = 1.0f / 7.0f; // Side Left to Mono
                speaker_mix[7][0] = 1.0f / 7.0f; // Side Right to Mono
                break;
            case 2:                       // 7.1 Surround -> Stereo
                speaker_mix[0][0] = .5;   // Front Left to Left
                speaker_mix[1][1] = .5;   // Front Right to Right
                speaker_mix[2][0] = .25;  // Center to Left
                speaker_mix[2][1] = .25;  // Center to Right
                speaker_mix[4][0] = .125; // Rear Left to Left
                speaker_mix[5][1] = .125; // Rear Right to Right
                speaker_mix[6][0] = .125; // Side Left to Left
                speaker_mix[7][1] = .125; // Side Right to Right
                break;
            case 4:                      // 7.1 Surround -> Quad
                speaker_mix[0][0] = .5;  // Front Left to Front Left
                speaker_mix[1][1] = .5;  // Front Right to Front Right
                speaker_mix[2][0] = .25; // Center to Front Left
                speaker_mix[2][1] = .25; // Center to Front Right
                speaker_mix[4][2] = .66; // Rear Left to Rear Left
                speaker_mix[5][3] = .66; // Rear Right to Rear Right
                speaker_mix[6][0] = .25; // Side Left to Front Left
                speaker_mix[7][1] = .25; // Side Left to Front Right
                speaker_mix[6][2] = .33; // Side Left to Rear Left
                speaker_mix[7][3] = .33; // Side Left to Rear Right
                break;
            case 6: // 7.1 Surround -> 5.1 Surround
                // FL FR C LFE BL BR
                speaker_mix[0][0] = .66; // Front Left to Front Left
                speaker_mix[1][1] = .66; // Front Right to Front Right
                speaker_mix[2][2] = 1;   // Center to Center
                speaker_mix[3][3] = 1;   // LFE to LFE
                speaker_mix[4][4] = .66; // Rear Left to Rear Left
                speaker_mix[5][5] = .66; // Rear Right to Rear Right
                speaker_mix[6][0] = .33; // Side Left to Front Left
                speaker_mix[7][1] = .33; // Side Right to Front Right
                speaker_mix[6][4] = .33; // Side Left to Rear Left
                speaker_mix[7][5] = .33; // Side Right to Rear Right
                break;
            case 8: // 7.1 Surround -> 7.1 Surround
                // FL FR C LFE BL BR SL SR
                speaker_mix[0][0] = 1; // Front Left to Front Left
                speaker_mix[1][1] = 1; // Front Right to Front Right
                speaker_mix[2][2] = 1; // Center to Center
                speaker_mix[3][3] = 1; // LFE to LFE
                speaker_mix[4][4] = 1; // Rear Left to Rear Left
                speaker_mix[5][5] = 1; // Rear Right to Rear Right
                speaker_mix[6][6] = 1; // Side Left to Side Left
                speaker_mix[7][7] = 1; // Side Right to Side Right
                break;
            }
            break;
        }
    }

    void mix_speakers(int32_t** in_buffer, int32_t** remixed_out_buffer, int sample_count) {
        for (int pos = 0; pos < sample_count; pos++)
            for (int input_channel = 0; input_channel < input_channels; input_channel++)
                for (int output_channel = 0; output_channel < output_channels; output_channel++)
                        remixed_out_buffer[input_channel][output_channel] = 0;
        for (int pos = 0; pos < sample_count; pos++)
            for (int input_channel = 0; input_channel < input_channels; input_channel++)
                for (int output_channel = 0; output_channel < output_channels; output_channel++)
                    remixed_out_buffer[output_channel][pos] += in_buffer[input_channel][pos] * speaker_mix[input_channel][output_channel];
    }
};rtp_receiver.cpp0000644000000000000000000001360615000443333012752 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <lame/lame.h>
#include <algorithm>
#include <string>
#include <pthread.h>
#include <sched.h>
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio stream
#define RTP_HEADER_SIZE 12 // Size of the Scream header, which contains information about the output audio stream
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE) // Total packet size including header and chunk
#define TAG_LENGTH 45
#define DATA_RECEIVE_POS (TAG_LENGTH - (RTP_HEADER_SIZE - HEADER_SIZE))

bool running = true; // Flag to control loop execution

uint8_t buffer[TAG_LENGTH + RTP_HEADER_SIZE + CHUNK_SIZE] = {0}; // Vector of pointers to receive buffers for input streams

uint8_t header[HEADER_SIZE] = {0};

vector<int> output_fds; // Vector of file descriptors for audio input streams

int listen_fd = 0; // fd for audio input

int data_fd = 0; // fd for writing IPs to

vector<string> known_ip_procs = {};

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      &listen_fd,
                      &data_fd};
int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

struct sockaddr_in receive_addr;

socklen_t receive_addr_len = sizeof(receive_addr);

void log(const string &message, bool endl = true, bool tag = true) {
    printf("%s %s%s", tag?"[RTP Listener]":"", message.c_str(), endl?"\n":"");
}

// Function to process fixed command line arguments like IP address and output port
void process_args(int argc, char** argv) {
    if (argc <= config_argc)
        ::exit(-1);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
void process_fd_args(int argc, char* argv[]) {
    for (int argi = config_argc; argi < argc; argi++) {
        output_fds.push_back(atoi(argv[argi]));
    }
}

void setup_header() { // Sets up the Scream header
    int output_samplerate = 48000;
    int output_bitdepth = 16;
    int output_channels = 2;
    int output_chlayout1 = 0x03;
    int output_chlayout2 = 0x00;
    bool output_samplerate_44100_base = (output_samplerate % 44100) == 0;
    // cppcheck-suppress knownConditionTrueFalse
    uint8_t output_samplerate_mult = (output_samplerate_44100_base?44100:48000) / output_samplerate;
    header[0] = output_samplerate_mult + (output_samplerate_44100_base << 7);
    header[1] = output_bitdepth;
    header[2] = output_channels;
    header[3] = output_chlayout1;
    header[4] = output_chlayout2;
    log("Set up Header, Rate: " + to_string(output_samplerate) + ", Bit-Depth" + to_string(output_bitdepth) + ", Channels" + to_string(output_channels));
}

bool parseHeader() {
    // Parse RTP header (first 12 bytes of buffer)
    /*uint8_t version = (buffer[DATA_RECEIVE_POS] >> 6) & 0x03;
    bool padding = (buffer[DATA_RECEIVE_POS] >> 5) & 0x01;
    bool extension = (buffer[DATA_RECEIVE_POS] >> 4) & 0x01;
    uint8_t csrcCount = buffer[DATA_RECEIVE_POS] & 0x0F;
    bool marker = (buffer[DATA_RECEIVE_POS + 1] >> 7) & 0x01;*/
    uint8_t payloadType = buffer[DATA_RECEIVE_POS + 1] & 0x7F;
    /*uint16_t sequenceNumber = (buffer[DATA_RECEIVE_POS + 2] << 8) | buffer[DATA_RECEIVE_POS + 3];
    uint32_t timestamp = (buffer[DATA_RECEIVE_POS + 4] << 24) | (buffer[DATA_RECEIVE_POS + 5] << 16) |
                         (buffer[DATA_RECEIVE_POS + 6] << 8) | buffer[DATA_RECEIVE_POS + 7];
    uint32_t ssrc = (buffer[DATA_RECEIVE_POS + 8] << 24) | (buffer[DATA_RECEIVE_POS + 9] << 16) |
                    (buffer[DATA_RECEIVE_POS + 10] << 8) | buffer[DATA_RECEIVE_POS + 11];*/
    return payloadType == 127; // Return true if parsing was successful
}

bool receive() {
    int bytes = recvfrom(listen_fd, buffer + DATA_RECEIVE_POS, RTP_HEADER_SIZE+CHUNK_SIZE, 0, (struct sockaddr *) &receive_addr, &receive_addr_len);
    if (bytes == -1) 
        ::exit(-1);
    if (bytes != RTP_HEADER_SIZE+CHUNK_SIZE)
        return false;
    return true;
}

void send() {
    memset(buffer, 0, TAG_LENGTH);
    strcpy(reinterpret_cast<char*>(buffer), inet_ntoa(receive_addr.sin_addr));
    string ip_address = string(reinterpret_cast<char*>(buffer));
    if (find(known_ip_procs.begin(), known_ip_procs.end(), ip_address) == known_ip_procs.end()) {
        known_ip_procs.push_back(ip_address);
        write(data_fd, (ip_address + "\n").c_str(), ip_address.length());
    }
    memcpy(buffer + TAG_LENGTH, header, HEADER_SIZE);
    for (int fd_idx=0;fd_idx<output_fds.size();fd_idx++)
        write(output_fds[fd_idx], buffer, PACKET_SIZE + TAG_LENGTH);
}

int main(int argc, char* argv[]) {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1", true, true);
    } else {
        log("Successfully pinned to CPU core 1", true, true);
    }

    process_args(argc, argv);

    process_fd_args(argc, argv);
    log("Input FDs: ", false, true);
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]) + " ", false, false);
    log("", true, false);
    setup_header();

    while (running)
        if (receive())
            if (parseHeader())
                send();
        else
            sleep(.2);
    return 0;
}
scream_per_process_receiver.cpp0000644000000000000000000001232215000443373016021 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <sys/select.h>
#include <sys/time.h>
#include <lame/lame.h>
#include <algorithm>
#include <string>
#include <pthread.h>
#include <sched.h>
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define IP_LENGTH 15
#define PROGRAM_TAG_LENGTH 30
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio strea
#define PACKET_SIZE (CHUNK_SIZE + PROGRAM_TAG_LENGTH + HEADER_SIZE) // Total packet size including header and chunk

bool running = true; // Flag to control loop execution

uint8_t buffer[IP_LENGTH + PACKET_SIZE] = {0}; // Vector of pointers to receive buffers for input streams
char* tag = reinterpret_cast<char*>(buffer);

vector<int> output_fds; // Vector of file descriptors for audio input streams

int listen_fd = 0; // fd for audio input

int data_fd = 0; // fd for writing IPs to

vector<string> known_ip_procs = {};

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      &listen_fd,
                      &data_fd};

int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

struct sockaddr_in receive_addr;

socklen_t receive_addr_len = sizeof(receive_addr);

void log(const string &message, bool endl = true, bool tag = true) {
    printf("%s %s%s", tag?"[Scream Per-Port Listener]":"", message.c_str(), endl?"\n":"");
}

// Function to process fixed command line arguments like IP address and output port
void process_args(int argc, char** argv) {
    if (argc <= config_argc)
        ::exit(-1);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
void process_fd_args(int argc, char* argv[]) {
    for (int argi = config_argc; argi < argc; argi++) {
        output_fds.push_back(atoi(argv[argi]));
    }
}

bool receive() {
    int bytes = recvfrom(listen_fd, buffer + IP_LENGTH, PACKET_SIZE, 0, (struct sockaddr *) &receive_addr, &receive_addr_len);
    //printf("Packet in Bytes: %i Process: %s\n", bytes, buffer);
    if (bytes == -1) 
        ::exit(-1);
    if (bytes != PACKET_SIZE)
        return false;
    return true;
}

void set_tag() {
    //Format for buffer is
    //XXX.XXX.XXX.XXXTAGTAGTAGTAGTAGTAGTAGTAGTAGTA\0DATADATA...
    //If the IP does not fill the full size empty space is filled with spaces.
    //The buffer has the TAG and data in it already and just needs the IP written
    memset(tag, ' ', IP_LENGTH); // Clear with space
    strcpy(tag, inet_ntoa(receive_addr.sin_addr)); // Write IP to start
    tag[strlen(tag)] = ' '; // Clear null terminator
    tag[IP_LENGTH + PROGRAM_TAG_LENGTH - 1] = 0; // Ensure it's got a null terminator at the end of the tag
}

void check_if_known() {
   bool already_known = false;
    for (int idx=0;idx<known_ip_procs.size();idx++) {
        if (known_ip_procs.at(idx) == tag) {
            already_known = true;
            break;
        }
    }
    if (!already_known) {
        dprintf(data_fd, "%s\n", tag);
        known_ip_procs.push_back(tag);
    } 
}


void send() {

    // Use select to check if sockets are ready for writing
    fd_set write_fds;
    struct timeval timeout;
    
    // Set timeout to 0 seconds, 100 microseconds (non-blocking)
    timeout.tv_sec = 0;
    timeout.tv_usec = 100;
    
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++) {
        // Initialize the file descriptor set
        FD_ZERO(&write_fds);
        FD_SET(output_fds[fd_idx], &write_fds);
        
        // Check if this socket is ready for writing
        int select_result = select(output_fds[fd_idx] + 1, NULL, &write_fds, NULL, &timeout);
        
        // Write only if select indicates the socket is ready
        if (select_result > 0 && FD_ISSET(output_fds[fd_idx], &write_fds)) {
            write(output_fds[fd_idx], buffer, PACKET_SIZE + IP_LENGTH);
        }
    }
}

int main(int argc, char* argv[]) {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1", true, true);
    } else {
        log("Successfully pinned to CPU core 1", true, true);
    }

    log("Start");
    process_args(argc, argv);

    process_fd_args(argc, argv);
    log("Input FDs: ", false, true);
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]) + " ", false, false);
    log("", true, false);

    while (running)
        if (receive())
        {
            set_tag();
            check_if_known();
            send();
        } else {
            sleep(.01);
        }
    return 0;
}
scream_receiver.cpp0000644000000000000000000000737215000443353013424 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <lame/lame.h>
#include <algorithm>
#include <string>
#include <pthread.h>
#include <sched.h>
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio stream
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE) // Total packet size including header and chunk
#define TAG_LENGTH 45

bool running = true; // Flag to control loop execution

uint8_t buffer[TAG_LENGTH + PACKET_SIZE] = {0}; // Vector of pointers to receive buffers for input streams

vector<int> output_fds; // Vector of file descriptors for audio input streams

int listen_fd = 0; // fd for audio input

int data_fd = 0; // fd for writing IPs to

vector<string> known_ip_procs = {};

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      &listen_fd,
                      &data_fd};

int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

struct sockaddr_in receive_addr;

socklen_t receive_addr_len = sizeof(receive_addr);

void log(const string &message, bool endl = true, bool tag = true) {
    printf("%s %s%s", tag?"[RTP Listener]":"", message.c_str(), endl?"\n":"");
}

// Function to process fixed command line arguments like IP address and output port
void process_args(int argc, char** argv) {
    if (argc <= config_argc)
        ::exit(-1);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
void process_fd_args(int argc, char* argv[]) {
    for (int argi = config_argc; argi < argc; argi++) {
        output_fds.push_back(atoi(argv[argi]));
    }
}

bool receive() {
    int bytes = recvfrom(listen_fd, buffer + TAG_LENGTH, PACKET_SIZE, 0, (struct sockaddr *) &receive_addr, &receive_addr_len);
    if (bytes == -1) 
        ::exit(-1);
    if (bytes != PACKET_SIZE)
        return false;
    return true;
}

void send() {
    memset(buffer, 0, TAG_LENGTH);
    strcpy(reinterpret_cast<char*>(buffer), inet_ntoa(receive_addr.sin_addr));
    string ip_address = string(reinterpret_cast<char*>(buffer));
    if (find(known_ip_procs.begin(), known_ip_procs.end(), ip_address) == known_ip_procs.end()) {
        known_ip_procs.push_back(ip_address);
        write(data_fd, (ip_address + "\n").c_str(), ip_address.length());
    }
    for (int fd_idx=0;fd_idx<output_fds.size();fd_idx++)
        write(output_fds[fd_idx], buffer, PACKET_SIZE + TAG_LENGTH);
}

int main(int argc, char* argv[]) {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1", true, true);
    } else {
        log("Successfully pinned to CPU core 1", true, true);
    }

    process_args(argc, argv);

    process_fd_args(argc, argv);
    log("Input FDs: ", false, true);
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]) + " ", false, false);
    log("", true, false);

    while (running)
        if (receive())
            send();
        else
            sleep(.2);
    return 0;
}
sink_audio_mixer.cpp0000644000000000000000000005131615006141757013625 0ustar  rootroot// C++ code for streaming audio data over a network using TCP/UDP protocols.

#include <iostream>
#include <vector>
#include "string.h"
#include <istream>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <lame/lame.h>
#ifdef __SSE2__
#include <emmintrin.h>
#endif
#include <immintrin.h>
#include <pthread.h>
#include <sched.h>
#include "audio_processor.h"
#include "dcaenc/dcaenc.h"
#include <sys/time.h>

AudioProcessor *lameProcessor = NULL;
using namespace std;

// Configuration variables
#define CHUNK_SIZE 1152 // Chunk size in bytes for audio data
#define HEADER_SIZE 5 // Size of the Scream header, which contains information about the output audio stream
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE) // Total packet size including header and chunk

bool running = true; // Flag to control loop execution

// Buffer system overview:
// 1. receive_buffers: Array of input buffers, one per audio source. Each buffer stores CHUNK_SIZE bytes of 32-bit audio samples
// 2. mixing_buffer: Single buffer where all active input streams are mixed together
// 3. output_buffer: Double-buffered output storage (2x PACKET_SIZE) allowing continuous streaming
// 4. mp3_buffer: Temporary storage for MP3 encoded data before sending

vector<int32_t*> receive_buffers; // Vector of input buffers, one per audio source
int32_t* mixing_buffer = new int32_t[CHUNK_SIZE / sizeof(int32_t)]; // Target buffer for mixed audio data
uint8_t *mixing_buffer_uint8 = (uint8_t*)mixing_buffer; // Byte-level access to mixing buffer for downsampling
char output_buffer[PACKET_SIZE * 2] = {0}; // Double-buffered output (2x PACKET_SIZE) for continuous streaming
int output_buffer_pos = 0; // Current write position in output_buffer
uint8_t mp3_buffer[CHUNK_SIZE * 8]; // Temporary storage for MP3 encoded data
int mp3_buffer_pos = 0; // Current position in MP3 buffer

lame_t lame = lame_init();

struct sockaddr_in udp_dest_addr = {}; // Socket address structure for UDP socket destination
int udp_output_fd = 0; // File descriptor for the UDP socket

struct timeval receive_timeout;
fd_set read_fds;

int tcp_output_fd = 0; // File descriptor for the TCP socket
int mp3_write_fd = 0; // File descriptor to write mp3 to
vector<int> output_fds; // Vector of file descriptors for audio input streams
bool active[1024] = {0}; // Vector to store whether each input stream is active or not
bool output_active = false; // Flag to indicate if there's any data to be sent over the network
string output_ip = ""; // IP address of the UDP socket destination
int output_port = 0; // Port number of the UDP socket destination
int output_bitdepth = 0; // Bit depth of the output audio stream
int output_samplerate = 0; // Sample rate of the output audio stream
int output_channels = 0; // Number of channels in the output audio stream
int output_chlayout1 = 0; // Channel layout part 1 for the output audio stream
int output_chlayout2 = 0; // Channel layout part 2 for the output audio stream
int use_dts = 0; // Is it outputting DTS?
dcaenc_context_s *dca_context; // DTS encoding context

// Array to hold integers passed from command line arguments, NULL indicates an argument is ignored
int* config_argv[] = {NULL, // Process File Name
                      NULL, // output_ip (string)
                      &output_port,
                      &output_bitdepth,
                      &output_samplerate,
                      &output_channels,
                      &output_chlayout1,
                      &output_chlayout2,
                      &tcp_output_fd,
                      &mp3_write_fd};
int config_argc = sizeof(config_argv) / sizeof(int*); // Number of command line arguments to process

inline void log(const string &message) {
    printf("[Sink Output Processor %s:%i] %s\n", output_ip.c_str(), output_port, message.c_str());
}

// Function to process fixed command line arguments like IP address and output port
inline void process_args(char* argv[], int argc) {
    if (argc <= config_argc)
        ::exit(-1);
    // cppcheck-suppress ctuArrayIndex
    output_ip = string(argv[1]);
    for (int argi = 0; argi < config_argc; argi++)
        if (config_argv[argi] == 0)
            continue;
        else
            *(config_argv[argi]) = atoi(argv[argi]);
}

// Function to process variable number of command line arguments representing file descriptors for input streams
inline void process_fd_args(char* argv[], int argc) {
    for (int argi = config_argc; argi < argc; argi++)
        output_fds.push_back(atoi(argv[argi]));
}

inline void setup_header() { // Sets up the Scream header
    bool output_samplerate_44100_base = (output_samplerate % 44100) == 0;
    uint8_t output_samplerate_mult = (output_samplerate_44100_base?44100:48000) / output_samplerate;
    output_buffer[0] = output_samplerate_mult + (output_samplerate_44100_base << 7);
    output_buffer[1] = output_bitdepth;
    output_buffer[2] = output_channels;
    output_buffer[3] = output_chlayout1;
    output_buffer[4] = output_chlayout2;
    log("Set up Header, Rate: " + to_string(output_samplerate) + ", Bit-Depth" + to_string(output_bitdepth) + ", Channels" + to_string(output_channels));
}

inline void setup_udp() { // Sets up the UDP socket for output
    log("UDP Set Up");
    udp_output_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    udp_dest_addr.sin_family = AF_INET;
    udp_dest_addr.sin_port = htons(output_port);
    inet_pton(AF_INET, output_ip.c_str(), &udp_dest_addr.sin_addr);
    int dscp = 63;
    int val = dscp << 2;
    setsockopt(udp_output_fd, IPPROTO_IP, IP_TOS, &val, sizeof(val));
    if (tcp_output_fd > 0) {
        setsockopt(tcp_output_fd, IPPROTO_IP, IP_TOS, &val, sizeof(val));
        fd_set fd;
        timeval tv;
        FD_ZERO(&fd);
        FD_SET(tcp_output_fd, &fd);
        tv.tv_sec = 15;
        tv.tv_usec = 0;
        u_long yes = 1;
        fcntl(tcp_output_fd, F_SETFL, fcntl(tcp_output_fd, F_GETFL, 0) | O_NONBLOCK);
        fcntl(tcp_output_fd, F_SETFL, fcntl(tcp_output_fd, F_GETFL, 0) | O_NDELAY);
        setsockopt(tcp_output_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        int newsize = 1152 * 16;
        setsockopt(tcp_output_fd, SOL_SOCKET, SO_SNDBUF, &newsize, sizeof(newsize));
        newsize = 1152 * 8;
        setsockopt(mp3_write_fd, SOL_SOCKET, SO_SNDBUF, &newsize, sizeof(newsize));
        bool trew = true;
        setsockopt(mp3_write_fd, SOL_SOCKET, SOCK_NONBLOCK, &trew, sizeof(trew));
        int flags = fcntl(mp3_write_fd, F_GETFL, 0);
        fcntl(mp3_write_fd, F_SETFL, flags | O_NONBLOCK);
        setsockopt (tcp_output_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        log("TCP Set Up");
    }
}

inline void setup_buffers() { // Sets up buffers to receive data from input fds
    log("Buffers Set Up");
    setbuf(stdout, NULL);
    for (int buf_idx = 0; buf_idx < output_fds.size(); buf_idx++)
        receive_buffers.push_back(static_cast<int32_t*>(malloc(CHUNK_SIZE)));
}

inline void setup_lame() {
    lame_set_in_samplerate(lame, output_samplerate);
    lame_set_VBR(lame, vbr_off);
    lame_init_params(lame);
}

bool lame_active = true;
struct timeval lame_timeout;
fd_set lame_fd;

inline void write_lame() {
    FD_ZERO(&lame_fd);
    FD_SET(mp3_write_fd, &lame_fd);
    lame_timeout.tv_sec = 0;
    lame_timeout.tv_usec = 0;
    int result = select(mp3_write_fd + 1, NULL, &lame_fd, NULL, &lame_timeout);
    // ScreamRouter will stop reading from the MP3 FD if there's no clients. Don't encode if there's no reader.
    if (result > 0 && FD_ISSET(mp3_write_fd, &lame_fd)) {
        if (!lame_active) {
            lame_active = true;
            log("MP3 Stream Active");
        }
        int32_t processed_buffer[CHUNK_SIZE / sizeof(uint32_t)];
        int processed_samples = lameProcessor->processAudio(reinterpret_cast<const uint8_t*>(mixing_buffer), processed_buffer);

        mp3_buffer_pos = lame_encode_buffer_interleaved_int(lame, processed_buffer, processed_samples / 2, mp3_buffer, CHUNK_SIZE * 8);
        
        if (mp3_buffer_pos > 0)
            write(mp3_write_fd, mp3_buffer, mp3_buffer_pos);
    }
    else {
        if (lame_active) {
            lame_active = false;
            log("MP3 Stream Inactive");
        }
    }
}

// Synchronization mechanism for multiple input streams:
// 1. Checks which input streams have data ready using non-blocking select()
// 2. Waits up to 15ms for lagging streams to catch up
// 3. Marks streams as inactive if they consistently lag behind
// 4. Detects when inactive streams become active again
inline void mark_fds_active_inactive() {
    fd_set check_fds;
    fd_set active_fds;
    FD_ZERO(&check_fds);
    FD_ZERO(&active_fds);
    int max_fd = 0;
    int total_active = 0;
    
    // Find the max fd and set up active_fds
    for (int idx = 0; idx < output_fds.size(); idx++) {
        if (active[idx]) {
            FD_SET(output_fds[idx], &active_fds);
            if (output_fds[idx] > max_fd) {
                max_fd = output_fds[idx];
            }
            total_active++;
        }
    }
    
    // Run a select against all active FDs with zero timeout
    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    fd_set ready_fds = active_fds;
    int result = select(max_fd + 1, &ready_fds, NULL, NULL, &tv);
    
    // If all active FDs have data, we're done with this part
    if (result == total_active) {
        // All active FDs have data, nothing to check
    } else {
        // Store all active FDs that do not have data pending in check_fds
        for (int idx = 0; idx < output_fds.size(); idx++) {
            if (active[idx] && !FD_ISSET(output_fds[idx], &ready_fds)) {
                FD_SET(output_fds[idx], &check_fds);
            }
        }
        
        // If there are FDs in check_fds, poll every 1ms for up to 20ms
        if (result < total_active) {
            struct timeval start_time, current_time;
            gettimeofday(&start_time, NULL);
            long elapsed_usec = 0;
            bool all_good = false;
            while (elapsed_usec <= 15000) {
                // Check if 30ms have elapsed for timeout
                gettimeofday(&current_time, NULL);
                elapsed_usec = (current_time.tv_sec - start_time.tv_sec) * 1000000 + 
                                   (current_time.tv_usec - start_time.tv_usec);
                
                // Poll with 1ms timeout
                fd_set temp_check_fds = check_fds;
                tv.tv_sec = 0;
                tv.tv_usec = 1000; // 1ms
                result = select(max_fd + 1, &temp_check_fds, NULL, NULL, &tv);
                
                if (result <= 0) {
                    continue; // No FDs ready or error
                }
                
                // Remove FDs that now have data from check_fds
                for (int idx = 0; idx < output_fds.size(); idx++) {
                    if (active[idx] && FD_ISSET(output_fds[idx], &temp_check_fds)) {
                        FD_CLR(output_fds[idx], &check_fds);
                    }
                }
                
                // If all FDs now have data, we can stop polling
                if (FD_ISSET(0, &check_fds) == 0) {
                    all_good = true;
                    break;
                }
            }
            if (!all_good) {
                // After 20ms, mark any remaining FDs in check_fds as false in active[]
                for (int idx = 0; idx < output_fds.size(); idx++) {
                    if (active[idx] && FD_ISSET(output_fds[idx], &check_fds)) {
                        active[idx] = false;
                        log("Input " + std::to_string(idx) + " inactive");
                    }
                }
            }
        }
    }
    
    // Run a zero-ms select on all inactive FDs
    FD_ZERO(&check_fds);
    max_fd = 0;
    
    for (int idx = 0; idx < output_fds.size(); idx++) {
        if (!active[idx]) {
            FD_SET(output_fds[idx], &check_fds);
            if (output_fds[idx] > max_fd) {
                max_fd = output_fds[idx];
            }
        }
    }
    
    if (max_fd > 0) {
        tv.tv_sec = 0;
        tv.tv_usec = 0;
        fd_set temp_check_fds = check_fds;
        result = select(max_fd + 1, &temp_check_fds, NULL, NULL, &tv);
        
        // If any inactive FDs are now active, set them to true in active[]
        if (result > 0) {
            for (int idx = 0; idx < output_fds.size(); idx++) {
                if (!active[idx] && FD_ISSET(output_fds[idx], &temp_check_fds)) {
                    active[idx] = true;
                    log("Input " + std::to_string(idx) + " active");
                    total_active++;
                }
            }
        }
    }
}

// Buffer reading mechanism:
// 1. Uses mark_fds_active_inactive() to determine which inputs are ready
// 2. For each active input:
//    - Uses non-blocking select() to check for available data
//    - Reads data in chunks until CHUNK_SIZE bytes are collected
//    - Handles partial reads and temporary unavailability
// 3. Sets output_active flag when data is successfully read
inline bool handle_receive_buffers() {
    output_active = false;
    mark_fds_active_inactive();
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++) {
        if (active[fd_idx]) {
            fd_set read_set;
            struct timeval timeout;
            timeout.tv_sec = 0;
            timeout.tv_usec = 15000;
            
            for (int bytes_in = 0; running && bytes_in < CHUNK_SIZE;) {
                FD_ZERO(&read_set);
                FD_SET(output_fds[fd_idx], &read_set);
                
                int ready = select(output_fds[fd_idx] + 1, &read_set, NULL, NULL, &timeout);
                if (ready < 1) {
                    break;
                }
                
                if (FD_ISSET(output_fds[fd_idx], &read_set)) {
                    int bytes_read = read(output_fds[fd_idx], 
                                        receive_buffers[fd_idx] + bytes_in, 
                                        CHUNK_SIZE - bytes_in);
                    if (bytes_read <= 0) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) continue;
                        log("Read error: " + string(strerror(errno)));
                        return false;
                    }
                    bytes_in += bytes_read;
                }
            }
            output_active = true;
        }
    }
    return output_active;
}

// Audio mixing process:
// 1. Uses SIMD instructions when available (AVX2 or SSE2) for efficient mixing
// 2. Adds samples from all active input streams into mixing_buffer
// 3. Includes overflow protection in non-SIMD path
// 4. Processing happens in 32-bit integer format for maximum dynamic range
void mix_buffers() {
#if defined(__AVX2__)
    for (int buf_pos = 0; buf_pos < CHUNK_SIZE / sizeof(int32_t); buf_pos += 8) {
        __m256i mixing = _mm256_setzero_si256();
        for (int input_buf_idx = 0; input_buf_idx < receive_buffers.size(); input_buf_idx++) {
            if (!active[input_buf_idx])
                continue;
            __m256i receive = _mm256_loadu_si256((__m256i*)&receive_buffers[input_buf_idx][buf_pos]);
            mixing = _mm256_add_epi32(mixing, receive);
        }
        _mm256_storeu_si256((__m256i*)&mixing_buffer[buf_pos], mixing);
    }
#elif defined(__SSE2__)
    for (int buf_pos = 0; buf_pos < CHUNK_SIZE / sizeof(int32_t); buf_pos += 4) {
        __m128i mixing = _mm_setzero_si128();
        for (int input_buf_idx = 0; input_buf_idx < receive_buffers.size(); input_buf_idx++) {
            if (!active[input_buf_idx])
                continue;
            __m128i receive = _mm_load_si128((__m128i*)&receive_buffers[input_buf_idx][buf_pos]);
            mixing = _mm_add_epi32(mixing, receive);
        }
        _mm_store_si128((__m128i*)&mixing_buffer[buf_pos], mixing);
    }
#else
    for (int buf_pos = 0; buf_pos < CHUNK_SIZE / sizeof(int32_t); buf_pos++) {
        mixing_buffer[buf_pos] = 0;
        for (int input_buf_idx = 0; input_buf_idx < receive_buffers.size(); input_buf_idx++) {
            if (!active[input_buf_idx])
                continue;
            mixing_buffer[buf_pos] += receive_buffers[input_buf_idx][buf_pos];
        }
        if (mixing_buffer[buf_pos] > INT32_MAX) {
            mixing_buffer[buf_pos] = INT32_MAX;
        } else if (mixing_buffer[buf_pos] < INT32_MIN) {
            mixing_buffer[buf_pos] = INT32_MIN;
        }
    }
#endif
}

// Buffer format conversion:
// 1. Converts 32-bit mixed samples to target bit depth (e.g., 16-bit or 24-bit)
// 2. Writes converted data to output_buffer after header
// 3. Maintains proper byte alignment for different output formats
inline void downscale_buffer() {
    int output_bytedepth = output_bitdepth / 8;
    for (int input_pos = 0;input_pos < CHUNK_SIZE; input_pos++) {
        if (output_buffer_pos % output_bytedepth == 0)
            input_pos += sizeof(uint32_t) - output_bytedepth;
        output_buffer[HEADER_SIZE + output_buffer_pos++] = mixing_buffer_uint8[input_pos];
    }
}

inline void send_buffer() { // Sends a buffer over TCP or UDP depending on which is active
    if (tcp_output_fd) {
        int result = send(tcp_output_fd, output_buffer + HEADER_SIZE, CHUNK_SIZE, 0);
        if (result <= 0) {
            if (errno != EAGAIN) { // Resource Temporary Unavailable (buffer full)
                log("Got TCP error: " + to_string(errno) + ")");
                //close(tcp_output_fd);
                tcp_output_fd = 0;
            }
        }
    } else
        sendto(udp_output_fd, output_buffer, PACKET_SIZE, 0, (struct sockaddr *)&udp_dest_addr, sizeof(udp_dest_addr));
}

// Double buffer management:
// 1. Implements a sliding window over output_buffer
// 2. Moves last CHUNK_SIZE bytes to start of buffer when needed
// 3. Ensures continuous streaming without gaps between packets
inline void rotate_buffer() {
    if (output_buffer_pos >= CHUNK_SIZE) {
        memcpy(output_buffer + HEADER_SIZE, output_buffer + PACKET_SIZE, CHUNK_SIZE);
        output_buffer_pos -= CHUNK_SIZE;
    }
}

inline void dts_encode() {
    if (use_dts == 1) {

    }
}

#include <exception>
#include <stdexcept>
#include <cxxabi.h>
#include <execinfo.h>

void print_stacktrace(int skip = 1) {
    void *callstack[128];
    int frames = backtrace(callstack, 128);
    char **strs = backtrace_symbols(callstack, frames);
    
    for (int i = skip; i < frames; ++i) {
        int status;
        char *demangled = abi::__cxa_demangle(strs[i], NULL, 0, &status);
        if (status == 0) {
            std::cerr << demangled << std::endl;
            free(demangled);
        } else {
            std::cerr << strs[i] << std::endl;
        }
    }
    free(strs);
}

int main(int argc, char* argv[]) {
    try {
    // Pin to CPU core 1
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(1, &cpuset);
    pthread_t current_thread = pthread_self();
    if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
        log("Failed to set CPU affinity to core 1");
    } else {
        log("Successfully pinned to CPU core 1");
    }

    process_args(argv, argc);
    if (use_dts == 1)
    {
        if (output_channels != 6) {
            log("DTS requires 6 channels (5.1), but only " + to_string(output_channels) + " were specified. Exiting.");
            exit(1);
        }
        if (output_samplerate != 44100 && output_samplerate != 48000) {
            log("DTS requires 44.1kHz or 48kHz but  " + to_string(output_channels) + " was specified. Exiting.");
            exit(1);
        }
        dca_context = dcaenc_create(
                        output_samplerate,
                        DCAENC_CHANNELS_3FRONT_2REAR,
                        1509000, // DVD bitrate
                        DCAENC_FLAG_IEC_WRAP | DCAENC_FLAG_LFE | DCAENC_FLAG_28BIT | DCAENC_FLAG_PERFECT_QMF);
    }
    lameProcessor = new AudioProcessor(output_channels, 2, 32, output_samplerate, output_samplerate, 1);
    log("Starting Ouput Mixer, sending UDP to " + output_ip +  ":" + to_string(output_port) + ", TCP Enabled: " + (tcp_output_fd > 0?"Yes":"No"));
    process_fd_args(argv, argc);
    log("Input FDs: ");
    for (int fd_idx = 0; fd_idx < output_fds.size(); fd_idx++)
        log(to_string(output_fds[fd_idx]));
    setup_header();
    setup_lame();
    setup_udp();
    setup_buffers();

    while (running) {
        if (!handle_receive_buffers()) {
            sleep(.5);
            continue;
        }
        mix_buffers();
        write_lame();
        downscale_buffer();
        if (output_buffer_pos < CHUNK_SIZE)
          continue;
        send_buffer();
        rotate_buffer();
    }
    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
        std::cerr << "Stack trace:" << std::endl;
        print_stacktrace();
    } catch (...) {
        std::cerr << "Caught unknown exception" << std::endl;
        std::cerr << "Stack trace:" << std::endl;
        print_stacktrace();
}
    return 0;
}
source_input_processor.cpp0000644000000000000000000003766415006161511015112 0ustar  rootroot#include <iostream>
#include <vector>
#include <string>
#include <unistd.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <deque>
#include <chrono>
#include <thread>
#include <atomic>
#include <sstream>
#include <climits>
#include <mutex>
#include <condition_variable>
#include <cstring>
#include <pthread.h>
#include <sched.h>
#include "audio_processor.h"

using namespace std;

#define CHUNK_SIZE 1152
#define HEADER_SIZE 5
#define PACKET_SIZE (CHUNK_SIZE + HEADER_SIZE)
#define TAG_SIZE 45

uint8_t packet_in_buffer[PACKET_SIZE + TAG_SIZE];
uint8_t receive_buffer[CHUNK_SIZE];
int32_t processed_buffer[CHUNK_SIZE * 8];
uint8_t *processed_buffer_int8 = (uint8_t *)processed_buffer;

int process_buffer_pos = 0;

string input_ip = "";
int fd_in = 0, fd_out = 0, data_fd_in = 0;
int output_channels = 0, output_samplerate = 0, output_chlayout1 = 0, output_chlayout2 = 0;
int delay = 0, timeshift_buffer_dur = 0;
float volume = 1;
std::chrono::steady_clock::time_pointtimeshift_last_change;
unsigned long timeshift_buffer_pos = 0;
float timeshift_backshift = 0;
std::mutex timeshift_mutex;
std::condition_variable timeshift_condition;

const auto TIMESHIFT_NOREMOVE_TIME = std::chrono::minutes(5);

std::deque<std::pair<std::chrono::steady_clock::time_point, std::vector<uint8_t>>> timeshift_buffer;
std::atomic<bool> threads_running(true);

uint8_t input_header[HEADER_SIZE] = {0};
int input_channels = 0, input_samplerate = 0, input_bitdepth = 0, input_chlayout1 = 0, input_chlayout2 = 0;

unique_ptr<AudioProcessor> audioProcessor = NULL;
std::mutex audioProcessor_mutex;

float new_eq[EQ_BANDS] = {1};

int *int_args[] = {
    NULL, &fd_in, &fd_out, &data_fd_in, &output_channels, &output_samplerate, &output_chlayout1, &output_chlayout2,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    &delay, &timeshift_buffer_dur,
};

float *float_args[] = {
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    &volume,
    &new_eq[0], &new_eq[1], &new_eq[2], &new_eq[3], &new_eq[4], &new_eq[5], &new_eq[6], &new_eq[7], &new_eq[8], &new_eq[9],
    &new_eq[10],&new_eq[11],&new_eq[12],&new_eq[13],&new_eq[14],&new_eq[15],&new_eq[16],&new_eq[17],
    NULL, NULL,
};

int config_argc = sizeof(int_args) / sizeof(int *);

void log(const string& message) {
    cerr << "[Source Input Processor " << getpid() << "] " << message << endl;
}

void process_args(int argc, char *argv[]) {
    if (argc <= config_argc) {
        log("Too few args");
        threads_running = false;
        return; // Return early to prevent accessing out-of-bounds array elements
    }
    input_ip = string(argv[1]);
    for (int argi = 0; argi < config_argc; argi++)
        if (int_args[argi] != NULL)
            *(int_args[argi]) = atoi(argv[argi + 1]);
    for (int argi = 0; argi < config_argc; argi++)
        if (float_args[argi] != NULL)
            *(float_args[argi]) = atof(argv[argi + 1]);
}

// This function checks if the incoming packet header has changed and updates the input parameters accordingly.
void check_update_header() {
    // Compare the current header with the new one received in the packet buffer.
    if (memcmp(input_header, packet_in_buffer + TAG_SIZE, HEADER_SIZE) != 0) {
        log("Got new header");
        // Update the input header with the new data.
        memcpy(input_header, packet_in_buffer + TAG_SIZE, HEADER_SIZE);
        
        // Extract sample rate from the header and convert it to integer format.
        input_samplerate = (input_header[0] & 0x7F) * ((input_header[0] & 0x80) ? 44100 : 48000);
        
        // Extract bit depth from the header and convert it to integer format.
        input_bitdepth = input_header[1];
        
        // Extract number of channels from the header and convert it to integer format.
        input_channels = input_header[2];
        
        // Extract channel layout from the header and convert it to integer format.
        input_chlayout1 = input_header[3];
        input_chlayout2 = input_header[4];
        
        log("Sample Rate: " + to_string(input_samplerate) + " -> " + to_string(output_samplerate));
        log("Bit Depth: " + to_string(input_bitdepth) + " -> 32");
        log("Channels: " + to_string(input_channels) + " -> " + to_string(output_channels));
        
        // Lock the audio processor mutex before updating the audio processor settings.
        audioProcessor_mutex.lock();
        // Create a new AudioProcessor instance with updated parameters.
        audioProcessor = make_unique<AudioProcessor>(input_channels, output_channels, input_bitdepth, input_samplerate, output_samplerate, volume);
        audioProcessor->setEqualizer(new_eq);
        // Unlock the audio processor mutex after updating the settings.
        audioProcessor_mutex.unlock();
    }
}

void receive_data_thread() {
    fd_set read_fds;
    struct timeval timeout;
    
    while (threads_running) {
        // Set up select with 5ms timeout
        FD_ZERO(&read_fds);
        FD_SET(fd_in, &read_fds);
        timeout.tv_sec = 0;
        timeout.tv_usec = 5000; // 5ms timeout
        
        // Wait for data with timeout
        int select_result = select(fd_in + 1, &read_fds, NULL, NULL, &timeout);
        
        // If select failed or timed out, continue the loop
        if (select_result <= 0) {
            continue;
        }
        
        // Check if our fd is ready for reading
        if (!FD_ISSET(fd_in, &read_fds)) {
            continue;
        }
        
        int bytes;
        while ((bytes = read(fd_in, packet_in_buffer, TAG_SIZE + PACKET_SIZE)) != TAG_SIZE + PACKET_SIZE ||
                (strcmp(input_ip.c_str(), reinterpret_cast<const char*>(packet_in_buffer)) != 0)) {
                    if (bytes == -1)
                        threads_running = false;
            }
        check_update_header();
        auto received_time = std::chrono::steady_clock::now();
        std::vector<uint8_t> new_packet(CHUNK_SIZE);
        memcpy(new_packet.data(), packet_in_buffer + TAG_SIZE + HEADER_SIZE, CHUNK_SIZE);
        
        // Critical section - add data to buffer
        {
            std::lock_guard<std::mutex> lock(timeshift_mutex);
            timeshift_buffer.emplace_back(received_time, std::move(new_packet));
            // Notify while holding the lock - this is actually the recommended pattern for condition variables
            timeshift_condition.notify_one(); // Notify waiting threads that new data is available
        }
    }
}

bool data_ready() {
    // Check if we have data and haven't reached the end
    if (timeshift_buffer.empty() || timeshift_buffer.size() <= timeshift_buffer_pos) {
        return false;
    }

    // Get current packet's scheduled play time
    auto current_time = timeshift_buffer.at(timeshift_buffer_pos).first + 
                       std::chrono::milliseconds(delay) + 
                       std::chrono::milliseconds((int)(timeshift_backshift*1000));

    // If we're at the last packet, don't allow playback
    if (timeshift_buffer_pos == timeshift_buffer.size() - 1) {
        return false;
    }

    // Otherwise check if it's time to play this packet
    return current_time <= std::chrono::steady_clock::now();
}

bool receive_data() {
    try {
        std::unique_lock<std::mutex> process_lock(timeshift_mutex);
        
        // If no data is ready, wait for notification with a timeout
        if (!data_ready()) {
            timeshift_condition.wait_for(process_lock, std::chrono::seconds(1), [&]() -> bool {
                return data_ready();
            });
        }

        if (!data_ready())
            return false;
        
        // Copy the data while holding the lock
        memcpy(receive_buffer, timeshift_buffer.at(timeshift_buffer_pos++).second.data(), CHUNK_SIZE);

        // Check if we need to clean up old data
        if (!timeshift_buffer.empty() && 
            timeshift_buffer.front().first + std::chrono::milliseconds(delay) + 
            std::chrono::milliseconds((int)(timeshift_backshift*1000)) + 
            std::chrono::seconds(timeshift_buffer_dur) < std::chrono::steady_clock::now()) {
            
            if (timeshift_last_change + TIMESHIFT_NOREMOVE_TIME < std::chrono::steady_clock::now()) {
                timeshift_buffer.pop_front();
                timeshift_buffer_pos--;
            }
        }
        
        return true;
        
    } catch (std::out_of_range) {
        log("Out of range 1");
        return false;
    }
}

void change_timeshift() {
    if (timeshift_buffer.size() == 0) {
        timeshift_buffer_pos = 0;
        timeshift_backshift = 0;
    } else {
        timeshift_mutex.lock();
        auto desired_time = std::chrono::steady_clock::now() - 
                            std::chrono::milliseconds((int)(timeshift_backshift*1000)) - 
                            std::chrono::milliseconds(delay);
        long closest_buffer_delta = LONG_MAX;
        
        for (long i=0; i<timeshift_buffer.size(); i++) {
            std::chrono::steady_clock::duration cur_delta = timeshift_buffer.at(i).first - desired_time;
            long cur_delta_num = abs(std::chrono::duration_cast<std::chrono::milliseconds>(cur_delta).count());
            if (cur_delta_num < closest_buffer_delta) {
                closest_buffer_delta = cur_delta_num;
                timeshift_buffer_pos = i;
            }
        }
        
        timeshift_backshift = std::chrono::duration_cast<std::chrono::duration<float>>(
            std::chrono::steady_clock::now() - timeshift_buffer.at(timeshift_buffer_pos).first + 
            std::chrono::milliseconds(delay)
        ).count();
        timeshift_mutex.unlock();
    }
}

void data_input_thread() {
    char line[256];
    fd_set read_fds;
    struct timeval timeout;

    while (threads_running) {
        // Set up select with 5ms timeout
        FD_ZERO(&read_fds);
        FD_SET(data_fd_in, &read_fds);
        timeout.tv_sec = 0;
        timeout.tv_usec = 5000; // 5ms timeout
        
        // Wait for data with timeout
        int select_result = select(data_fd_in + 1, &read_fds, NULL, NULL, &timeout);
        
        // If select failed or timed out, continue the loop
        if (select_result <= 0) {
            continue;
        }
        
        // Check if our fd is ready for reading
        if (!FD_ISSET(data_fd_in, &read_fds)) {
            continue;
        }
        
        if (read(data_fd_in, line, sizeof(line)) > 0) {
            std::string input(line);
            std::istringstream iss(input);
            std::string command;

            while (std::getline(iss, command)) {
                std::istringstream command_stream(command);
                std::string variable;
                float value;

                if (command_stream >> variable >> value) {
                    if (variable[0] == 'b' && variable.length() > 1 && std::isdigit(variable[1])) {
                        int index = std::stoi(variable.substr(1)) - 1;
                        if (index >= 0 && index < EQ_BANDS) {
                            new_eq[index] = value;
                        }
                    } else if (variable == "v") {
                        if (!audioProcessor)
                            continue;
                        volume = value;
                        audioProcessor_mutex.lock();
                        audioProcessor->setVolume(volume);
                        audioProcessor_mutex.unlock();
                    } else if (variable == "t") {
                        timeshift_backshift = value;
                        change_timeshift();
                    } else if (variable == "d") {
                        delay = (int)value;
                        change_timeshift();
                    }
                } else if (command == "a") {
                    if (!audioProcessor)
                        continue;
                    audioProcessor_mutex.lock();
                    audioProcessor->setEqualizer(new_eq);
                    audioProcessor_mutex.unlock();
                }
            }
        }
        
        // No need for sleep here as select already provides the timeout
    }
}

void write_output_buffer() {
    write(fd_out, processed_buffer_int8, CHUNK_SIZE);
    for (int pos = 0; pos < sizeof(processed_buffer) - CHUNK_SIZE; pos++)
        processed_buffer_int8[pos] = processed_buffer_int8[pos + CHUNK_SIZE];
    process_buffer_pos -= CHUNK_SIZE / sizeof(int32_t);
}

#include <exception>
#include <stdexcept>
#include <cxxabi.h>
#include <execinfo.h>

void print_stacktrace() {
    const int MAX_STACK_FRAMES = 100;
    void* stack_traces[MAX_STACK_FRAMES];
    int trace_size = backtrace(stack_traces, MAX_STACK_FRAMES);
    char** stack_strings = backtrace_symbols(stack_traces, trace_size);

    std::cerr << "Stack trace:" << std::endl;
    for (int i = 0; i < trace_size; ++i) {
        std::string stack_string(stack_strings[i]);
        size_t pos = stack_string.find('(');
        size_t pos2 = stack_string.find('+', pos);
        if (pos != std::string::npos && pos2 != std::string::npos) {
            std::string mangled_name = stack_string.substr(pos + 1, pos2 - pos - 1);
            int status;
            char* demangled_name = abi::__cxa_demangle(mangled_name.c_str(), nullptr, nullptr, &status);
            if (status == 0) {
                std::cerr << "  " << i << ": " << demangled_name << std::endl;
                free(demangled_name);
            } else {
                std::cerr << "  " << i << ": " << stack_strings[i] << std::endl;
            }
        } else {
            std::cerr << "  " << i << ": " << stack_strings[i] << std::endl;
        }
    }
    free(stack_strings);
}

void monitor_buffer_levels() {
        while (threads_running) {
        
        // Check process buffer
        size_t process_buffer_size = process_buffer_pos * sizeof(int32_t);
        
        // Calculate percentages
        double process_buffer_percentage = (double)process_buffer_size / (CHUNK_SIZE * 8) * 100;
        
        // Log if any buffer exceeds thresholds
        if (process_buffer_percentage > 100) {
            log("CRITICAL: Buffer overflow - Process: " + std::to_string(process_buffer_percentage) + "%");
        }
        
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

int main(int argc, char *argv[]) {
    try {
        // Pin to CPU core 1
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        CPU_SET(1, &cpuset);
        pthread_t current_thread = pthread_self();
        if (pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset) != 0) {
            log("Failed to set CPU affinity to core 1");
        } else {
            log("Successfully pinned to CPU core 1");
        }

        timeshift_last_change = std::chrono::steady_clock::time_point(std::chrono::steady_clock::duration::min());
        process_args(argc, argv);
        log("Starting source input processor " + input_ip);

        std::thread receive_thread(receive_data_thread);
        std::thread data_thread(data_input_thread);
        std::thread monitor_thread(monitor_buffer_levels);

        while (threads_running) {
            if (!receive_data()) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
                continue;
            }
            if (audioProcessor) {
                audioProcessor_mutex.lock();
                int processed_samples = audioProcessor->processAudio(receive_buffer, processed_buffer + process_buffer_pos);
                audioProcessor_mutex.unlock();
                process_buffer_pos += processed_samples;

                while (process_buffer_pos >= CHUNK_SIZE / sizeof(int32_t))
                    write_output_buffer();
            }
        }

        receive_thread.join();
        data_thread.join();
        monitor_thread.join();

        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Exception caught: " << e.what() << std::endl;
        print_stacktrace();
        return 1;
    } catch (...) {
        std::cerr << "Unknown exception caught" << std::endl;
        print_stacktrace();
        return 1;
    }
}
speaker_mix.cpp0000644000000000000000000003037614774646173012623 0ustar  rootroot#include "audio_processor.h"
#include <emmintrin.h>
#include <immintrin.h>


void AudioProcessor::updateSpeakerMix() {
    // Fills out the speaker mix table speaker_mix[][] with the current configuration.
    memset(speaker_mix, 0, sizeof(speaker_mix));
    // speaker_mix[input channel][output channel] = gain;
    // Ex: To map Left on Stereo to Right on Stereo at half volume you would do:
    // speaker_mix[0][1] = .5;
    switch (inputChannels)
    {
    case 1: // Mono, Ch 0: Left
        // Mono -> All
        for (int output_channel = 0; output_channel < MAX_CHANNELS; output_channel++) // Write the left (first) speaker to every channel
            speaker_mix[0][output_channel] = 1;
        break;
    case 2: // Stereo, Ch 0: Left, Ch 1: Right
        switch (outputChannels)
        {
        case 1:                     // Stereo -> Mono
            speaker_mix[0][0] = .5; // Left to mono .5 vol
            speaker_mix[1][0] = .5; // Right to mono .5 vol
            break;
        case 2:                    // Stereo -> Stereo
            speaker_mix[0][0] = 1; // Left to Left
            speaker_mix[1][1] = 1; // Right to Right
            break;
        case 4:
            speaker_mix[0][0] = 1; // Left to Front Left
            speaker_mix[1][1] = 1; // Right to Front Right
            speaker_mix[0][2] = 1; // Left to Back Left
            speaker_mix[1][3] = 1; // Right to Back Right
            break;
        case 6: // Stereo -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = 1;  // Left to Front Left
            speaker_mix[0][5] = 1;  // Left to Rear Left
            speaker_mix[1][1] = 1;  // Right to Front Right
            speaker_mix[1][6] = 1;  // Right to Rear Right
            speaker_mix[0][3] = .5; // Left to Center Half Vol
            speaker_mix[1][3] = .5; // Right to Center Half Vol
            speaker_mix[0][4] = .5; // Right to Sub Half Vol
            speaker_mix[1][4] = .5; // Left to Sub Half Vol
            break;
        case 8: // Stereo -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1;  // Left to Front Left
            speaker_mix[0][6] = 1;  // Left to Side Left
            speaker_mix[0][4] = 1;  // Left to Rear Left
            speaker_mix[1][1] = 1;  // Right to Front Right
            speaker_mix[1][7] = 1;  // Right to Side Right
            speaker_mix[1][5] = 1;  // Right to Rear Right
            speaker_mix[0][2] = .5; // Left to Center Half Vol
            speaker_mix[1][2] = .5; // Right to Center Half Vol
            speaker_mix[0][3] = .5; // Right to Sub Half Vol
            speaker_mix[1][3] = .5; // Left to Sub Half Vol
            break;
        }
        break;
    case 4:
        switch (outputChannels)
        {
        case 1:                      // Quad -> Mono
            speaker_mix[0][0] = .25; // Front Left to Mono
            speaker_mix[1][0] = .25; // Front Right to Mono
            speaker_mix[2][0] = .25; // Rear Left to Mono
            speaker_mix[3][0] = .25; // Rear Right to Mono
            break;
        case 2:                     // Quad -> Stereo
            speaker_mix[0][0] = .5; // Front Left to Left
            speaker_mix[1][1] = .5; // Front Right to Right
            speaker_mix[2][0] = .5; // Rear Left to Left
            speaker_mix[3][1] = .5; // Rear Right to Right
            break;
        case 4:
            speaker_mix[0][0] = 1; // Front Left to Front Left
            speaker_mix[1][1] = 1; // Front Right to Front Right
            speaker_mix[2][2] = 1; // Rear Left to Rear Left
            speaker_mix[3][3] = 1; // Rear Right to Rear Right
            break;
        case 6: // Quad -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = 1;   // Front Left to Front Left
            speaker_mix[1][1] = 1;   // Front Right to Front Right
            speaker_mix[0][2] = .5;  // Front Left to Center
            speaker_mix[1][2] = .5;  // Front Right to Center
            speaker_mix[0][3] = .25; // Front Left to LFE
            speaker_mix[1][3] = .25; // Front Right to LFE
            speaker_mix[2][3] = .25; // Rear Left to LFE
            speaker_mix[3][3] = .25; // Rear Right to LFE
            speaker_mix[2][4] = 1;   // Rear Left to Rear Left
            speaker_mix[3][5] = 1;   // Rear Right to Rear Right
            break;
        case 8: // Quad -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1;   // Front Left to Front Left
            speaker_mix[1][1] = 1;   // Front Right to Front Right
            speaker_mix[0][2] = .5;  // Front Left to Center
            speaker_mix[1][2] = .5;  // Front Right to Center
            speaker_mix[0][3] = .25; // Front Left to LFE
            speaker_mix[1][3] = .25; // Front Right to LFE
            speaker_mix[2][3] = .25; // Rear Left to LFE
            speaker_mix[3][3] = .25; // Rear Right to LFE
            speaker_mix[2][4] = 1;   // Rear Left to Rear Left
            speaker_mix[3][5] = 1;   // Rear Right to Rear Right
            speaker_mix[0][6] = .5;  // Front Left to Side Left
            speaker_mix[1][7] = .5;  // Front Right to Side Right
            speaker_mix[2][6] = .5;  // Rear Left to Side Left
            speaker_mix[3][7] = .5;  // Rear Right to Side Right
            break;
        }
        break;
    case 6:
        switch (outputChannels)
        {
        case 1:                     // 5.1 Surround -> Mono
            speaker_mix[0][0] = .2; // Front Left to Mono
            speaker_mix[1][0] = .2; // Front Right to Mono
            speaker_mix[2][0] = .2; // Center to Mono
            speaker_mix[4][0] = .2; // Rear Left to Mono
            speaker_mix[5][0] = .2; // Rear Right to Mono
            break;
        case 2:                      // 5.1 Surround -> Stereo
            speaker_mix[0][0] = .33; // Front Left to Left
            speaker_mix[1][1] = .33; // Front Right to Right
            speaker_mix[2][0] = .33; // Center to Left
            speaker_mix[2][1] = .33; // Center to Right
            speaker_mix[4][0] = .33; // Rear Left to Left
            speaker_mix[5][1] = .33; // Rear Right to Right
            break;
        case 4:
            speaker_mix[0][0] = .66; // Front Left to Front Left
            speaker_mix[1][1] = .66; // Front Right to Front Right
            speaker_mix[2][0] = .33; // Center to Front Left
            speaker_mix[2][1] = .33; // Center to Front Right
            speaker_mix[4][2] = 1;   // Rear Left to Rear Left
            speaker_mix[5][3] = 1;   // Rear Right to Rear Right
            break;
        case 6: // 5.1 Surround -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = 1; // Front Left to Front Left
            speaker_mix[1][1] = 1; // Front Right to Front Right
            speaker_mix[2][2] = 1; // Center to Center
            speaker_mix[3][3] = 1; // LFE to LFE
            speaker_mix[4][4] = 1; // Rear Left to Rear Left
            speaker_mix[5][5] = 1; // Rear Right to Rear Right
            break;
        case 8: // 5.1 Surround -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1;  // Front Left to Front Left
            speaker_mix[1][1] = 1;  // Front Right to Front Right
            speaker_mix[2][2] = 1;  // Center to Center
            speaker_mix[3][3] = 1;  // LFE to LFE
            speaker_mix[4][4] = 1;  // Rear Left to Rear Left
            speaker_mix[5][5] = 1;  // Rear Right to Rear Right
            speaker_mix[0][6] = .5; // Front Left to Side Left
            speaker_mix[1][7] = .5; // Front Right to Side Right
            speaker_mix[4][6] = .5; // Rear Left to Side Left
            speaker_mix[5][7] = .5; // Rear Right to Side Right
            break;
        }
        break;
    case 8:
        switch (outputChannels)
        {
        case 1:                              // 7.1 Surround -> Mono
            speaker_mix[0][0] = 1.0f / 7.0f; // Front Left to Mono
            speaker_mix[1][0] = 1.0f / 7.0f; // Front Right to Mono
            speaker_mix[2][0] = 1.0f / 7.0f; // Center to Mono
            speaker_mix[4][0] = 1.0f / 7.0f; // Rear Left to Mono
            speaker_mix[5][0] = 1.0f / 7.0f; // Rear Right to Mono
            speaker_mix[6][0] = 1.0f / 7.0f; // Side Left to Mono
            speaker_mix[7][0] = 1.0f / 7.0f; // Side Right to Mono
            break;
        case 2:                       // 7.1 Surround -> Stereo
            speaker_mix[0][0] = .5;   // Front Left to Left
            speaker_mix[1][1] = .5;   // Front Right to Right
            speaker_mix[2][0] = .25;  // Center to Left
            speaker_mix[2][1] = .25;  // Center to Right
            speaker_mix[4][0] = .125; // Rear Left to Left
            speaker_mix[5][1] = .125; // Rear Right to Right
            speaker_mix[6][0] = .125; // Side Left to Left
            speaker_mix[7][1] = .125; // Side Right to Right
            break;
        case 4:                      // 7.1 Surround -> Quad
            speaker_mix[0][0] = .5;  // Front Left to Front Left
            speaker_mix[1][1] = .5;  // Front Right to Front Right
            speaker_mix[2][0] = .25; // Center to Front Left
            speaker_mix[2][1] = .25; // Center to Front Right
            speaker_mix[4][2] = .66; // Rear Left to Rear Left
            speaker_mix[5][3] = .66; // Rear Right to Rear Right
            speaker_mix[6][0] = .25; // Side Left to Front Left
            speaker_mix[7][1] = .25; // Side Left to Front Right
            speaker_mix[6][2] = .33; // Side Left to Rear Left
            speaker_mix[7][3] = .33; // Side Left to Rear Right
            break;
        case 6: // 7.1 Surround -> 5.1 Surround
            // FL FR C LFE BL BR
            speaker_mix[0][0] = .66; // Front Left to Front Left
            speaker_mix[1][1] = .66; // Front Right to Front Right
            speaker_mix[2][2] = 1;   // Center to Center
            speaker_mix[3][3] = 1;   // LFE to LFE
            speaker_mix[4][4] = .66; // Rear Left to Rear Left
            speaker_mix[5][5] = .66; // Rear Right to Rear Right
            speaker_mix[6][0] = .33; // Side Left to Front Left
            speaker_mix[7][1] = .33; // Side Right to Front Right
            speaker_mix[6][4] = .33; // Side Left to Rear Left
            speaker_mix[7][5] = .33; // Side Right to Rear Right
            break;
        case 8: // 7.1 Surround -> 7.1 Surround
            // FL FR C LFE BL BR SL SR
            speaker_mix[0][0] = 1; // Front Left to Front Left
            speaker_mix[1][1] = 1; // Front Right to Front Right
            speaker_mix[2][2] = 1; // Center to Center
            speaker_mix[3][3] = 1; // LFE to LFE
            speaker_mix[4][4] = 1; // Rear Left to Rear Left
            speaker_mix[5][5] = 1; // Rear Right to Rear Right
            speaker_mix[6][6] = 1; // Side Left to Side Left
            speaker_mix[7][7] = 1; // Side Right to Side Right
            break;
        }
        break;
    }
}

void AudioProcessor::mixSpeakers() {
    //memset(remixed_channel_buffers, 0, sizeof(remixed_channel_buffers));
    for (int pos = 0; pos < channel_buffer_pos; pos++) {
        for (int output_channel = 0; output_channel < outputChannels; output_channel++) {
            float mixed_sample = 0.0f;
            for (int input_channel = 0; input_channel < inputChannels; input_channel++) {
                mixed_sample += static_cast<float>(channel_buffers[input_channel][pos]) 
                                * speaker_mix[input_channel][output_channel];
            }
            // Apply soft clipping
            mixed_sample = softClip(mixed_sample / INT32_MAX);
            // Convert back to int32_t
            remixed_channel_buffers[output_channel][pos] = static_cast<int32_t>(mixed_sample * INT32_MAX);
        }
    }
}

void AudioProcessor::splitBufferToChannels() {
    for (int i = 0; i < resample_buffer_pos; i++) {
        int channel = i % inputChannels;
        int pos = i / inputChannels;
        channel_buffers[channel][pos] = resampled_buffer[i];
    }
    channel_buffer_pos = resample_buffer_pos / inputChannels;
}

void AudioProcessor::mergeChannelsToBuffer() {
    merged_buffer_pos = 0;
    for (int pos = 0; pos < channel_buffer_pos; ++pos) {
        for (int channel = 0; channel < outputChannels; ++channel) {
            merged_buffer[merged_buffer_pos++] = remixed_channel_buffers[channel][pos];
        }
    }
}
audio_processor.h0000644000000000000000000000444314707023704013136 0ustar  rootroot#ifndef AUDIO_PROCESSOR_H
#define AUDIO_PROCESSOR_H

#include <cstdint>
#include <cstring>
#include <thread>
#include <atomic>
#include "libsamplerate/include/samplerate.h"

#define MAX_CHANNELS 8
#define EQ_BANDS 18
#define CHUNK_SIZE 1152

struct SRC_STATE_tag;
typedef SRC_STATE_tag SRC_STATE;
class Biquad;

class AudioProcessor {
public:
    AudioProcessor(int inputChannels, int outputChannels, int inputBitDepth, int inputSampleRate, int outputSampleRate, float volume);
    ~AudioProcessor();

    int processAudio(const uint8_t* inputBuffer, int32_t* outputBuffer);
    void setVolume(float newVolume);
    void setEqualizer(const float* newEq);

protected:
    int inputChannels, outputChannels;
    int inputSampleRate, outputSampleRate;
    int inputBitDepth;
    float volume;
    float eq[EQ_BANDS];
    float speaker_mix[MAX_CHANNELS][MAX_CHANNELS];

    uint8_t receive_buffer[CHUNK_SIZE * 4];
    int32_t scaled_buffer[CHUNK_SIZE * 32];
    uint8_t *scaled_buffer_int8 = (uint8_t *)scaled_buffer;
    int32_t resampled_buffer[CHUNK_SIZE * 32];
    int32_t channel_buffers[MAX_CHANNELS][CHUNK_SIZE * 32];
    int32_t remixed_channel_buffers[MAX_CHANNELS][CHUNK_SIZE * 32];
    int32_t merged_buffer[CHUNK_SIZE * 32];
    int32_t processed_buffer[CHUNK_SIZE * 32]; 

    int scale_buffer_pos = 0;
    int process_buffer_pos = 0;
    int merged_buffer_pos = 0;
    int resample_buffer_pos = 0;
    int channel_buffer_pos = 0;

    SRC_STATE* sampler;
    SRC_STATE* downsampler;
    float resampler_data_in[CHUNK_SIZE * MAX_CHANNELS * 8];
    float resampler_data_out[CHUNK_SIZE * MAX_CHANNELS * 8];

    Biquad* filters[MAX_CHANNELS][EQ_BANDS];
    Biquad* dcFilters[MAX_CHANNELS];

    void updateSpeakerMix();
    void setupBiquad();
    void initializeSampler();
    void scaleBuffer();
    void volumeAdjust();
    float softClip(float sample);
    void resample();
    void downsample();
    void splitBufferToChannels();
    void mixSpeakers();
    void equalize();
    void mergeChannelsToBuffer();
    void noiseShapingDither();
    void setupDCFilter();
    void removeDCOffset();
    bool isProcessingRequired();
    bool isProcessingRequiredCheck();
    void monitorBuffers();

    // Buffer monitoring thread
    std::thread monitor_thread;
    std::atomic<bool> monitor_running;
};

#endif // AUDIO_PROCESSOR_H
layout_mixer.h0000644000000000000000000000000014672710230012436 0ustar  rootrootutils.h0000644000000000000000000000000014650565122011061 0ustar  rootroot