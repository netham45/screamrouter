# Task 01_01: Define C++ Structs for Desired Configuration State

**Objective:** Create a new header file, `audio_engine_config_types.h`, within the `src/configuration/` directory. This file will define the C++ data structures necessary to represent the desired state of the audio engine, which will be consumed by the `AudioEngineConfigApplier`.

**File to Create:** `src/configuration/audio_engine_config_types.h`

**Namespace:** `screamrouter::config`

**Details:**

1.  **Include Guards and Necessary Headers:**
    *   Start with standard include guards (`#ifndef AUDIO_ENGINE_CONFIG_TYPES_H`, `#define AUDIO_ENGINE_CONFIG_TYPES_H`, `#endif`).
    *   Include `<string>`, `<vector>`, `<map>`, `<set>` as needed.
    *   Include `src/audio_engine/audio_types.h` to reference existing structs like `screamrouter::audio::SinkConfig` and `screamrouter::audio::SourceConfig` (the C++ versions).

2.  **`AppliedSourcePathParams` Struct:**
    *   This struct represents a single, unique path from an original audio input to a specific sink, including all processing parameters for that path and the output format required by the target sink.
    *   **Fields:**
        *   `std::string path_id;`: A unique identifier for this specific source-to-sink path. This could be generated by the Python layer (e.g., "source\_tag\_to\_sink\_id") or by the `AudioEngineConfigApplier` if it needs to manage these. For now, assume Python provides it or it's derived.
        *   `std::string source_tag;`: The original identifier of the input source (e.g., IP address, "Desktop Audio"). This is used to tell `RtpReceiver` which raw stream to listen to.
        *   `std::string target_sink_id;`: The ID of the sink this path is intended for.
        *   `float volume = 1.0f;`: Volume for this specific path.
        *   `std::vector<float> eq_values;`: Equalizer settings for this path (size should match `EQ_BANDS` from `audio_types.h`). Initialize to flat if empty.
        *   `int delay_ms = 0;`: Delay in milliseconds for this path.
        *   `float timeshift_sec = 0.0f;`: Timeshift in seconds for this path.
        *   `int target_output_channels;`: The number of audio channels required by the `target_sink_id`.
        *   `int target_output_samplerate;`: The sample rate required by the `target_sink_id`.
        *   `std::string generated_instance_id;`: **(To be filled by `AudioEngineConfigApplier`)** This will store the `instance_id` returned by `AudioManager::configure_source()` for the `SourceInputProcessor` created for this specific path. It's initially empty when passed from Python.

3.  **`AppliedSinkParams` Struct:**
    *   This struct represents a configured sink in the audio engine.
    *   **Fields:**
        *   `std::string sink_id;`: Unique identifier for the sink.
        *   `screamrouter::audio::SinkConfig sink_engine_config;`: The C++ `SinkConfig` struct (from `src/audio_engine/audio_types.h`) containing all parameters needed by `AudioManager::add_sink()` (e.g., output IP, port, bit depth, sample rate, channels, channel layout, TCP usage).
        *   `std::vector<std::string> connected_source_path_ids;`: A list of `path_id`s (from `AppliedSourcePathParams`) that should be connected to this sink. The `AudioEngineConfigApplier` will use these `path_id`s to look up the corresponding `generated_instance_id` from `AppliedSourcePathParams` to make the actual connection in `AudioManager`.

4.  **`DesiredEngineState` Struct:**
    *   This is the top-level struct that will be passed from Python (via Pybind11) to the `AudioEngineConfigApplier`.
    *   **Fields:**
        *   `std::vector<AppliedSourcePathParams> source_paths;`: A list of all desired source-to-sink paths, each with its specific processing parameters and target output format.
        *   `std::vector<AppliedSinkParams> sinks;`: A list of all desired sinks and their configurations, including which source paths connect to them.

**Example Structure (Conceptual):**

```cpp
// src/configuration/audio_engine_config_types.h
#ifndef AUDIO_ENGINE_CONFIG_TYPES_H
#define AUDIO_ENGINE_CONFIG_TYPES_H

#include <string>
#include <vector>
#include "src/audio_engine/audio_types.h" // For audio::SinkConfig, EQ_BANDS

namespace screamrouter {
namespace config {

struct AppliedSourcePathParams {
    std::string path_id;                 // e.g., "DesktopAudio_to_LivingRoomSpeakers"
    std::string source_tag;              // e.g., "192.168.1.100"
    std::string target_sink_id;          // e.g., "LivingRoomSpeakers"
    
    float volume = 1.0f;
    std::vector<float> eq_values;        // Should be initialized to EQ_BANDS size
    int delay_ms = 0;
    float timeshift_sec = 0.0f;
    
    int target_output_channels;
    int target_output_samplerate;
    
    std::string generated_instance_id; // Filled by C++ applier

    // Constructor to initialize eq_values correctly
    AppliedSourcePathParams() : eq_values(audio::EQ_BANDS, 1.0f) {}
};

struct AppliedSinkParams {
    std::string sink_id;
    audio::SinkConfig sink_engine_config; // The C++ struct from audio_types.h
    std::vector<std::string> connected_source_path_ids; // List of path_id from AppliedSourcePathParams
};

struct DesiredEngineState {
    std::vector<AppliedSourcePathParams> source_paths;
    std::vector<AppliedSinkParams> sinks;
};

} // namespace config
} // namespace screamrouter

#endif // AUDIO_ENGINE_CONFIG_TYPES_H
```

**Acceptance Criteria:**

*   The file `src/configuration/audio_engine_config_types.h` is created.
*   The structs `AppliedSourcePathParams`, `AppliedSinkParams`, and `DesiredEngineState` are defined within the `screamrouter::config` namespace as specified.
*   The fields within each struct match the descriptions.
*   The file includes necessary headers and include guards.
*   The `AppliedSourcePathParams` constructor initializes `eq_values` to the correct size (e.g., `audio::EQ_BANDS`) with default flat values (e.g., 1.0f).
