# Task 03_01: Create Pybind11 Bindings for C++ Configuration Structs

**Objective:** Modify the Pybind11 bindings file (`src/audio_engine/bindings.cpp`) to expose the newly created C++ configuration structs (`AppliedSourcePathParams`, `AppliedSinkParams`, `DesiredEngineState`) to the Python layer. This allows Python code (specifically `ConfigurationManager.py`) to create and populate these structs before passing them to the C++ `AudioEngineConfigApplier`.

**File to Modify:** `src/audio_engine/bindings.cpp`

**Details:**

1.  **Include Necessary Headers:**
    *   At the top of `bindings.cpp`, add an include for the new types header:
        ```cpp
        #include "src/configuration/audio_engine_config_types.h" 
        ```
    *   Ensure `<pybind11/stl.h>` is included to handle automatic conversions for `std::vector` and `std::string`.

2.  **Import Namespace:**
    *   Add a `using` directive for the new namespace to simplify binding code:
        ```cpp
        using namespace screamrouter::config;
        ```

3.  **Bind `AppliedSourcePathParams` Struct:**
    *   Inside the `PYBIND11_MODULE` block, use `py::class_` to bind the struct:
    ```cpp
    py::class_<AppliedSourcePathParams>(m, "AppliedSourcePathParams", "Parameters for a specific source-to-sink audio path")
        .def(py::init<>()) // Bind default constructor (initializes eq_values)
        .def_readwrite("path_id", &AppliedSourcePathParams::path_id, "Unique ID for this path (e.g., source_tag_to_sink_id)")
        .def_readwrite("source_tag", &AppliedSourcePathParams::source_tag, "Original source identifier (e.g., IP address)")
        .def_readwrite("target_sink_id", &AppliedSourcePathParams::target_sink_id, "ID of the target sink for this path")
        .def_readwrite("volume", &AppliedSourcePathParams::volume, "Volume for this path")
        .def_readwrite("eq_values", &AppliedSourcePathParams::eq_values, "Equalizer settings for this path (list/vector of floats)")
        .def_readwrite("delay_ms", &AppliedSourcePathParams::delay_ms, "Delay in milliseconds for this path")
        .def_readwrite("timeshift_sec", &AppliedSourcePathParams::timeshift_sec, "Timeshift in seconds for this path")
        .def_readwrite("target_output_channels", &AppliedSourcePathParams::target_output_channels, "Required output channels for the target sink")
        .def_readwrite("target_output_samplerate", &AppliedSourcePathParams::target_output_samplerate, "Required output sample rate for the target sink")
        .def_readwrite("generated_instance_id", &AppliedSourcePathParams::generated_instance_id, "(Read-only from Python perspective) Instance ID generated by C++"); 
        // Note: generated_instance_id is filled by C++, making it read-write might be okay but conceptually it's an output.
    ```

4.  **Bind `AppliedSinkParams` Struct:**
    *   Bind the struct, including the nested `audio::SinkConfig`.
    ```cpp
    py::class_<AppliedSinkParams>(m, "AppliedSinkParams", "Parameters for a configured sink")
        .def(py::init<>()) // Bind default constructor
        .def_readwrite("sink_id", &AppliedSinkParams::sink_id, "Unique identifier for the sink")
        // Bind the nested C++ SinkConfig. Python will need to create/populate this C++ struct instance.
        .def_readwrite("sink_engine_config", &AppliedSinkParams::sink_engine_config, "C++ SinkConfig parameters for AudioManager") 
        .def_readwrite("connected_source_path_ids", &AppliedSinkParams::connected_source_path_ids, "List of path_ids connected to this sink");
    ```
    *   **Important:** Ensure `audio::SinkConfig` itself is already bound (it appears to be in the provided `bindings.cpp` content). If not, it would need to be bound similarly to how `audio::SourceConfig` is bound.

5.  **Bind `DesiredEngineState` Struct:**
    *   Bind the top-level container struct.
    ```cpp
    py::class_<DesiredEngineState>(m, "DesiredEngineState", "Represents the complete desired state of the audio engine")
        .def(py::init<>()) // Bind default constructor
        .def_readwrite("source_paths", &DesiredEngineState::source_paths, "List of all desired AppliedSourcePathParams")
        .def_readwrite("sinks", &DesiredEngineState::sinks, "List of all desired AppliedSinkParams");
    ```

**Placement:** Add these new `py::class_` definitions within the `PYBIND11_MODULE(screamrouter_audio_engine, m)` block, alongside the existing bindings for `SourceConfig`, `SinkConfig`, and `AudioManager`.

**Acceptance Criteria:**

*   The `src/audio_engine/bindings.cpp` file is modified.
*   Includes for `<pybind11/stl.h>` and `src/configuration/audio_engine_config_types.h` are present.
*   The `screamrouter::config` namespace is used.
*   `py::class_` bindings are added for `AppliedSourcePathParams`, `AppliedSinkParams`, and `DesiredEngineState`.
*   All relevant member variables of these structs are exposed to Python using `.def_readwrite`.
*   Default constructors (`py::init<>()`) are bound for each struct.
*   The code compiles successfully as part of the Python extension build process.
*   Python code can now `import screamrouter_audio_engine` and instantiate/access members of `screamrouter_audio_engine.AppliedSourcePathParams`, `screamrouter_audio_engine.AppliedSinkParams`, and `screamrouter_audio_engine.DesiredEngineState`.
